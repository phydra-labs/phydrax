{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Phydrax is a scientific machine learning toolkit for PDEs, constraints, and domain-aware models, built on JAX + Equinox. It provides composable building blocks for geometry, operators, and training pipelines, with an emphasis on explicit control of objectives and data sampling.</p>"},{"location":"#unifying-view-minimize-functionals-over-domains","title":"Unifying view: minimize functionals over domains","text":"<p>Phydrax organizes PDE/physics learning around a single pattern:</p> <p>1) choose a domain (and components like interior/boundary/slices), 2) define fields as functions on that domain, 3) build composable operators of domain functions, 4) build scalar objectives (functionals) as integrals/means of residuals over components, 5) minimize the resulting functional.</p> <p>Conceptually, a typical objective has the form</p> \\[ L[u] = \\sum_i w_i\\int_{\\Omega_i}\\rho_i(u(z))\\,d\\mu_i(z), \\] <p>where each term corresponds to a constraint, data fit, or integral target on a domain component.</p>"},{"location":"#core-objects-mental-model","title":"Core objects (mental model)","text":"<p>Most workflows are composing a few primitives:</p> <ul> <li>Domain: a labeled product space \\(\\Omega=\\Omega_x\\times\\Omega_t\\times\\cdots\\).</li> <li>Component: a subset like interior/boundary/initial slice where a term lives.</li> <li>DomainFunction: a field \\(u:\\Omega\\to\\mathbb{R}^m\\) with explicit label dependencies.</li> <li>Operators: maps \\(u\\mapsto r\\) like \\(\\nabla u\\), \\(\\Delta u\\), \\(\\partial_t u\\), integrals, etc.</li> <li>Constraints: scalar loss terms built from residuals on components.</li> <li>FunctionalSolver: sums constraints into a differentiable scalar objective and runs optimization.</li> </ul> <p>Optional (but central in many PDE problems):</p> <ul> <li>Enforced constraints: build an ansatz \\(\\tilde u\\) that satisfies boundary/initial conditions by construction,   then train on the remaining terms.</li> </ul>"},{"location":"#core-flow","title":"Core flow","text":"<p>If you are new to the library, start with:</p> <ol> <li>Define a domain (space, time, or products of both).</li> <li>Define functions on that domain.</li> <li>Add constraints and operators to construct a loss \\(L\\).</li> <li>Train or evaluate with a solver.</li> </ol>"},{"location":"#example","title":"Example","text":"<p>This example trains a neural field \\(u_\\theta(x,y)\\) to satisfy</p> \\[ \\Delta u = 4 \\quad \\text{in }\\Omega=[-1,1]^2,\\qquad u = g \\quad \\text{on }\\partial\\Omega, \\] <p>The configurations are kept minimal for structural demonstration purposes. Convergence requires larger networks, more iterations, and hyperparameter tuning.</p> <pre><code>import jax.numpy as jnp\nimport jax.random as jr\nimport optax\nimport phydrax as phx\n\ngeom = phx.domain.Square(center=(0.0, 0.0), side=2.0)  # [-1,1]^2, label \"x\"\n\n# Exact solution / boundary target g(x,y) = x^2 + y^2\n@geom.Function(\"x\")\ndef g(x):\n    return x[0] ** 2 + x[1] ** 2\n\n# Trainable field u_theta(x)\nmodel = phx.nn.MLP(\n    in_size=2,\n    out_size=\"scalar\",\n    width_size=16,\n    depth=2,\n    key=jr.key(0),\n)\nu = geom.Model(\"x\")(model)\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\n\n# Interior PDE residual: \u0394u - 4 = 0\npde = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    geom,\n    operator=lambda f: phx.operators.laplacian(f, var=\"x\") - 4.0,\n    num_points=64,\n    structure=structure,\n    reduction=\"mean\",\n)\n\n# Soft Dirichlet boundary: u - g = 0 on \u2202\u03a9\nboundary = geom.component({\"x\": phx.domain.Boundary()})\nbc = phx.constraints.ContinuousDirichletBoundaryConstraint(\n    \"u\",\n    boundary,\n    target=g,\n    num_points=32,\n    structure=structure,\n    weight=10.0,\n    reduction=\"mean\",\n)\n\nsolver = phx.solver.FunctionalSolver(functions={\"u\": u}, constraints=[pde, bc])\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Requires Python 3.11+.</p> <p>First, install your preferred JAX distribution. Otherwise, Phydrax will default to the cpu version.</p> <pre><code>uv add phydrax\n</code></pre> <p>No special builds or containers. Batteries-included, ready to go.</p>"},{"location":"#why-jax","title":"Why JAX?","text":"<p>Partial Differential Equations and their variants are most naturally expressed in the language of operators, which can be thought of as maps between function spaces. While functions map points to values (think <code>Array</code>s), operators map entire functions to new functions.</p> <p>JAX\u2019s functional programming model and higher-order transformations act precisely as operators on functions. This creates a clean correspondence between the abstract operator calculus of PDEs and their concrete, composable, high-performance numerical realizations.</p> <p>Furthermore, the JAX SciML ecosystem contains many fantastic libraries and projects, and Phydrax aims to be fully-compatible with them to push the possibilities of SciML as far as they can go.</p>"},{"location":"#license","title":"License","text":"<p>Source-available under the Phydra Non-Production License (PNPL). Research/piloting encouraged.  Production/commercial use requires a separate license.</p> <p>For production licensing and all other commercial inquiries including consulting, contracting, and custom software: partner@phydra.ai, or DM us on X.</p> <p> Next: All of Phydrax</p>"},{"location":"all-of-phydrax/","title":"All of Phydrax","text":"<p>This page provides a high-level map of the library, how the parts fit together, and where to look for specific functionality.</p>"},{"location":"all-of-phydrax/#unifying-formalism-minimizing-functionals-over-domains","title":"Unifying formalism: minimizing functionals over domains","text":"<p>Phydrax is designed to make a single idea modular:</p> <p>Define fields on labeled domains and minimize scalar functionals built from operators and measures over domain components.</p> <p>A typical objective can be written as</p> \\[ L[u] = \\sum_i w_i\\int_{\\Omega_i}\\rho_i(u(z))\\,d\\mu_i(z), \\] <p>where each \\(\\Omega_i\\) is a domain component (interior, boundary, initial slice, data subset, \u2026), \\(\\mu_i\\) is the induced measure, and \\(\\rho_i\\) is a pointwise residual penalty (often a squared norm). The library is organized so each piece (domains, sampling, operators, constraints, solvers) cleanly corresponds to a part of this expression.</p>"},{"location":"all-of-phydrax/#the-compositional-contract","title":"The compositional contract","text":"<p>At a practical level, most workflows look like:</p> <p>1) choose a domain \\(\\Omega\\) and a component \\(\\Omega_{\\text{comp}}\\subseteq\\Omega\\), 2) define one or more fields \\(u_\\theta:\\Omega\\to\\mathbb{R}^m\\) as <code>DomainFunction</code>s, 3) build residual operators \\(r=\\mathcal{N}(u_\\theta,\\dots)\\) using <code>phydrax.operators</code>, 4) turn residuals into constraint terms \\(\\ell_i\\) via sampling + reduction (mean/integral), 5) sum terms into a functional \\(L=\\sum_i \\ell_i\\) and optimize with <code>FunctionalSolver</code>.</p> <p>Two design choices make this interoperable:</p> <ul> <li>Labeled product domains: every coordinate is a named factor (<code>\"x\"</code>, <code>\"t\"</code>, <code>\"data\"</code>, <code>\"p\"</code>, \u2026).</li> <li>Structured batches: sampling preserves axis semantics (paired sampling and coord-separable grids).</li> </ul>"},{"location":"all-of-phydrax/#key-choice-points-what-makes-workflows-differ","title":"Key choice points (what makes workflows differ)","text":""},{"location":"all-of-phydrax/#sampling-point-batches-vs-coord-separable-grids","title":"Sampling: point batches vs coord-separable grids","text":"<p>Phydrax supports two complementary evaluation regimes:</p> <ul> <li><code>PointsBatch</code> (paired sampling): typical PINN-style collocation constraints. See Guides \u2192 Domains and sampling.</li> <li><code>CoordSeparableBatch</code> (axis/grid sampling): spectral/basis operators and neural operators (FNO/DeepONet). See Guides \u2192 Differential operators.</li> </ul>"},{"location":"all-of-phydrax/#differentiation-ad-jets-fd-basis","title":"Differentiation: AD / jets / FD / basis","text":"<p>Differential operators support multiple backends (<code>backend=\"ad\"|\"jet\"|\"fd\"|\"basis\"</code>) and autodiff modes (<code>mode=\"reverse\"|\"forward\"</code>). For deeper math, see Appendix \u2192 Differentiation modes.</p>"},{"location":"all-of-phydrax/#constraints-soft-penalties-vs-enforced-by-construction","title":"Constraints: soft penalties vs enforced by construction","text":"<p>Boundary/initial conditions can be handled in two ways:</p> <ul> <li>Soft: add boundary/initial constraint terms (e.g. <code>ContinuousDirichletBoundaryConstraint</code>) to \\(L\\).</li> <li>Enforced: build an ansatz \\(\\tilde u=\\mathcal{H}(u)\\) satisfying conditions exactly, then train on the remaining terms.</li> </ul> <p>The enforced route is staged as boundary \u2192 initial \u2192 interior data. See:</p> <ul> <li>API \u2192 Constraints \u2192 Enforced constraint ans\u00e4tze</li> <li>API \u2192 Solver \u2192 Enforced constraint pipelines</li> <li>Appendix \u2192 Physics-Constrained Interpolation</li> </ul>"},{"location":"all-of-phydrax/#models-fields-vs-operators","title":"Models: fields vs operators","text":"<ul> <li>Field learning: learn \\(u_\\theta(x,t,\\dots)\\) directly (MLPs, separable models, etc.).</li> <li>Operator learning: learn \\(G_\\theta\\) mapping inputs to fields, using a dataset factor \\(\\Omega_{\\text{data}}\\) so   the domain becomes \\(\\Omega_{\\text{data}}\\times\\Omega_x\\times\\cdots\\). See API \u2192 Domain \u2192 Composition   and API \u2192 NN \u2192 Architectures.</li> </ul>"},{"location":"all-of-phydrax/#a-first-real-pde-example-poisson-on-a-square","title":"A first real PDE example: Poisson on a square","text":"<p>This example trains a neural field \\(u_\\theta(x,y)\\) to satisfy</p> \\[ \\Delta u = 4 \\quad \\text{in }\\Omega=[-1,1]^2,\\qquad u = g \\quad \\text{on }\\partial\\Omega, \\] <p>with the analytic choice \\(g(x,y)=x^2+y^2\\) (so the exact solution is \\(u^\\star(x,y)=x^2+y^2\\)).</p> <p>The configurations are kept small for demonstration purposes.</p> <p>Example</p> <pre><code>import jax.numpy as jnp\nimport jax.random as jr\nimport optax\nimport phydrax as phx\n\ngeom = phx.domain.Square(center=(0.0, 0.0), side=2.0)  # [-1,1]^2, label \"x\"\n\n# Exact solution / boundary target g(x,y) = x^2 + y^2\n@geom.Function(\"x\")\ndef g(x):\n    return x[0] ** 2 + x[1] ** 2\n\n# Trainable field u_theta(x)\nmodel = phx.nn.MLP(\n    in_size=2,\n    out_size=\"scalar\",\n    width_size=16,\n    depth=2,\n    key=jr.key(0),\n)\nu = geom.Model(\"x\")(model)\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\n\n# Interior PDE residual: \u0394u - 4 = 0\npde = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    geom,\n    operator=lambda f: phx.operators.laplacian(f, var=\"x\") - 4.0,\n    num_points=64,\n    structure=structure,\n    reduction=\"mean\",\n)\n\n# Soft Dirichlet boundary: u - g = 0 on \u2202\u03a9\nboundary = geom.component({\"x\": phx.domain.Boundary()})\nbc = phx.constraints.ContinuousDirichletBoundaryConstraint(\n    \"u\",\n    boundary,\n    target=g,\n    num_points=32,\n    structure=structure,\n    weight=10.0,\n    reduction=\"mean\",\n)\n\nsolver = phx.solver.FunctionalSolver(functions={\"u\": u}, constraints=[pde, bc])\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\n</code></pre>"},{"location":"all-of-phydrax/#enforced-boundary-conditions-replace-penalties-with-an-ansatz","title":"Enforced boundary conditions (replace penalties with an ansatz)","text":"<p>Instead of penalizing boundary violations, you can enforce \\(u=g\\) by construction and train only on the interior PDE term. This is often numerically cleaner and makes the \u201cfunctional over a domain\u201d story composable: constraints are just extra terms, while enforcement is a map \\(u\\mapsto \\tilde u\\).</p> <p>Example</p> <pre><code>import jax.random as jr\nimport optax\nimport phydrax as phx\n\ngeom = phx.domain.Square(center=(0.0, 0.0), side=2.0)\n\n@geom.Function(\"x\")\ndef g(x):\n    return x[0] ** 2 + x[1] ** 2\n\nmodel = phx.nn.MLP(in_size=2, out_size=\"scalar\", width_size=16, depth=2, key=jr.key(0))\nu = geom.Model(\"x\")(model)\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\npde = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    geom,\n    operator=lambda f: phx.operators.laplacian(f, var=\"x\") - 4.0,\n    num_points=64,\n    structure=structure,\n)\n\nboundary = geom.component({\"x\": phx.domain.Boundary()})\nterm = phx.solver.SingleFieldEnforcedConstraint(\n    \"u\",\n    boundary,\n    lambda f: phx.constraints.enforce_dirichlet(f, boundary, var=\"x\", target=g),\n)\n\nsolver = phx.solver.FunctionalSolver(\n    functions={\"u\": u},\n    constraints=[pde],\n    constraint_terms=[term],\n    boundary_weight_num_reference=128,\n    boundary_weight_key=jr.key(1),\n)\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\n</code></pre>"},{"location":"all-of-phydrax/#adding-data-anchors-sensors-is-just-another-term","title":"Adding data (anchors / sensors) is \u201cjust another term\u201d","text":"<p>Phydrax treats data-fit the same way as PDE residuals: as a constraint term on a domain component or point set. For scattered anchor data \\(\\{(x_i,y_i)\\}\\), use <code>DiscreteInteriorDataConstraint</code>:</p> <pre><code>import jax.numpy as jnp\nimport phydrax as phx\n\n# Continuing from the Poisson example above:\n# - geom is the geometry domain\n# - u is your trainable field\n\nanchors = jnp.array([[0.0, 0.0], [0.5, -0.5], [-0.25, 0.75]])\nvalues = jnp.sum(anchors**2, axis=1)  # pretend we observed u(x)=x^2+y^2\n\ndata = phx.constraints.DiscreteInteriorDataConstraint(\n    \"u\",\n    geom,\n    points={\"x\": anchors},\n    values=values,\n    weight=1.0,\n)\n</code></pre>"},{"location":"all-of-phydrax/#operator-learning-dataset-coordinates","title":"Operator learning (dataset \u00d7 coordinates)","text":"<p>To model operators \\(G: f \\mapsto u(\\cdot)\\), represent the domain as a product \\(\\Omega=\\Omega_{\\text{data}}\\times\\Omega_x\\times\\cdots\\) using <code>DatasetDomain</code>, and use a structured model like DeepONet/FNO. See API \u2192 Domain \u2192 Composition and API \u2192 NN \u2192 Architectures.</p>"},{"location":"all-of-phydrax/#notation","title":"Notation","text":"<p>We use \\(x\\) for spatial variables, \\(t\\) for time, and \\(u(x, t)\\) for fields. A typical objective aggregates constraints as \\(L = \\sum_i w_i\\,\\ell_i\\).</p>"},{"location":"all-of-phydrax/#by-task-what-do-i-compose","title":"By task: \u201cwhat do I compose?\u201d","text":"<p>Below are the common SciML regimes expressed in Phydrax\u2019s primitives.</p> <ul> <li>Forward PDE solve (PINN-style): interior residual + boundary/initial terms (soft or enforced).   Start at Getting started and then Guides \u2192 Constraints.</li> <li>Enforced BC/IC: build ans\u00e4tze with <code>enforce_dirichlet</code> / <code>enforce_initial</code> / etc., and stage them via solver pipelines.   See API \u2192 Solver \u2192 Enforced constraint pipelines.</li> <li>Data assimilation / hybrid physics\u2013data: add <code>DiscreteInteriorDataConstraint</code> / <code>DiscreteTimeDataConstraint</code> alongside PDE residuals.   See API \u2192 Constraints \u2192 Discrete.</li> <li>Inverse problems (unknown coefficients/parameters): represent unknowns as additional fields or domain parameters, and couple them in residual operators.   See API \u2192 Domain \u2192 Functions and API \u2192 Constraints.</li> <li>Operator learning (DeepONet/FNO): use <code>DatasetDomain</code> and structured models on \\(\\Omega_{\\text{data}}\\times\\Omega_x\\).   See API \u2192 Domain \u2192 Composition and API \u2192 NN \u2192 Architectures.</li> <li>Integral / conservation laws: build terms from <code>integral</code>/<code>mean</code> and use integral constraints (equality targets, flux balances, etc.).   See Guides \u2192 Integrals and measures.</li> <li>ODEs and dynamical systems: treat time as a scalar domain and enforce residuals \\(\\dot u - f(u,t)=0\\) via ODE constraints (continuous or discrete).   See API \u2192 Constraints \u2192 Discrete and API \u2192 Constraints \u2192 Continuous.</li> <li>Cookbook recipes: end-to-end patterns for Poisson, heat, inverse+data, and operator learning.   Start at Cookbook \u2192 Overview.</li> </ul>"},{"location":"all-of-phydrax/#where-to-go-next","title":"Where to go next","text":"<ul> <li>Cookbook</li> <li>Domains and sampling</li> <li>Differential operators</li> <li>Integrals and measures</li> <li>Constraints and objectives</li> <li>Solvers and training</li> <li>API reference</li> <li><code>phydrax.domain</code> for geometry, time, and sampling.</li> <li><code>phydrax.constraints</code> for loss terms and enforced constraints.</li> <li><code>phydrax.operators</code> for PDE operators.</li> <li><code>phydrax.nn</code> for models and wrappers.</li> <li><code>phydrax.solver</code> for training and evaluation loops.</li> </ul>"},{"location":"guides_constraints/","title":"Constraints and objectives","text":"<p>This guide explains how Phydrax turns PDE residuals, data fits, and integral targets into scalar objective terms that can be summed and optimized.</p>"},{"location":"guides_constraints/#what-a-constraint-is","title":"What a constraint is","text":"<p>At a high level, a constraint is a scalar loss term \\(\\ell(\\theta)\\) computed from a set of domain-aware field functions (often parameterized by neural network parameters \\(\\theta\\)). Solvers typically minimize a weighted sum:</p> \\[ L(\\theta) = \\sum_i \\ell_i(\\theta). \\] <p>In Phydrax, constraints are objects with a common <code>.loss(functions, key=..., ...)</code> interface.</p>"},{"location":"guides_constraints/#sampled-continuous-constraints","title":"Sampled (continuous) constraints","text":"<p>Many constraints are defined by:</p> <p>1) a domain component (interior, boundary, initial slice, etc.), and 2) a residual operator producing a <code>DomainFunction</code> \\(r(z)\\) from one or more fields.</p> <p>The pointwise penalty is a squared Frobenius norm:</p> \\[ \\rho(z) = \\|r(z)\\|_F^2 = \\sum_i r_i(z)^2. \\] <p>Phydrax supports two reduction modes:</p> <p><code>reduction=\"mean\"</code> (measure-normalized):</p> \\[ \\ell = w\\,\\frac{1}{\\mu(\\Omega_{\\text{comp}})}\\int_{\\Omega_{\\text{comp}}}\\rho(z)\\,\\mathrm{d}\\mu(z) \\] <p><code>reduction=\"integral\"</code> (unnormalized):</p> \\[ \\ell = w\\int_{\\Omega_{\\text{comp}}}\\rho(z)\\,\\mathrm{d}\\mu(z) \\] <p>Here \\(\\mu\\) is the component measure induced by the domain (volume/area/length for interiors, surface measure for boundaries, counting measure for fixed slices, etc.), and <code>weight = w</code> is a scalar multiplier.</p>"},{"location":"guides_constraints/#sampling-structure-and-over","title":"Sampling structure and <code>over=...</code>","text":"<p>Sampling is controlled by a <code>ProductStructure</code> (paired point sampling) and optionally by <code>coord_separable</code> (grid sampling).</p> <p>The <code>over</code> argument selects which axes to reduce over:</p> <ul> <li><code>over=None</code>: reduce over all sampled axes implied by the batch,</li> <li><code>over=\"x\"</code>: reduce over the axis for label <code>\"x\"</code> (when it is a singleton block in paired sampling),</li> <li><code>over=(\"x\", \"t\")</code>: reduce over a paired block.</li> </ul> <p>For coord-separable batches, <code>over=\"x\"</code> reduces over the coord-separable axes for that label.</p>"},{"location":"guides_constraints/#filtering-where-and-where_all","title":"Filtering: <code>where</code> and <code>where_all</code>","text":"<p>Continuous constraints can restrict the sampling region via:</p> <ul> <li><code>where={label: predicate}</code> (per-label filtering),</li> <li><code>where_all=predicate</code> (global filtering on the full point tuple).</li> </ul> <p>Conceptually this applies an indicator/mask inside the integral/mean.</p>"},{"location":"guides_constraints/#a-common-pattern-interior-pde-residual","title":"A common pattern: interior PDE residual","text":"<p><code>ContinuousPointwiseInteriorConstraint</code> is a convenience wrapper for pointwise residual losses.</p> <pre><code>import phydrax as phx\n\ngeom = phx.domain.Interval1d(0.0, 1.0)\n\n@geom.Function(\"x\")\ndef u(x):\n    return x[0] ** 2\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\nconstraint = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    geom,\n    operator=lambda f: phx.operators.laplacian(f, var=\"x\"),\n    num_points=128,\n    structure=structure,\n    reduction=\"mean\",\n)\n</code></pre>"},{"location":"guides_constraints/#discrete-and-pointset-constraints","title":"Discrete and pointset constraints","text":"<p>For sensor/anchor data (discrete samples), Phydrax provides constraints that do not sample from a component, but instead evaluate on explicit point sets (and typically reduce by mean/integral in an analogous way).</p>"},{"location":"guides_constraints/#integral-equality-constraints","title":"Integral equality constraints","text":"<p>Integral constraints enforce targets of the form</p> \\[ \\int_{\\Omega_{\\text{comp}}} f(z)\\,d\\mu(z) = c, \\] <p>where the left-hand side is estimated via Monte Carlo or quadrature, depending on the batch. See Guides \u2192 Integrals and measures for the measure/weighting details.</p>"},{"location":"guides_differential/","title":"Differential operators","text":"<p>This page documents Phydrax's core differential operators from a mathematical point of view and explains how they interact with labeled product domains and structured sampling.</p>"},{"location":"guides_differential/#notation-and-conventions","title":"Notation and conventions","text":"<p>Let the domain be a labeled product \\(\\Omega = \\Omega_x \\times \\Omega_t \\times \\cdots\\). Phydrax represents functions as <code>DomainFunction</code> objects, which conceptually define a map</p> \\[ u:\\Omega\\to\\mathbb{R}^{m_1\\times\\cdots\\times m_k}. \\] <p>For a geometry label (typically <code>\"x\"</code>) with spatial dimension \\(d\\), write \\(x=(x_1,\\dots,x_d)\\in\\mathbb{R}^d\\). For a scalar label (typically <code>\"t\"</code>), write \\(t\\in\\mathbb{R}\\).</p> <p>Phydrax adopts the convention that derivative dimensions are appended on the right:</p> <ul> <li>if \\(u\\) is scalar-valued, then \\(\\nabla_x u\\) has a trailing axis of length \\(d\\);</li> <li>if \\(u\\) is vector-valued with trailing size \\(m\\), then \\(\\nabla_x u\\) has trailing shape \\((m,d)\\);</li> <li>higher-rank tensor values are differentiated componentwise, appending derivative axes.</li> </ul>"},{"location":"guides_differential/#gradient-jacobian","title":"Gradient / Jacobian","text":"<p><code>phydrax.operators.grad(u, var=\"x\")</code> constructs the gradient/Jacobian with respect to a labeled variable.</p>"},{"location":"guides_differential/#geometry-variables","title":"Geometry variables","text":"<p>For a geometry variable \\(x\\in\\mathbb{R}^d\\):</p> <p>If \\(u:\\Omega\\to\\mathbb{R}\\) is scalar-valued, then</p> \\[ \\nabla_x u = \\left(\\frac{\\partial u}{\\partial x_1},\\dots,\\frac{\\partial u}{\\partial x_d}\\right). \\] <p>If \\(u:\\Omega\\to\\mathbb{R}^m\\) is vector-valued, then <code>grad</code> returns the Jacobian \\(J\\in\\mathbb{R}^{m\\times d}\\) with entries \\(J_{ij}=\\partial u_i/\\partial x_j\\).</p>"},{"location":"guides_differential/#scalar-variables","title":"Scalar variables","text":"<p>For a scalar label \\(t\\), <code>grad(u, var=\"t\")</code> reduces to the partial derivative \\(\\partial u/\\partial t\\).</p>"},{"location":"guides_differential/#hessian-laplacian-bi-laplacian","title":"Hessian, Laplacian, Bi-Laplacian","text":""},{"location":"guides_differential/#hessian","title":"Hessian","text":"<p><code>phydrax.operators.hessian(u, var=\"x\")</code> returns the matrix of second derivatives. For scalar-valued \\(u\\),</p> \\[ H_{ij}(x)=\\frac{\\partial^2 u}{\\partial x_i\\,\\partial x_j}. \\] <p>For vector-valued \\(u\\), the Hessian is taken componentwise, producing a trailing shape \\((m,d,d)\\).</p>"},{"location":"guides_differential/#laplacian","title":"Laplacian","text":"<p><code>phydrax.operators.laplacian(u, var=\"x\")</code> computes</p> \\[ \\Delta u \\;=\\; \\nabla\\cdot\\nabla u \\;=\\; \\sum_{i=1}^{d}\\frac{\\partial^2 u}{\\partial x_i^2}         \\;=\\; \\text{tr}(\\nabla^2 u). \\]"},{"location":"guides_differential/#bi-laplacian","title":"Bi-Laplacian","text":"<p><code>phydrax.operators.bilaplacian(u, var=\"x\")</code> computes the fourth-order operator</p> \\[ \\Delta^2 u \\;=\\; \\Delta(\\Delta u). \\]"},{"location":"guides_differential/#divergence-and-curl","title":"Divergence and curl","text":""},{"location":"guides_differential/#divergence","title":"Divergence","text":"<p>For a vector field \\(v:\\Omega\\to\\mathbb{R}^d\\), <code>phydrax.operators.div(v, var=\"x\")</code> computes</p> \\[ \\nabla\\cdot v = \\sum_{i=1}^{d}\\frac{\\partial v_i}{\\partial x_i} = \\text{tr}(\\nabla v). \\] <p>If \\(v\\) has additional leading value axes (e.g. multiple vector fields stacked), divergence is applied componentwise over those leading value axes.</p>"},{"location":"guides_differential/#curl-3d-only","title":"Curl (3D only)","text":"<p>For \\(v:\\Omega\\to\\mathbb{R}^3\\), <code>phydrax.operators.curl(v, var=\"x\")</code> computes</p> \\[ \\nabla\\times v = \\begin{pmatrix}   \\partial_y v_z - \\partial_z v_y \\\\   \\partial_z v_x - \\partial_x v_z \\\\   \\partial_x v_y - \\partial_y v_x \\end{pmatrix}. \\]"},{"location":"guides_differential/#backends-autodiff-finite-differences-spectralbasis","title":"Backends: autodiff, finite differences, spectral/basis","text":"<p>Many differential operators accept a <code>backend</code> keyword:</p> <ul> <li><code>backend=\"ad\"</code> uses autodiff and works for both point sampling and coord-separable sampling.</li> <li><code>backend=\"jet\"</code> uses Taylor-mode AD (\"jets\") for higher-order derivatives with respect to a single variable.</li> <li><code>backend=\"fd\"</code> uses finite differences on coord-separable grids (and falls back to autodiff for point inputs).</li> <li><code>backend=\"basis\"</code> uses basis-aware methods on coord-separable grids (and falls back to autodiff for point inputs).</li> </ul>"},{"location":"guides_differential/#jet-backend-taylor-mode-derivative-jets","title":"Jet backend (Taylor-mode / derivative jets)","text":"<p>The jet backend propagates a truncated derivative jet through the computation graph. Concretely, for a smooth map \\(f\\) and a direction \\(v\\), it computes the derivatives of the 1D curve \\(y(\\epsilon)=f(x+\\epsilon v)\\) at \\(\\epsilon=0\\), i.e. the coefficients of the Taylor expansion</p> \\[ f(x+\\epsilon v) = \\sum_{k=0}^{K}\\frac{\\epsilon^k}{k!}\\,D^k f(x)[v,\\dots,v] + O(\\epsilon^{K+1}). \\] <p>Under the hood, higher-order chain rules are governed by the Fa\u00e0 di Bruno formula. In one dimension, for a composition \\(f\\circ g\\),</p> \\[ (f\\circ g)^{(n)}(x) = \\sum_{k=1}^{n} f^{(k)}(g(x))\\,B_{n,k}\\bigl(g'(x),g''(x),\\dots,g^{(n-k+1)}(x)\\bigr), \\] <p>where \\(B_{n,k}\\) are the (partial) Bell polynomials. Jet-mode AD implements these combinatorics automatically, which is why it can be more direct than nesting <code>jax.jacfwd</code>/<code>jax.jacrev</code> when you need \\(n\\ge 2\\) derivatives with respect to the same variable.</p> <p>The <code>basis</code> keyword (used when <code>backend=\"basis\"</code>) selects a 1D method along each coord-separable axis:</p> <ul> <li><code>basis=\"fourier\"</code>: FFT-based spectral derivatives on periodic grids;</li> <li><code>basis=\"sine\"</code> / <code>basis=\"cosine\"</code>: FFT-based derivatives via odd/even extension;</li> <li><code>basis=\"poly\"</code>: polynomial (barycentric) differentiation on generic 1D grids.</li> </ul> <p>Note</p> <p>FFT-based bases (<code>fourier</code>/<code>sine</code>/<code>cosine</code>) assume a uniformly-spaced coordinate axis.</p>"},{"location":"guides_differential/#coord-separable-sampling-and-grid-evaluation","title":"Coord-separable sampling and grid evaluation","text":"<p>When you sample a <code>CoordSeparableBatch</code>, selected geometry labels provide a tuple of 1D coordinate axes instead of a point cloud. For a 2D geometry label <code>\"x\"</code>, the model/operator receives \\((x_{\\text{axis}}, y_{\\text{axis}})\\) and evaluates on the implied Cartesian grid.</p> <p>This is the preferred mode for spectral operators and neural operators (FNO/DeepONet).</p> <p>Example</p> <p>Laplacian on a periodic 1D grid using the basis backend:</p> <pre><code>import jax.random as jr\nimport jax.numpy as jnp\nimport phydrax as phx\n\ngeom = phx.domain.Interval1d(0.0, 1.0)\n\n@geom.Function(\"x\")\ndef u(x):\n    return jnp.sin(2.0 * jnp.pi * x[0])\n\nlap_u = phx.operators.laplacian(u, var=\"x\", backend=\"basis\", basis=\"fourier\")\n\nbatch = geom.component().sample_coord_separable({\"x\": phx.domain.FourierAxisSpec(64)}, key=jr.key(0))\nout = lap_u(batch)\n</code></pre>"},{"location":"guides_differential/#surface-differential-operators","title":"Surface differential operators","text":"<p>Several operators act on fields restricted to a geometry boundary (surface/curve). These use the outward unit normal \\(n\\) provided by the geometry and project ambient derivatives onto the tangent space.</p> <p>Let \\(\\Gamma = \\partial\\Omega_x\\) be a smooth boundary in \\(\\mathbb{R}^d\\) with unit normal \\(n(x)\\in\\mathbb{R}^d\\). Define the tangential projector</p> \\[ P(x) = I - n(x)\\,n(x)^\\top. \\] <p>For a scalar field \\(u\\), the surface gradient is</p> \\[ \\nabla_\\Gamma u = P\\,\\nabla u. \\] <p>For a (tangent) vector field \\(v\\), the surface divergence is</p> \\[ \\nabla_\\Gamma\\cdot v = \\text{tr}\\!\\left(P\\,\\nabla v\\right). \\] <p>The Laplace\u2013Beltrami operator is the surface analogue of the Laplacian:</p> \\[ \\Delta_\\Gamma u = \\nabla_\\Gamma\\cdot(\\nabla_\\Gamma u). \\] <p>In Phydrax, these operators are exposed as <code>surface_grad</code>, <code>surface_div</code>, and <code>laplace_beltrami</code> (see API \u2192 Operators \u2192 Differential).</p> <p>Note</p> <p>Surface operators are intended to be evaluated on boundary components so that the geometry can supply consistent normals.</p>"},{"location":"guides_differential/#fractional-operators","title":"Fractional operators","text":"<p>Phydrax includes a small set of fractional derivative operators, primarily for experimentation.</p>"},{"location":"guides_differential/#fractional-laplacian-integral-estimator","title":"Fractional Laplacian (integral estimator)","text":"<p>For \\(0&lt;\\alpha&lt;2\\), the fractional Laplacian in \\(\\mathbb{R}^d\\) can be written (up to a constant \\(C_{d,\\alpha}\\)) as a singular integral:</p> \\[ (-\\Delta)^{\\alpha/2}u(x) \\propto \\int_{\\mathbb{R}^d}\\frac{u(x)-u(y)}{\\|x-y\\|^{d+\\alpha}}\\,dy. \\] <p><code>phydrax.operators.fractional_laplacian</code> implements a truncated ball estimator using offsets \\(y=x+\\xi\\) with \\(\\|\\xi\\|\\le R\\):</p> \\[ \\int_{B_R(0)} \\frac{u(x)-u(x+\\xi)}{\\|\\xi\\|^{d+\\alpha}}\\,d\\xi. \\] <p>The implementation excludes a small neighborhood \\(\\|\\xi\\|\\le\\varepsilon\\) to avoid the singularity, and can optionally reduce variance for \\(\\alpha&gt;1\\) by subtracting a first-order correction involving \\(\\nabla u\\) (<code>desingularize=True</code>).</p> <p>Warning</p> <p>The returned value is not normalized by \\(C_{d,\\alpha}\\), and the truncation radius \\(R\\) introduces a modeling choice. Use this operator with care and validate against known solutions.</p>"},{"location":"guides_differential/#grunwaldletnikov-monte-carlo-gmc","title":"Gr\u00fcnwald\u2013Letnikov (Monte Carlo / GMC)","text":"<p>For one-sided fractional derivatives (currently \\(\\alpha\\in(1,2)\\)), Phydrax provides a Monte Carlo variant of a Gr\u00fcnwald\u2013Letnikov discretization; see <code>fractional_derivative_gl_mc</code> and related helpers on the API page.</p>"},{"location":"guides_domain/","title":"Domains and sampling","text":"<p>This guide explains Phydrax's labeled domains and the two sampling modes used throughout the library: paired point sampling and coord-separable grid sampling.</p>"},{"location":"guides_domain/#labeled-product-domains","title":"Labeled product domains","text":"<p>A Phydrax domain represents a product of labeled factors:</p> \\[ \\Omega = \\Omega_{\\ell_1}\\times\\cdots\\times \\Omega_{\\ell_k}, \\] <p>where each factor has a label like <code>\"x\"</code> (space) or <code>\"t\"</code> (time). Product domains are composed with the <code>@</code> operator:</p> <pre><code>import phydrax as phx\n\ngeom = phx.domain.Interval1d(0.0, 1.0)        # label \"x\"\ntime = phx.domain.TimeInterval(0.0, 2.0)    # label \"t\" (alias of ScalarInterval)\ndomain = geom @ time                        # labels (\"x\", \"t\")\n</code></pre> <p>For non-time scalar axes, use <code>ScalarInterval(start, end, label=\"...\")</code>.</p> <p>Functions on a domain are wrapped as <code>DomainFunction</code>s. The key idea is that a <code>DomainFunction</code> declares which labels it depends on, and operators/constraints use those labels consistently.</p> <pre><code>@domain.Function(\"x\", \"t\")\ndef u(x, t):\n    return x[0] * (1.0 + t)\n</code></pre>"},{"location":"guides_domain/#components-interior-boundary-and-fixed-slices","title":"Components: interior, boundary, and fixed slices","text":"<p>Constraints and integrals are typically evaluated over a domain component, which selects a subset of each factor:</p> <ul> <li><code>Interior()</code>: the interior of a geometry or scalar interval;</li> <li><code>Boundary()</code>: the boundary of a geometry or scalar interval (endpoints in 1D);</li> <li><code>FixedStart()</code> / <code>FixedEnd()</code>: the start/end slice of a scalar interval (often time);</li> <li><code>Fixed(value)</code>: a slice at a specified coordinate.</li> </ul> <p>Components are created with <code>domain.component(...)</code>:</p> <pre><code># Continuing from: domain = geom @ time\ncomponent = domain.component({\"t\": phx.domain.FixedStart()})  # initial-time slice\n</code></pre>"},{"location":"guides_domain/#filtering-with-where-and-where_all","title":"Filtering with <code>where</code> and <code>where_all</code>","text":"<p>Sampling can be restricted by predicates:</p> <ul> <li><code>where={label: predicate}</code> applies a per-label predicate, e.g. <code>where={\"x\": lambda x: x[0] &lt; 0.5}</code>.</li> <li><code>where_all=predicate</code> applies a predicate to the full point tuple (useful for coupled filters).</li> </ul> <p>These filters behave like indicator functions: points that fail the predicate are discarded (for point sampling) or masked out (for coord-separable sampling).</p>"},{"location":"guides_domain/#paired-point-sampling-pointsbatch","title":"Paired point sampling (<code>PointsBatch</code>)","text":"<p>Most pointwise PDE residual constraints use paired sampling, driven by a <code>ProductStructure</code>.</p> <p>A <code>ProductStructure</code> partitions the sampled labels into blocks. Each block is sampled jointly, and each block corresponds to one named sampling axis in the resulting <code>PointsBatch</code>.</p> <p>Examples:</p> <ul> <li><code>ProductStructure(((\"x\", \"t\"),))</code> samples paired space-time points.</li> <li><code>ProductStructure(((\"x\",), (\"t\",)))</code> samples space and time independently (Cartesian product).</li> </ul> <pre><code>import equinox as eqx\nimport jax.random as jr\nimport phydrax as phx\n\n# Continuing from: domain = geom @ time\nstructure = phx.domain.ProductStructure(((\"x\", \"t\"),))\nbatch = domain.component().sample(\n    128,\n    structure=structure,\n    key=eqx.internal.doc_repr(jr.key(0), \"jr.key(0)\"),\n)\n</code></pre>"},{"location":"guides_domain/#coord-separable-grid-sampling-coordseparablebatch","title":"Coord-separable grid sampling (<code>CoordSeparableBatch</code>)","text":"<p>For spectral/basis operators and neural operators, it is often preferable to sample 1D axes and evaluate on the implied Cartesian grid. This is coord-separable sampling.</p> <p>You choose which geometry labels are coord-separable by passing a per-label spec, e.g. <code>{\"x\": FourierAxisSpec(64)}</code> for a 1D periodic grid or <code>{\"x\": (64, 64)}</code> for a 2D grid.</p> <pre><code>import equinox as eqx\nimport jax.random as jr\nimport phydrax as phx\n\ngeom = phx.domain.Interval1d(0.0, 1.0)\nbatch = geom.component().sample_coord_separable(\n    {\"x\": phx.domain.FourierAxisSpec(64)},\n    key=eqx.internal.doc_repr(jr.key(0), \"jr.key(0)\"),\n)\n</code></pre> <p>When a geometry label is coord-separable, the value passed into a <code>DomainFunction</code> for that label is a tuple of 1D coordinate arrays (one per spatial dimension), rather than a point cloud.</p>"},{"location":"guides_domain/#axis-specs-and-quadrature-metadata","title":"Axis specs and quadrature metadata","text":"<p>Axis specs (<code>FourierAxisSpec</code>, <code>LegendreAxisSpec</code>, etc.) can attach an <code>AxisDiscretization</code> to the batch, including:</p> <ul> <li><code>nodes</code> (the axis coordinates),</li> <li>optional quadrature weights (for <code>integral</code>/<code>mean</code>),</li> <li>basis metadata used by <code>backend=\"basis\"</code> differential operators.</li> </ul> <p>This is how Phydrax keeps sampling, quadrature, and operator discretization consistent without manual bookkeeping.</p>"},{"location":"guides_domain/#phase-space-product-domains-positionmomentum","title":"Phase-space product domains (position\u2013momentum)","text":"<p>You can represent phase space by composing a spatial geometry for position with a second spatial geometry that you relabel as momentum.</p>"},{"location":"guides_domain/#without-time","title":"Without time","text":"<pre><code>import phydrax as phx\n\nx = phx.domain.Interval1d(0.0, 1.0)              # label \"x\"\np = phx.domain.Interval1d(-2.0, 2.0).relabel(\"p\")  # momentum axis, label \"p\"\n\nphase = x @ p                                  # labels (\"x\", \"p\")\n\n@phase.Function(\"x\", \"p\")\ndef f(x, p):\n    return x[0] ** 2 + p[0] ** 2\n\nstructure = phx.domain.ProductStructure(((\"x\", \"p\"),))  # paired (x,p) samples\nbatch = phase.component().sample(256, structure=structure)\nval = f(batch)  # evaluated on phase-space points\n</code></pre>"},{"location":"guides_domain/#with-time","title":"With time","text":"<p>Add a time factor and treat the objective as evolving on \\(\\Omega_x\\times\\Omega_p\\times[t_0,t_1]\\):</p> <pre><code>import phydrax as phx\n\nx = phx.domain.Interval1d(0.0, 1.0)\np = phx.domain.Interval1d(-2.0, 2.0).relabel(\"p\")\nt = phx.domain.TimeInterval(0.0, 5.0)          # label \"t\"\n\nphase_time = x @ p @ t                         # labels (\"x\", \"p\", \"t\")\n\n@phase_time.Function(\"x\", \"p\", \"t\")\ndef f(x, p, t):\n    return (x[0] ** 2 + p[0] ** 2) * (1.0 + t)\n\nstructure = phx.domain.ProductStructure(((\"x\", \"p\", \"t\"),))\nbatch = phase_time.component().sample(512, structure=structure)\nval = f(batch)\n</code></pre>"},{"location":"guides_domain/#higher-dimensional-momentum-domains","title":"Higher-dimensional momentum domains","text":"<p>For multi-dimensional momentum, relabel a 2D/3D geometry:</p> <pre><code>import phydrax as phx\n\nx = phx.domain.Square(center=(0.0, 0.0), side=2.0)            # \"x\" in R^2\np = phx.domain.Square(center=(0.0, 0.0), side=6.0).relabel(\"p\")  # \"p\" in R^2\nphase = x @ p\n</code></pre>"},{"location":"guides_integrals/","title":"Integrals and measures","text":"<p>Phydrax's integral operators (<code>integral</code>, <code>mean</code>, and friends) estimate integrals over a <code>DomainComponent</code> with a domain-aware measure.</p>"},{"location":"guides_integrals/#measure-mu-induced-by-the-domain-and-component","title":"Measure \\(\\mu\\) induced by the domain and component","text":"<p>Given a component \\(\\Omega_{\\text{comp}}\\subseteq \\Omega\\) (interior, boundary, fixed slice, etc.), Phydrax interprets <code>integral(f, ..., component=...)</code> as estimating</p> \\[ \\int_{\\Omega_{\\text{comp}}} f(z)\\,d\\mu(z). \\] <p>The measure depends on the factor type and the component selection:</p> <ul> <li>Geometry factors:</li> <li><code>Interior()</code>: \\(\\mu(\\Omega_x)\\) is the geometry volume/area/length (<code>factor.volume</code>).</li> <li><code>Boundary()</code>: \\(\\mu(\\partial\\Omega_x)\\) is the boundary measure (<code>factor.boundary_measure_value</code>).</li> <li><code>Fixed(...)</code>: counting measure on the fixed slice.</li> <li>Scalar interval factors (e.g. time):</li> <li><code>Interior()</code>: \\(\\mu(\\Omega_t)\\) is the interval measure (<code>factor.measure</code>).</li> <li><code>Boundary()</code>: defaults to 2-point counting measure (endpoints).</li> <li><code>FixedStart</code> / <code>FixedEnd</code> / <code>Fixed(...)</code>: counting measure on the fixed time.</li> <li>Dataset factors (<code>DatasetDomain</code>):</li> <li><code>Interior()</code>: either \\(\\mu(\\Omega_{\\text{data}})=1\\) (<code>measure=\"probability\"</code>) or     \\(\\mu(\\Omega_{\\text{data}})=N\\) (<code>measure=\"count\"</code>).</li> </ul>"},{"location":"guides_integrals/#sampling-structure-paired-vs-coord-separable","title":"Sampling structure: paired vs coord-separable","text":"<p>Phydrax supports two structured sampling modes that affect how integrals are reduced:</p> <ul> <li><code>PointsBatch</code> (paired sampling): you choose a <code>ProductStructure</code> and sample points per block.</li> <li><code>CoordSeparableBatch</code> (coord-separable sampling): you sample 1D coordinate axes for selected geometry labels   and evaluate on a Cartesian grid, optionally with per-axis discretization metadata.</li> </ul>"},{"location":"guides_integrals/#default-weights","title":"Default weights","text":"<p>If you do not supply an explicit <code>QuadratureBatch</code>, then:</p> <p>For <code>PointsBatch</code>, Phydrax uses a uniform Monte Carlo-style weight on each sampling axis:</p> \\[ w_a = \\frac{\\mu_a}{n_a}, \\] <p>where \\(n_a\\) is the number of points on axis \\(a\\) and \\(\\mu_a\\) is the product measure of the labels in that block.</p> <p>For <code>CoordSeparableBatch</code>, Phydrax multiplies per-axis weights:</p> <ul> <li>if <code>AxisDiscretization.quad_weights</code> is present (e.g. Gauss\u2013Legendre), those weights are used;</li> <li>otherwise weights fall back to uniform weights based on the factor's axis-aligned bounding box.</li> </ul>"},{"location":"guides_integrals/#filtering-and-weighting-where-weight_all","title":"Filtering and weighting (<code>where</code>, <code>weight_all</code>)","text":"<p>Integrals can be restricted and reweighted via the component:</p> <ul> <li><code>component.where</code> / <code>component.where_all</code> act as indicator functions (masking out samples).</li> <li><code>component.weight_all</code> multiplies the integrand by a user-defined weight field.</li> </ul> <p>Conceptually, Phydrax estimates</p> \\[ \\int_{\\Omega_{\\text{comp}}} \\mathbf{1}_{\\text{where}}(z)\\,w(z)\\,f(z)\\,d\\mu(z). \\]"},{"location":"guides_integrals/#choosing-reduction-axes-over","title":"Choosing reduction axes (<code>over=...</code>)","text":"<p><code>over</code> controls which axes to integrate over:</p> <ul> <li><code>over=None</code>: integrate over all axes implied by the batch.</li> <li><code>over=\"x\"</code>: integrate over the axis associated with label <code>\"x\"</code> (requires <code>\"x\"</code> to be a singleton block in paired sampling).</li> <li><code>over=(\"x\",\"t\")</code>: integrate over a specific paired block.</li> </ul> <p>For coord-separable batches, <code>over=\"x\"</code> integrates over the coord-separable axes for that label.</p>"},{"location":"guides_integrals/#examples","title":"Examples","text":"<p>Example</p> <p>Gauss\u2013Legendre quadrature on an interval:</p> <pre><code>import phydrax as phx\n\ngeom = phx.domain.Interval1d(-1.0, 2.0)\n\n@geom.Function(\"x\")\ndef u(x):\n    return x[0] ** 2\n\nbatch = geom.component().sample_coord_separable({\"x\": phx.domain.LegendreAxisSpec(24)})\nval = phx.operators.integral(u, batch, component=geom.component())\n</code></pre>"},{"location":"guides_solver/","title":"Solvers and training","text":"<p>This guide explains how <code>FunctionalSolver</code> evaluates losses and how <code>solve()</code> updates parameters.</p>"},{"location":"guides_solver/#what-functionalsolver-does","title":"What <code>FunctionalSolver</code> does","text":"<p>A <code>FunctionalSolver</code> is a lightweight orchestrator that holds:</p> <ul> <li><code>functions</code>: a mapping <code>{name: DomainFunction}</code> of the current fields,</li> <li><code>constraints</code>: a list/tuple of constraint objects, each producing a scalar loss,</li> <li>optional <code>constraint_pipelines</code>: enforced-constraint pipelines that replace raw fields with ansatz   functions satisfying selected conditions exactly.</li> </ul> <p>The total objective is the sum of constraint losses:</p> \\[ L = \\sum_i \\ell_i. \\]"},{"location":"guides_solver/#loss-evaluation-loss","title":"Loss evaluation (<code>loss(...)</code>)","text":"<p>When you call <code>solver.loss(key=...)</code>:</p> <p>1) If enforced pipelines are configured, the current <code>functions</code> mapping is transformed into    ansatz functions via <code>solver.ansatz_functions()</code>. 2) The provided PRNG key is split into one subkey per constraint. 3) Each constraint loss is evaluated and summed.</p> <p>Additional keyword arguments are forwarded to each constraint's <code>.loss(...)</code> method.</p>"},{"location":"guides_solver/#enforced-constraint-pipelines","title":"Enforced-constraint pipelines","text":"<p>Enforced pipelines are optional, but common when you want to enforce boundary/initial conditions exactly by construction (rather than penalizing violations).</p> <p>Pipelines are applied before any soft constraints are evaluated, so all residuals see the post-processed (enforced) fields.</p> <p>See API \u2192 Solver \u2192 Enforced constraint pipelines for the pipeline types and constructors.</p>"},{"location":"guides_solver/#training-solve","title":"Training (<code>solve(...)</code>)","text":"<p><code>FunctionalSolver.solve(...)</code> runs an optimization loop over the parameters contained inside <code>solver.functions</code>. Under the hood it uses Equinox to split the function PyTree into:</p> <ul> <li>trainable parameters: inexact arrays (floating/complex arrays),</li> <li>static part: everything else.</li> </ul>"},{"location":"guides_solver/#optimizer-support","title":"Optimizer support","text":"<p><code>optim=</code> can be:</p> <ul> <li>an Optax <code>GradientTransformation</code> (standard first-order optimizers),</li> <li>an Optax <code>GradientTransformationExtraArgs</code> (line-search style optimizers),</li> <li>an evosax algorithm instance (evolutionary strategies).</li> </ul>"},{"location":"guides_solver/#iteration-counter-iter_","title":"Iteration counter (<code>iter_</code>)","text":"<p>During training, the current epoch index is passed to each constraint loss as <code>iter_</code> (as a JAX scalar), so constraints can implement schedules (annealing, curriculum weights, etc.).</p>"},{"location":"guides_solver/#jit-and-keep_best","title":"<code>jit</code> and <code>keep_best</code>","text":"<ul> <li>If <code>jit=True</code>, the per-step update is JIT-compiled when using standard Optax optimizers.   (Line-search optimizers are not JIT-wrapped.)</li> <li>If <code>keep_best=True</code>, the returned solver uses the best parameter set observed over all epochs   (by objective value); otherwise it returns the final parameters.</li> </ul>"},{"location":"guides_solver/#minimal-example","title":"Minimal example","text":"<pre><code>import equinox as eqx\nimport jax.random as jr\nimport optax\nimport phydrax as phx\n\ngeom = phx.domain.Interval1d(0.0, 1.0)\n\n# Trainable scalar field u_theta(x)\nmodel = phx.nn.MLP(\n    in_size=1,\n    out_size=\"scalar\",\n    width_size=16,\n    depth=2,\n    key=eqx.internal.doc_repr(jr.key(0), \"jr.key(0)\"),\n)\nu = geom.Model(\"x\")(model)\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\n\n# A toy interior objective that encourages u(x) \u2248 0 in \u03a9 (replace with a PDE operator in real use).\nconstraint = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    geom,\n    operator=lambda f: f,\n    num_points=128,\n    structure=structure,\n    reduction=\"mean\",\n)\n\nsolver = phx.solver.FunctionalSolver(functions={\"u\": u}, constraints=[constraint])\nloss0 = solver.loss(key=eqx.internal.doc_repr(jr.key(0), \"jr.key(0)\"))\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\nloss1 = solver.loss(key=jr.key(1))\nprint(loss0, loss1)\n</code></pre>"},{"location":"guides_solver/#evosax-example-gradient-free","title":"EvoSax example (gradient-free)","text":"<p>To use evolutionary strategies, pass an evosax algorithm instance as <code>optim=...</code>:</p> <pre><code>import equinox as eqx\nfrom evosax import algorithms as evo_algos\nimport phydrax as phx\n\n# Continuing from the minimal example above:\n# solver = phx.solver.FunctionalSolver(functions={\"u\": u}, constraints=[constraint])\n\n# evosax expects a \"solution\" PyTree matching the trainable parameter structure.\nparams, _ = eqx.partition(solver.functions, eqx.is_inexact_array)\nalgo = evo_algos.Open_ES(population_size=8, solution=params)\n\nsolver = solver.solve(num_iter=20, optim=algo, seed=0)\n</code></pre>"},{"location":"api/phydrax/","title":"Phydrax","text":"<p>Top-level package namespace. Most functionality lives in subpackages:</p> <ul> <li><code>phydrax.domain</code>: domains, geometry, sampling, and domain functions</li> <li><code>phydrax.operators</code>: differential/integral operators on <code>DomainFunction</code>s</li> <li><code>phydrax.constraints</code>: objective terms built from operators and data</li> <li><code>phydrax.nn</code>: neural network components and structured models</li> <li><code>phydrax.solver</code>: loss assembly and training utilities</li> </ul>"},{"location":"api/constraints/","title":"Constraints","text":"<p>Constraints define objective terms for training or evaluation. They operate on domain functions and typically return a scalar loss term.</p> <p>For the mathematical conventions used by sampled constraints (residual norms, reduction modes, measures, and filtering), see Guides \u2192 Constraints and objectives.</p>"},{"location":"api/constraints/boundary/","title":"Boundary and initial conditions","text":""},{"location":"api/constraints/boundary/#generic-boundary-constraints","title":"Generic boundary constraints","text":""},{"location":"api/constraints/boundary/#phydrax.constraints.ContinuousDirichletBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousDirichletBoundaryConstraint(constraint_var: str, component: DomainComponent | DomainComponentUnion, /, *, target: DomainFunction | ArrayLike | None = None, num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Continuous Dirichlet boundary constraint.</p> <p>Enforces \\(u = g\\) on the boundary component by minimizing the squared residual \\(u - g\\).</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Boundary component or component union.</li> <li><code>target</code>: Target value/function \\(g\\) (defaults to 0).</li> <li><code>num_points</code>: Number of boundary samples.</li> <li><code>structure</code>: Sampling structure over labels.</li> <li><code>sampler</code>: Sampling method.</li> <li><code>weight</code>: Scalar weight.</li> <li><code>label</code>: Optional label for logging.</li> <li><code>over</code>: Optional reduction axes.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>FunctionalConstraint</code> enforcing the Dirichlet condition.</li> </ul>"},{"location":"api/constraints/boundary/#phydrax.constraints.ContinuousNeumannBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousNeumannBoundaryConstraint(constraint_var: str, component: DomainComponent, /, *, var: str = 'x', target: DomainFunction | ArrayLike | None = None, mode: Literal[reverse, forward] = 'reverse', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Continuous Neumann boundary constraint.</p> <p>Enforces \\(\\partial u/\\partial n = g\\) on the boundary component, where \\(n\\) is the outward normal.</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Boundary component.</li> <li><code>var</code>: Geometry variable used to compute normals.</li> <li><code>target</code>: Target flux/function \\(g\\) (defaults to 0).</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>num_points</code>: Number of boundary samples.</li> <li><code>structure</code>: Sampling structure over labels.</li> <li><code>sampler</code>: Sampling method.</li> <li><code>weight</code>: Scalar weight.</li> <li><code>label</code>: Optional label for logging.</li> <li><code>over</code>: Optional reduction axes.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>FunctionalConstraint</code> enforcing the Neumann condition.</li> </ul>"},{"location":"api/constraints/boundary/#phydrax.constraints.ContinuousRobinBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousRobinBoundaryConstraint(constraint_var: str, component: DomainComponent, /, *, var: str = 'x', dirichlet_coeff: DomainFunction | ArrayLike | None = None, neumann_coeff: DomainFunction | ArrayLike | None = None, target: DomainFunction | ArrayLike | None = None, mode: Literal[reverse, forward] = 'reverse', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Continuous Robin boundary constraint.</p> <p>Enforces \\(c_0 u + c_1 \\\\, \\\\partial u/\\\\partial n = g\\) on the boundary component.</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Boundary component.</li> <li><code>var</code>: Geometry variable used to compute normals.</li> <li><code>dirichlet_coeff</code>: Coefficient \\(c_0\\) (defaults to 0).</li> <li><code>neumann_coeff</code>: Coefficient \\(c_1\\) (defaults to 0).</li> <li><code>target</code>: Target value/function \\(g\\) (defaults to 0).</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>num_points</code>: Number of boundary samples.</li> <li><code>structure</code>: Sampling structure over labels.</li> <li><code>sampler</code>: Sampling method.</li> <li><code>weight</code>: Scalar weight.</li> <li><code>label</code>: Optional label for logging.</li> <li><code>over</code>: Optional reduction axes.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>FunctionalConstraint</code> enforcing the Robin condition.</li> </ul>"},{"location":"api/constraints/boundary/#phydrax.constraints.AbsorbingBoundaryConstraint","title":"<code>phydrax.constraints.AbsorbingBoundaryConstraint(constraint_var: str, component: DomainComponent, /, *, var: str = 'x', time_var: str = 't', wavespeed: DomainFunction | ArrayLike | None = None, target: DomainFunction | ArrayLike | None = None, mode: Literal[reverse, forward] = 'reverse', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Absorbing/Sommerfeld boundary constraint</p> \\[ \\frac{\\partial u}{\\partial n} + \\frac{1}{c} \\frac{\\partial u}{\\partial t} = g. \\] <p>This is a common first-order radiation condition for wave-like PDEs, where <code>c</code> is a characteristic wave speed.</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Boundary <code>DomainComponent</code> to sample from.</li> <li><code>var</code>: Geometry label used for normals and spatial derivatives.</li> <li><code>time_var</code>: Time label used for \\(\\partial/\\partial t\\).</li> <li><code>wavespeed</code>: Wave speed <code>c</code> as a <code>DomainFunction</code>, callable, or array-like. Defaults to <code>1.0</code>.</li> <li><code>target</code>: Target value as a <code>DomainFunction</code>, callable, or array-like. Defaults to <code>0.0</code>.</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>num_points</code>: Number of boundary points to sample (paired or structured; see <code>structure</code>).</li> <li><code>structure</code>: A <code>ProductStructure</code> describing how variables are sampled/blocked.</li> <li><code>sampler</code>: Sampling scheme (e.g. <code>\"latin_hypercube\"</code>).</li> <li><code>weight</code>: Scalar multiplier applied to this term.</li> <li><code>over</code>: Optional subset of labels to reduce/integrate over.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul>"},{"location":"api/constraints/boundary/#generic-initial-constraints","title":"Generic initial constraints","text":""},{"location":"api/constraints/boundary/#phydrax.constraints.ContinuousInitialConstraint","title":"<code>phydrax.constraints.ContinuousInitialConstraint(constraint_var: str, component: DomainComponent | DomainComponentUnion, /, *, evolution_var: str = 't', func: DomainFunction | ArrayLike | None = None, time_derivative_order: int = 0, mode: Literal[reverse, forward] = 'reverse', time_derivative_backend: Literal[ad, jet] = 'ad', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, coord_separable: Mapping[str, Any] | None = None, dense_structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Continuous initial-condition constraint on a fixed-start time slice.</p> <p>Enforces</p> \\[ \\left.\\frac{\\partial^n u}{\\partial t^n}\\right|_{t=t_0} = g \\] <p>by sampling the initial slice, where <code>n = time_derivative_order</code>.</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Domain component on the initial surface (or a union of such components).</li> <li><code>evolution_var</code>: Time label used for the initial slice (default: <code>\"t\"</code>).</li> <li><code>func</code>: Target value/function \\(g\\) (defaults to 0).</li> <li><code>time_derivative_order</code>: Derivative order \\(n\\) for \\(\\partial^n/\\partial t^n\\).</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>time_derivative_backend</code>: Backend for time derivatives (<code>\"ad\"</code> or <code>\"jet\"</code>).</li> <li><code>num_points</code>: Number of initial-slice points to sample (paired or structured; see <code>structure</code>).</li> <li><code>structure</code>: A <code>ProductStructure</code> describing how variables are sampled/blocked.</li> <li><code>coord_separable</code>: Optional coord-separable sampling spec (per label).</li> <li><code>dense_structure</code>: Optional dense structure used when sampling produces dense batches.</li> <li><code>sampler</code>: Sampling scheme (e.g. <code>\"latin_hypercube\"</code>).</li> <li><code>weight</code>: Scalar multiplier applied to this term.</li> <li><code>label</code>: Optional label for logging.</li> <li><code>over</code>: Optional subset of labels to reduce/integrate over.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul>"},{"location":"api/constraints/cfd/","title":"CFD constraints","text":""},{"location":"api/constraints/cfd/#boundary-conditions","title":"Boundary conditions","text":""},{"location":"api/constraints/cfd/#phydrax.constraints.ContinuousSymmetryVelocityBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousSymmetryVelocityBoundaryConstraint(velocity_var: str, component: DomainComponent, /, *, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Symmetry (no-penetration) condition on a symmetry plane.</p> <p>Enforces \\(u\\cdot n = 0\\) on the boundary component.</p>"},{"location":"api/constraints/cfd/#phydrax.constraints.ContinuousNoPenetrationBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousNoPenetrationBoundaryConstraint(velocity_var: str, component: DomainComponent, /, *, wall_normal_velocity: DomainFunction | ArrayLike | None = None, wall_velocity: DomainFunction | ArrayLike | None = None, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>No-penetration (impermeability) wall boundary condition.</p> <p>Enforces the normal-velocity condition</p> \\[ u\\cdot n = u_n, \\] <p>where <code>u_n</code> can be provided via <code>wall_normal_velocity</code> or derived from a full <code>wall_velocity</code> by taking its normal component.</p>"},{"location":"api/constraints/cfd/#phydrax.constraints.ContinuousSlipWallBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousSlipWallBoundaryConstraint(velocity_var: str, pressure_var: str, component: DomainComponent, /, *, var: str = 'x', viscosity: DomainFunction | ArrayLike, mode: Literal[reverse, forward] = 'reverse', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Free-slip wall boundary condition via zero tangential traction.</p> <p>Forms the (pressure + viscous) traction</p> \\[ t = -p\\,n + \\tau\\,n,\\qquad \\tau = \\mu(\\nabla u + \\nabla u^\\top), \\] <p>and enforces that its tangential component vanishes:</p> \\[ (I - n\\otimes n)\\,t = 0. \\]"},{"location":"api/constraints/cfd/#-","title":"---","text":""},{"location":"api/constraints/cfd/#phydrax.constraints.DiscreteNoPenetrationBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteNoPenetrationBoundaryConstraint(velocity_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, wall_normal_velocity: ArrayLike | None = None, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete no-penetration constraint at explicit boundary anchor points.</p> <p>Enforces \\(u\\cdot n = u_n\\) (default \\(0\\)) at the provided points.</p>"},{"location":"api/constraints/cfd/#phydrax.constraints.DiscreteZeroNormalGradientVelocityBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteZeroNormalGradientVelocityBoundaryConstraint(velocity_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete zero normal-gradient condition for velocity at explicit anchor points.</p> <p>Enforces \\(\\partial u/\\partial n = 0\\) componentwise at the provided points.</p>"},{"location":"api/constraints/cfd/#integral-global-constraints","title":"Integral / global constraints","text":""},{"location":"api/constraints/cfd/#phydrax.constraints.CFDBoundaryFlowRateConstraint","title":"<code>phydrax.constraints.CFDBoundaryFlowRateConstraint(velocity_var: str, domain, /, *, flow_rate: ArrayLike, var: str = 'x', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Boundary integral constraint for volumetric flow rate.</p> <p>Enforces</p> \\[ \\int_{\\partial\\Omega} u\\cdot n\\,dS = \\dot{V}, \\] <p>where \\(\\dot{V}\\) is the prescribed flow rate.</p>"},{"location":"api/constraints/cfd/#phydrax.constraints.CFDKineticEnergyFluxBoundaryConstraint","title":"<code>phydrax.constraints.CFDKineticEnergyFluxBoundaryConstraint(velocity_var: str, domain, /, *, target_total_power: ArrayLike, var: str = 'x', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Boundary integral constraint for kinetic energy flux (power).</p> <p>Uses the flux density \\(\\tfrac12\\|u\\|_2^2(u\\cdot n)\\) and enforces</p> \\[ \\int_{\\partial\\Omega} \\tfrac12\\|u\\|_2^2(u\\cdot n)\\,dS = P. \\]"},{"location":"api/constraints/cfd/#phydrax.constraints.AveragePressureBoundaryConstraint","title":"<code>phydrax.constraints.AveragePressureBoundaryConstraint(pressure_var: str, domain, /, *, mean_pressure: ArrayLike, num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Boundary integral constraint for pressure.</p> <p>Enforces an integral of the form</p> \\[ \\int_{\\partial\\Omega} p\\,dS = c. \\] <p>If you want to enforce an average pressure \\(\\bar p\\), set <code>mean_pressure</code> to \\(\\bar p\\,|\\partial\\Omega|\\).</p>"},{"location":"api/constraints/continuous/","title":"Continuous constraints","text":"<p>These helpers construct sampled constraints over domain components. For details on reduction, measures, and filtering, see Guides \u2192 Constraints and objectives.</p>"},{"location":"api/constraints/continuous/#interior-initial-sampling-constraints","title":"Interior / initial sampling constraints","text":""},{"location":"api/constraints/continuous/#phydrax.constraints.ContinuousPointwiseInteriorConstraint","title":"<code>phydrax.constraints.ContinuousPointwiseInteriorConstraint(constraint_vars: str | Sequence[str], domain, operator, *, num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, coord_separable: Mapping[str, Any] | None = None, dense_structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean', where: Mapping[str, Any] | None = None, where_all: DomainFunction | None = None) -&gt; FunctionalConstraint</code>","text":"<p>Pointwise residual constraint over an interior domain component.</p> <p>Let <code>operator</code> define a residual <code>DomainFunction</code> \\(r\\) from one or more fields:</p> \\[ r = \\mathcal{N}(u_1,\\dots,u_k), \\] <p>where \\(r(z)\\) is evaluated at sampled interior points \\(z\\in\\Omega\\).</p> <p>The resulting objective is the mean or integral of the squared residual.</p> <p>For <code>reduction=\"mean\"</code>:</p> \\[ \\ell = w\\,\\frac{1}{\\mu(\\Omega)}\\int_{\\Omega} \\|r(z)\\|_F^2\\,d\\mu(z), \\] <p>For <code>reduction=\"integral\"</code>:</p> \\[ \\ell = w\\int_{\\Omega} \\|r(z)\\|_F^2\\,d\\mu(z). \\] <p>Arguments:</p> <ul> <li><code>constraint_vars</code>: Name (or names) of the field functions passed into <code>operator</code>.</li> <li><code>domain</code>: A <code>phydrax.domain</code> object to sample from.</li> <li><code>operator</code>: Callable mapping one or more <code>DomainFunction</code> objects to a residual   <code>DomainFunction</code>.</li> <li><code>num_points</code>: Number of interior points to sample (paired or structured; see <code>structure</code>).</li> <li><code>structure</code>: A <code>ProductStructure</code> describing how variables are sampled/blocked.</li> <li><code>coord_separable</code>: Optional coord-separable sampling spec (per label).</li> <li><code>dense_structure</code>: Optional dense structure used when sampling produces dense batches.</li> <li><code>sampler</code>: Sampling scheme (e.g. <code>\"latin_hypercube\"</code>).</li> <li><code>weight</code>: Scalar multiplier \\(w\\) applied to this term.</li> <li><code>over</code>: Optional subset of labels to reduce/integrate over.</li> <li><code>reduction</code>: Reduction mode: <code>\"mean\"</code> (measure-normalized) or <code>\"integral\"</code> (unnormalized).</li> <li><code>where</code>: Optional per-label filters, treated as indicator functions.</li> <li><code>where_all</code>: Optional global filter, evaluated on the full point tuple.</li> </ul>"},{"location":"api/constraints/continuous/#phydrax.constraints.ContinuousInitialConstraint","title":"<code>phydrax.constraints.ContinuousInitialConstraint(constraint_var: str, component: DomainComponent | DomainComponentUnion, /, *, evolution_var: str = 't', func: DomainFunction | ArrayLike | None = None, time_derivative_order: int = 0, mode: Literal[reverse, forward] = 'reverse', time_derivative_backend: Literal[ad, jet] = 'ad', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, coord_separable: Mapping[str, Any] | None = None, dense_structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Continuous initial-condition constraint on a fixed-start time slice.</p> <p>Enforces</p> \\[ \\left.\\frac{\\partial^n u}{\\partial t^n}\\right|_{t=t_0} = g \\] <p>by sampling the initial slice, where <code>n = time_derivative_order</code>.</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Domain component on the initial surface (or a union of such components).</li> <li><code>evolution_var</code>: Time label used for the initial slice (default: <code>\"t\"</code>).</li> <li><code>func</code>: Target value/function \\(g\\) (defaults to 0).</li> <li><code>time_derivative_order</code>: Derivative order \\(n\\) for \\(\\partial^n/\\partial t^n\\).</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>time_derivative_backend</code>: Backend for time derivatives (<code>\"ad\"</code> or <code>\"jet\"</code>).</li> <li><code>num_points</code>: Number of initial-slice points to sample (paired or structured; see <code>structure</code>).</li> <li><code>structure</code>: A <code>ProductStructure</code> describing how variables are sampled/blocked.</li> <li><code>coord_separable</code>: Optional coord-separable sampling spec (per label).</li> <li><code>dense_structure</code>: Optional dense structure used when sampling produces dense batches.</li> <li><code>sampler</code>: Sampling scheme (e.g. <code>\"latin_hypercube\"</code>).</li> <li><code>weight</code>: Scalar multiplier applied to this term.</li> <li><code>label</code>: Optional label for logging.</li> <li><code>over</code>: Optional subset of labels to reduce/integrate over.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul>"},{"location":"api/constraints/continuous/#phydrax.constraints.ContinuousInitialFunctionConstraint","title":"<code>phydrax.constraints.ContinuousInitialFunctionConstraint(constraint_vars: str | Sequence[str], domain, /, *, func: DomainFunction | ArrayLike | None = None, evolution_var: str = 't', time_derivative_order: int = 0, mode: Literal[reverse, forward] = 'reverse', time_derivative_backend: Literal[ad, jet] = 'ad', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, coord_separable: Mapping[str, Any] | None = None, dense_structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean', where: Mapping[str, Any] | None = None, where_all: DomainFunction | None = None) -&gt; FunctionalConstraint</code>","text":"<p>Initial-condition constraint matching time derivatives on the initial slice.</p> <p>Builds a constraint on the component slice <code>evolution_var = FixedStart()</code> and enforces</p> \\[ \\left.\\frac{\\partial^n u}{\\partial t^n}\\right|_{t=t_0} = g, \\] <p>where <code>n = time_derivative_order</code>, \\(t_0\\) is the start of the time interval, and <code>g</code> is provided by <code>func</code> (defaults to \\(0\\)).</p> <p>The loss is formed by sampling points on the initial slice and reducing the squared residual as in <code>FunctionalConstraint</code>.</p> <p>Arguments:</p> <ul> <li><code>constraint_vars</code>: Name (or names) of the field functions passed into the residual.</li> <li><code>domain</code>: A <code>phydrax.domain</code> object to sample from.</li> <li><code>func</code>: Target value \\(g\\) as a <code>DomainFunction</code>, callable, or array-like. Defaults to <code>0.0</code>.</li> <li><code>evolution_var</code>: Name of the time-like label used for the initial slice (default <code>\"t\"</code>).</li> <li><code>time_derivative_order</code>: Derivative order \\(n\\) for \\(\\partial^n/\\partial t^n\\).</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>time_derivative_backend</code>: Backend for time derivatives (<code>\"ad\"</code> or <code>\"jet\"</code>).</li> <li><code>num_points</code>: Number of initial-slice points to sample (paired or structured; see <code>structure</code>).</li> <li><code>structure</code>: A <code>ProductStructure</code> describing how variables are sampled/blocked.</li> <li><code>coord_separable</code>: Optional coord-separable sampling spec (per label).</li> <li><code>dense_structure</code>: Optional dense structure used when sampling produces dense batches.</li> <li><code>sampler</code>: Sampling scheme (e.g. <code>\"latin_hypercube\"</code>).</li> <li><code>weight</code>: Scalar multiplier applied to this term.</li> <li><code>over</code>: Optional subset of labels to reduce/integrate over.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> <li><code>where</code>: Optional per-label filters, treated as indicator functions.</li> <li><code>where_all</code>: Optional global filter, evaluated on the full point tuple.</li> </ul>"},{"location":"api/constraints/continuous/#integral-constraints","title":"Integral constraints","text":""},{"location":"api/constraints/continuous/#phydrax.constraints.ContinuousIntegralInteriorConstraint","title":"<code>phydrax.constraints.ContinuousIntegralInteriorConstraint(constraint_vars: str | Sequence[str], domain, operator: Callable[..., DomainFunction] | DomainFunction, /, *, num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, equal_to: ArrayLike | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Integral equality constraint over an interior component.</p> <p>Enforces an interior integral condition of the form</p> \\[ \\int_{\\Omega} f(z)\\,d\\mu(z) = c, \\] <p>where the integrand \\(f\\) is produced by <code>operator</code> applied to the named <code>constraint_vars</code>.</p>"},{"location":"api/constraints/continuous/#phydrax.constraints.ContinuousIntegralBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousIntegralBoundaryConstraint(constraint_vars: str | Sequence[str], domain, operator: Callable[..., DomainFunction] | DomainFunction, /, *, num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, equal_to: ArrayLike | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Integral equality constraint over a boundary component.</p> <p>Enforces a boundary integral condition</p> \\[ \\int_{\\partial\\Omega} f(x,n(x))\\,dS = c, \\] <p>where <code>operator</code> receives the boundary normal field \\(n(x)\\) as an additional argument.</p>"},{"location":"api/constraints/continuous/#phydrax.constraints.ContinuousIntegralInitialConstraint","title":"<code>phydrax.constraints.ContinuousIntegralInitialConstraint(constraint_vars: str | Sequence[str], domain, operator: Callable[..., DomainFunction] | DomainFunction, /, *, evolution_var: str = 't', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, equal_to: ArrayLike | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Integral equality constraint over the initial surface.</p> <p>Constructs a component slice <code>evolution_var = FixedStart()</code> (e.g. \\(t=t_0\\)) and enforces an integral condition on that slice.</p>"},{"location":"api/constraints/continuous/#ode-constraints","title":"ODE constraints","text":""},{"location":"api/constraints/continuous/#phydrax.constraints.ContinuousODEConstraint","title":"<code>phydrax.constraints.ContinuousODEConstraint(constraint_var: str, domain: TimeInterval, operator: Callable[[DomainFunction], DomainFunction], /, *, num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Continuous ODE residual constraint on a <code>TimeInterval</code>.</p> <p>Given an ODE residual operator \\(\\mathcal{R}\\) (provided by <code>operator</code>), this enforces \\(\\mathcal{R}(u)(t)=0\\) in a sampled/weak sense by minimizing</p> \\[ \\ell = w\\,\\frac{1}{|[t_0,t_1]|}\\int_{t_0}^{t_1}\\|\\mathcal{R}(u)(t)\\|_F^2\\,dt \\] <p>(or the unnormalized integral when <code>reduction=\"integral\"</code>).</p>"},{"location":"api/constraints/continuous/#phydrax.constraints.InitialODEConstraint","title":"<code>phydrax.constraints.InitialODEConstraint(constraint_var: str, domain: TimeInterval, /, *, func: DomainFunction | ArrayLike | Callable | None = None, time_derivative_order: int = 0, time_derivative_backend: Literal[ad, jet] = 'ad', weight: ArrayLike = 1.0, label: str | None = None, structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Initial-condition constraint on the slice \\(t=t_0\\).</p> <p>Enforces</p> \\[ \\left.\\frac{\\partial^n u}{\\partial t^n}\\right|_{t=t_0} = g, \\] <p>where <code>n = time_derivative_order</code> and <code>g</code> is given by <code>func</code> (defaults to \\(0\\)).</p>"},{"location":"api/constraints/core/","title":"Core constraints","text":"<p>For the mathematical conventions used by sampled constraints (residual norms, reduction modes, measures, and <code>over=</code> semantics), see Guides \u2192 Constraints and objectives.</p>"},{"location":"api/constraints/core/#constraint-containers","title":"Constraint containers","text":""},{"location":"api/constraints/core/#phydrax.constraints.FunctionalConstraint","title":"<code>phydrax.constraints.FunctionalConstraint</code>","text":"<p>A sampled objective term defined by a residual <code>DomainFunction</code>.</p> <p>A <code>FunctionalConstraint</code> represents one term in a physics/data objective. It is defined by:</p> <ul> <li>a <code>DomainComponent</code> (or union) describing the integration/sampling region   \\(\\Omega_{\\text{comp}}\\) and measure \\(\\mu\\);</li> <li>a residual operator producing a <code>DomainFunction</code> \\(r(z)\\) from the current set of   field functions.</li> </ul> <p>The pointwise squared residual is taken as a Frobenius norm:</p> \\[ \\rho(z) = \\|r(z)\\|_F^2 = \\sum_{i} r_i(z)^2, \\] <p>and the scalar loss is computed using either reduction mode.</p> <p>For <code>reduction=\"mean\"</code>:</p> \\[ \\ell = w\\,\\frac{1}{\\mu(\\Omega_{\\text{comp}})}\\int_{\\Omega_{\\text{comp}}} \\rho(z)\\,d\\mu(z), \\] <p>For <code>reduction=\"integral\"</code>:</p> \\[ \\ell = w\\int_{\\Omega_{\\text{comp}}} \\rho(z)\\,d\\mu(z), \\] <p>where \\(w\\) is the scalar <code>weight</code>.</p> <p>Sampling is performed according to <code>structure</code> (paired blocks) and optionally <code>coord_separable</code>.</p>"},{"location":"api/constraints/core/#phydrax.constraints.FunctionalConstraint.__init__","title":"<code>__init__(*, component: DomainComponent | DomainComponentUnion, residual: Callable[[Mapping[str, DomainFunction]], DomainFunction], num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, coord_separable: Mapping[str, Any] | None = None, dense_structure: ProductStructure | None = None, constraint_vars: Sequence[str] | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean')</code>","text":""},{"location":"api/constraints/core/#phydrax.constraints.FunctionalConstraint.from_operator","title":"<code>from_operator(*, component: DomainComponent | DomainComponentUnion, operator: Callable[..., DomainFunction], constraint_vars: str | Sequence[str], num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, coord_separable: Mapping[str, int | Sequence[int]] | None = None, dense_structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>  <code>classmethod</code>","text":"<p>Create a <code>FunctionalConstraint</code> from an operator mapping <code>DomainFunction</code>s to a residual.</p> <p>This wraps an <code>operator(u1, u2, ...) -&gt; r</code> into a residual callable <code>residual(functions) -&gt; r</code> using the provided <code>constraint_vars</code>.</p>"},{"location":"api/constraints/core/#phydrax.constraints.FunctionalConstraint.sample","title":"<code>sample(*, key: Key[Array, ''] = jr.key(0)) -&gt; PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...]</code>","text":"<p>Sample points from the configured component.</p> <ul> <li>Returns a <code>PointsBatch</code> for paired sampling (<code>coord_separable=None</code>).</li> <li>Returns a <code>CoordSeparableBatch</code> when <code>coord_separable</code> is enabled.</li> <li>Returns a tuple of <code>PointsBatch</code> when sampling from a <code>DomainComponentUnion</code>.</li> </ul>"},{"location":"api/constraints/core/#phydrax.constraints.FunctionalConstraint.loss","title":"<code>loss(functions: Mapping[str, DomainFunction], /, *, key: Key[Array, ''] = jr.key(0), batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...] | None = None, **kwargs: Any) -&gt; Array</code>","text":"<p>Evaluate the scalar loss for this constraint.</p> <p>This samples the configured component, evaluates the residual, forms a squared Frobenius norm, and reduces via <code>mean(...)</code> or <code>integral(...)</code> depending on <code>reduction</code> and <code>over</code>.</p> <p>This: 1) builds the residual <code>DomainFunction</code> \\(r\\) from <code>functions</code>, 2) samples points \\(z_i\\) on <code>component</code>, 3) computes \\(\\rho(z_i)=\\|r(z_i)\\|_F^2\\), 4) reduces using either a mean or an integral estimator.</p>"},{"location":"api/constraints/core/#phydrax.constraints.PointSetConstraint","title":"<code>phydrax.constraints.PointSetConstraint</code>","text":"<p>A constraint evaluated on an explicit finite set of points.</p> <p>Given a fixed collection of points \\(\\{z_i\\}_{i=1}^N\\) (encoded as a <code>PointsBatch</code>) and a residual <code>DomainFunction</code> \\(r(z)\\), the pointwise squared residual is</p> \\[ \\rho(z_i)=\\|r(z_i)\\|_F^2. \\] <p>The scalar loss is then</p> <p>For <code>reduction=\"mean\"</code>:</p> \\[ \\ell = w\\,\\frac{1}{N}\\sum_{i=1}^N \\rho(z_i), \\] <p>For <code>reduction=\"sum\"</code>:</p> \\[ \\ell = w\\sum_{i=1}^N \\rho(z_i), \\] <p>where \\(w\\) is the scalar <code>weight</code>.</p>"},{"location":"api/constraints/core/#phydrax.constraints.PointSetConstraint.__init__","title":"<code>__init__(*, points: PointsBatch, residual: Callable[[Mapping[str, DomainFunction]], DomainFunction], constraint_vars: Sequence[str] | None = None, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal['mean', 'sum'] = 'mean')</code>","text":"<p>Create a point-set constraint from points and a residual callable.</p>"},{"location":"api/constraints/core/#phydrax.constraints.PointSetConstraint.from_points","title":"<code>from_points(*, component: DomainComponent, points: Mapping[str, ArrayLike] | ArrayLike, residual: Callable[[Mapping[str, DomainFunction]], DomainFunction], constraint_vars: Sequence[str] | None = None, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal['mean', 'sum'] = 'mean') -&gt; PointSetConstraint</code>  <code>classmethod</code>","text":"<p>Build a <code>PointSetConstraint</code> from raw point coordinates.</p>"},{"location":"api/constraints/core/#phydrax.constraints.PointSetConstraint.from_operator","title":"<code>from_operator(*, points: PointsBatch, operator: Callable[..., DomainFunction], constraint_vars: str | Sequence[str], weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal['mean', 'sum'] = 'mean') -&gt; PointSetConstraint</code>  <code>classmethod</code>","text":"<p>Build a <code>PointSetConstraint</code> from an operator applied to named fields.</p>"},{"location":"api/constraints/core/#phydrax.constraints.PointSetConstraint.loss","title":"<code>loss(functions: Mapping[str, DomainFunction], /, *, key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; Array</code>","text":"<p>Evaluate the point-set loss.</p> <p>This evaluates the residual on the stored points and applies the configured reduction (<code>mean</code> or <code>sum</code>).</p>"},{"location":"api/constraints/core/#phydrax.constraints.IntegralEqualityConstraint","title":"<code>phydrax.constraints.IntegralEqualityConstraint</code>","text":"<p>A constraint enforcing an integral equality.</p> <p>Given an integrand <code>DomainFunction</code> \\(f(z)\\) on a component \\(\\Omega_{\\text{comp}}\\), this enforces the scalar equality</p> \\[ \\int_{\\Omega_{\\text{comp}}} f(z)\\,d\\mu(z) = c, \\] <p>by minimizing the squared error</p> \\[ \\ell = w\\left\\|\\int_{\\Omega_{\\text{comp}}} f(z)\\,d\\mu(z) - c\\right\\|_2^2, \\] <p>where \\(w\\) is <code>weight</code> and \\(c\\) is <code>equal_to</code>.</p>"},{"location":"api/constraints/core/#phydrax.constraints.IntegralEqualityConstraint.__init__","title":"<code>__init__(*, component: DomainComponent | DomainComponentUnion, integrand: Callable[[Mapping[str, DomainFunction]], DomainFunction], equal_to: ArrayLike = 0.0, num_points: NumPoints | tuple[Any, ...], structure: ProductStructure, coord_separable: Mapping[str, Any] | None = None, dense_structure: ProductStructure | None = None, constraint_vars: Sequence[str] | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None)</code>","text":"<p>Create an integral equality constraint from an integrand callable.</p>"},{"location":"api/constraints/core/#phydrax.constraints.IntegralEqualityConstraint.loss","title":"<code>loss(functions: Mapping[str, DomainFunction], /, *, key: Key[Array, ''] = jr.key(0), batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...] | None = None, **kwargs: Any) -&gt; Array</code>","text":"<p>Evaluate the squared integral mismatch loss.</p> <p>Computes the integral estimate \\(\\widehat{I} \\approx \\int f\\,d\\mu\\) and returns \\(w\\|\\widehat{I}-c\\|_2^2\\).</p>"},{"location":"api/constraints/discrete/","title":"Discrete constraints","text":""},{"location":"api/constraints/discrete/#discrete-point-constraints","title":"Discrete point constraints","text":""},{"location":"api/constraints/discrete/#phydrax.constraints.PointSetConstraint","title":"<code>phydrax.constraints.PointSetConstraint</code>","text":"<p>A constraint evaluated on an explicit finite set of points.</p> <p>Given a fixed collection of points \\(\\{z_i\\}_{i=1}^N\\) (encoded as a <code>PointsBatch</code>) and a residual <code>DomainFunction</code> \\(r(z)\\), the pointwise squared residual is</p> \\[ \\rho(z_i)=\\|r(z_i)\\|_F^2. \\] <p>The scalar loss is then</p> <p>For <code>reduction=\"mean\"</code>:</p> \\[ \\ell = w\\,\\frac{1}{N}\\sum_{i=1}^N \\rho(z_i), \\] <p>For <code>reduction=\"sum\"</code>:</p> \\[ \\ell = w\\sum_{i=1}^N \\rho(z_i), \\] <p>where \\(w\\) is the scalar <code>weight</code>.</p>"},{"location":"api/constraints/discrete/#phydrax.constraints.PointSetConstraint.__init__","title":"<code>__init__(*, points: PointsBatch, residual: Callable[[Mapping[str, DomainFunction]], DomainFunction], constraint_vars: Sequence[str] | None = None, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal['mean', 'sum'] = 'mean')</code>","text":"<p>Create a point-set constraint from points and a residual callable.</p>"},{"location":"api/constraints/discrete/#phydrax.constraints.PointSetConstraint.from_points","title":"<code>from_points(*, component: DomainComponent, points: Mapping[str, ArrayLike] | ArrayLike, residual: Callable[[Mapping[str, DomainFunction]], DomainFunction], constraint_vars: Sequence[str] | None = None, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal['mean', 'sum'] = 'mean') -&gt; PointSetConstraint</code>  <code>classmethod</code>","text":"<p>Build a <code>PointSetConstraint</code> from raw point coordinates.</p>"},{"location":"api/constraints/discrete/#phydrax.constraints.PointSetConstraint.from_operator","title":"<code>from_operator(*, points: PointsBatch, operator: Callable[..., DomainFunction], constraint_vars: str | Sequence[str], weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal['mean', 'sum'] = 'mean') -&gt; PointSetConstraint</code>  <code>classmethod</code>","text":"<p>Build a <code>PointSetConstraint</code> from an operator applied to named fields.</p>"},{"location":"api/constraints/discrete/#phydrax.constraints.PointSetConstraint.loss","title":"<code>loss(functions: Mapping[str, DomainFunction], /, *, key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; Array</code>","text":"<p>Evaluate the point-set loss.</p> <p>This evaluates the residual on the stored points and applies the configured reduction (<code>mean</code> or <code>sum</code>).</p>"},{"location":"api/constraints/discrete/#phydrax.constraints.DiscreteInteriorDataConstraint","title":"<code>phydrax.constraints.DiscreteInteriorDataConstraint(constraint_var: str, domain, /, *, points: Mapping[str, ArrayLike] | ArrayLike | None = None, values: ArrayLike | None = None, sensors: Mapping[str, ArrayLike] | ArrayLike | None = None, times: ArrayLike | None = None, sensor_values: ArrayLike | None = None, num_points: NumPoints | tuple[Any, ...] | None = None, structure: ProductStructure | None = None, coord_separable: Mapping[str, Any] | None = None, dense_structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, reduction: Literal[mean, sum] = 'mean', idw_exponent: float = 2.0, eps_snap: float = 1e-12, lengthscales: Mapping[str, float] | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None, label: str | None = None) -&gt; FunctionalConstraint | PointSetConstraint</code>","text":"<p>Discrete interior data-fit constraint from anchors or sensor tracks.</p> <p>This enforces agreement between a field \\(u\\) and discrete data in one of two forms:</p> <p>1) Anchors (scattered measurements):    given points \\(\\{z_i\\}_{i=1}^N\\) and values \\(\\{y_i\\}\\), enforce \\(u(z_i)\\approx y_i\\),    producing a <code>PointSetConstraint</code> with residual \\(r_i = u(z_i) - y_i\\).</p> <p>2) Sensor tracks (fixed sensors over time):    given sensor locations \\(x_m\\), times \\(t_j\\), and measurements \\(y_{m,j}\\), construct    a target function \\(g(x,t)\\) (via spatial IDW + time interpolation) and enforce    \\(u(x,t)\\approx g(x,t)\\) at sampled \\((x,t)\\) pairs, producing a <code>FunctionalConstraint</code>.</p> <p>For anchor data, a continuous target function can be constructed via inverse distance weighting (IDW) interpolation; see <code>idw_interpolant</code>.</p> <p>Returns:</p> <ul> <li>A <code>PointSetConstraint</code> (anchors), or a <code>FunctionalConstraint</code> (sensor tracks).</li> </ul>"},{"location":"api/constraints/discrete/#phydrax.constraints.DiscreteTimeDataConstraint","title":"<code>phydrax.constraints.DiscreteTimeDataConstraint(constraint_var: str, domain: TimeInterval, /, *, times: ArrayLike, values: ArrayLike, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete data-fit constraint \\(u(t_i)\\approx y_i\\) with smooth time interpolation.</p> <p>Constructs a cubic Hermite spline target \\(g(t)\\) through the samples <code>(times, values)</code> and enforces \\(u(t_i)\\approx g(t_i)\\) at the provided times.</p>"},{"location":"api/constraints/discrete/#discrete-boundary-initial-constraints","title":"Discrete boundary / initial constraints","text":""},{"location":"api/constraints/discrete/#phydrax.constraints.DiscreteDirichletBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteDirichletBoundaryConstraint(constraint_var: str, component: DomainComponent | DomainComponentUnion, /, *, points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, idw_exponent: float = 2.0, eps_snap: float = 1e-12, lengthscales: Mapping[str, float] | None = None, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete Dirichlet constraint on a boundary component at explicit anchor points.</p> <p>Interpolates the provided <code>(points, values)</code> into a <code>DomainFunction</code> target via inverse-distance weighting (IDW), and then enforces <code>u(points) = target(points)</code>.</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Boundary <code>DomainComponent</code> associated with the points.</li> <li><code>points</code>: Anchor point coordinates (mapping by label, or stacked array).</li> <li><code>values</code>: Target values at the anchor points.</li> <li><code>idw_exponent</code>: Power \\(p\\) in IDW weights \\(w_j \\propto (\\|z-z_j\\|^2 + \\varepsilon)^{-p/2}\\).</li> <li><code>eps_snap</code>: Snap threshold \\(\\varepsilon\\) used to return exact anchors when very close.</li> <li><code>lengthscales</code>: Optional per-label lengthscales used inside the distance metric.</li> <li><code>weight</code>: Scalar multiplier applied to this term.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"sum\"</code>.</li> </ul>"},{"location":"api/constraints/discrete/#phydrax.constraints.DiscreteNeumannBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteNeumannBoundaryConstraint(constraint_var: str, component: DomainComponent | DomainComponentUnion, /, *, points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', idw_exponent: float = 2.0, eps_snap: float = 1e-12, lengthscales: Mapping[str, float] | None = None, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete Neumann constraint on a boundary component at explicit anchor points.</p> <p>Interpolates the provided <code>(points, values)</code> into a <code>DomainFunction</code> target via inverse-distance weighting (IDW), and then enforces \\(\\partial u/\\partial n = g\\) at the provided points.</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Boundary <code>DomainComponent</code> associated with the points.</li> <li><code>points</code>: Anchor point coordinates (mapping by label, or stacked array).</li> <li><code>values</code>: Target Neumann data \\(g\\) at the anchor points.</li> <li><code>var</code>: Geometry label used to compute normals and differentiate.</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>idw_exponent</code>: Power \\(p\\) in IDW weights \\(w_j \\propto (\\|z-z_j\\|^2 + \\varepsilon)^{-p/2}\\).</li> <li><code>eps_snap</code>: Snap threshold \\(\\varepsilon\\) used to return exact anchors when very close.</li> <li><code>lengthscales</code>: Optional per-label lengthscales used inside the distance metric.</li> <li><code>weight</code>: Scalar multiplier applied to this term.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"sum\"</code>.</li> </ul>"},{"location":"api/constraints/discrete/#phydrax.constraints.DiscreteInitialConstraint","title":"<code>phydrax.constraints.DiscreteInitialConstraint(constraint_var: str, component: DomainComponent | DomainComponentUnion, /, *, evolution_var: str = 't', points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, time_derivative_order: int = 0, mode: Literal[reverse, forward] = 'reverse', time_derivative_backend: Literal[ad, jet] = 'ad', idw_exponent: float = 2.0, eps_snap: float = 1e-12, lengthscales: Mapping[str, float] | None = None, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete initial-condition constraint from anchor points on the initial surface.</p> <p>Enforces</p> \\[ \\left.\\frac{\\partial^n u}{\\partial t^n}\\right|_{t=t_0}(x_i) \\approx y_i \\] <p>at provided anchor points, where <code>n = time_derivative_order</code> and \\(t_0\\) is the start of the time interval.</p> <p>Arguments:</p> <ul> <li><code>constraint_var</code>: Name of the constrained field.</li> <li><code>component</code>: Domain component on the initial surface (or a union of such components).</li> <li><code>evolution_var</code>: Time label used for the initial slice (default: <code>\"t\"</code>).</li> <li><code>points</code>: Anchor point coordinates (mapping by label, or stacked array).</li> <li><code>values</code>: Target values \\(y_i\\) at the anchor points.</li> <li><code>time_derivative_order</code>: Derivative order \\(n\\) for \\(\\partial^n/\\partial t^n\\).</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>time_derivative_backend</code>: Backend for time derivatives (<code>\"ad\"</code> or <code>\"jet\"</code>).</li> <li><code>idw_exponent</code>: Power \\(p\\) in IDW weights \\(w_j \\propto (\\|z-z_j\\|^2 + \\varepsilon)^{-p/2}\\).</li> <li><code>eps_snap</code>: Snap threshold \\(\\varepsilon\\) used to return exact anchors when very close.</li> <li><code>lengthscales</code>: Optional per-label lengthscales used inside the distance metric.</li> <li><code>weight</code>: Scalar multiplier applied to this term.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"sum\"</code>.</li> </ul>"},{"location":"api/constraints/discrete/#discrete-ode-constraints","title":"Discrete ODE constraints","text":""},{"location":"api/constraints/discrete/#phydrax.constraints.DiscreteODEConstraint","title":"<code>phydrax.constraints.DiscreteODEConstraint(constraint_var: str, domain: TimeInterval, operator: Callable[[DomainFunction], DomainFunction], /, *, times: ArrayLike, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete ODE residual constraint evaluated at explicit times.</p> <p>Evaluates the ODE residual \\(\\mathcal{R}(u)(t_i)\\) at the provided times <code>times</code> and applies a mean/sum reduction of \\(\\|\\mathcal{R}(u)(t_i)\\|_F^2\\).</p>"},{"location":"api/constraints/em/","title":"Electromagnetics constraints","text":""},{"location":"api/constraints/em/#boundary-conditions","title":"Boundary conditions","text":""},{"location":"api/constraints/em/#phydrax.constraints.ContinuousPECBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousPECBoundaryConstraint(field_var: str, component: DomainComponent, /, *, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Perfect electric conductor (PEC) boundary condition.</p> <p>For an electric field \\(E\\), PEC implies the tangential component vanishes:</p> \\[ E_t = (I-n\\otimes n)\\,E = 0, \\] <p>equivalently \\(n\\times E = 0\\).</p>"},{"location":"api/constraints/em/#phydrax.constraints.ContinuousPMCBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousPMCBoundaryConstraint(field_var: str, component: DomainComponent, /, *, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Perfect magnetic conductor (PMC) boundary condition.</p> <p>For a magnetic field \\(H\\), PMC implies the tangential component vanishes:</p> \\[ H_t = (I-n\\otimes n)\\,H = 0, \\] <p>equivalently \\(n\\times H = 0\\).</p>"},{"location":"api/constraints/em/#phydrax.constraints.ContinuousImpedanceBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousImpedanceBoundaryConstraint(h_var: str, e_var: str, component: DomainComponent, /, *, admittance: DomainFunction | ArrayLike, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Impedance (Leontovich) boundary condition.</p> <p>Enforces a linear relation between tangential \\(E\\) and \\(H\\):</p> \\[ n\\times H = Y\\,E_t, \\] <p>where <code>admittance</code> is \\(Y\\) and \\(E_t\\) is the tangential projection of \\(E\\).</p>"},{"location":"api/constraints/em/#phydrax.constraints.ContinuousElectricSurfaceChargeBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousElectricSurfaceChargeBoundaryConstraint(field_var: str, component: DomainComponent, /, *, epsilon: DomainFunction | ArrayLike, surface_charge: DomainFunction | ArrayLike, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Surface charge boundary condition for the electric field.</p> <p>Enforces a normal-flux condition</p> \\[ \\epsilon\\,E\\cdot n = \\rho_s, \\] <p>where \\(\\rho_s\\) is a prescribed surface charge density.</p>"},{"location":"api/constraints/em/#phydrax.constraints.ContinuousMagneticSurfaceCurrentBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousMagneticSurfaceCurrentBoundaryConstraint(field_var: str, component: DomainComponent, /, *, surface_current: DomainFunction | ArrayLike, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Surface current boundary condition for the magnetic field.</p> <p>Enforces the tangential jump condition</p> \\[ n\\times H = K_s, \\] <p>where \\(K_s\\) is a prescribed surface current density.</p>"},{"location":"api/constraints/em/#phydrax.constraints.ContinuousInterfaceNormalBContinuityConstraint","title":"<code>phydrax.constraints.ContinuousInterfaceNormalBContinuityConstraint(h1_var: str, h2_var: str, component: DomainComponent, /, *, mu1: DomainFunction | ArrayLike, mu2: DomainFunction | ArrayLike, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Normal continuity of magnetic flux density across an interface.</p> <p>For \\(B=\\mu H\\), enforces</p> \\[ (B_2 - B_1)\\cdot n = 0, \\] <p>i.e. \\(\\mu_2 H_2\\cdot n - \\mu_1 H_1\\cdot n = 0\\).</p>"},{"location":"api/constraints/em/#phydrax.constraints.ContinuousInterfaceNormalDJumpConstraint","title":"<code>phydrax.constraints.ContinuousInterfaceNormalDJumpConstraint(e1_var: str, e2_var: str, component: DomainComponent, /, *, epsilon1: DomainFunction | ArrayLike, epsilon2: DomainFunction | ArrayLike, surface_charge: DomainFunction | ArrayLike | None = None, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Normal jump condition for electric displacement across an interface.</p> <p>For \\(D=\\epsilon E\\), enforces</p> \\[ (D_2 - D_1)\\cdot n = \\rho_s, \\] <p>i.e. \\(\\epsilon_2 E_2\\cdot n - \\epsilon_1 E_1\\cdot n = \\rho_s\\).</p>"},{"location":"api/constraints/em/#phydrax.constraints.ContinuousInterfaceTangentialEContinuityConstraint","title":"<code>phydrax.constraints.ContinuousInterfaceTangentialEContinuityConstraint(e1_var: str, e2_var: str, component: DomainComponent, /, *, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Tangential continuity of electric field across an interface.</p> <p>Enforces \\((E_2 - E_1)_t = 0\\), i.e. tangential \\(E\\) is continuous across the interface.</p>"},{"location":"api/constraints/em/#phydrax.constraints.ContinuousInterfaceTangentialHJumpConstraint","title":"<code>phydrax.constraints.ContinuousInterfaceTangentialHJumpConstraint(h1_var: str, h2_var: str, component: DomainComponent, /, *, surface_current: DomainFunction | ArrayLike | None = None, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Tangential jump condition for magnetic field across an interface.</p> <p>Enforces</p> \\[ n\\times(H_2 - H_1) = K_s, \\] <p>where \\(K_s\\) is an optional surface current density (defaults to \\(0\\)).</p>"},{"location":"api/constraints/em/#phydrax.constraints.DiscretePECBoundaryConstraint","title":"<code>phydrax.constraints.DiscretePECBoundaryConstraint(field_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete PEC constraint at explicit boundary anchor points.</p>"},{"location":"api/constraints/em/#phydrax.constraints.DiscretePMCBoundaryConstraint","title":"<code>phydrax.constraints.DiscretePMCBoundaryConstraint(field_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete PMC constraint at explicit boundary anchor points.</p>"},{"location":"api/constraints/em/#phydrax.constraints.DiscreteElectricSurfaceChargeBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteElectricSurfaceChargeBoundaryConstraint(field_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, surface_charge_values: ArrayLike, epsilon: DomainFunction | ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete surface charge constraint at explicit boundary anchor points.</p>"},{"location":"api/constraints/em/#phydrax.constraints.DiscreteMagneticSurfaceCurrentBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteMagneticSurfaceCurrentBoundaryConstraint(field_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, surface_current_values: ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete surface current constraint at explicit boundary anchor points.</p>"},{"location":"api/constraints/em/#phydrax.constraints.DiscreteInterfaceNormalBContinuityConstraint","title":"<code>phydrax.constraints.DiscreteInterfaceNormalBContinuityConstraint(field_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, mu: DomainFunction | ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete normal magnetic flux continuity constraint at explicit interface points.</p>"},{"location":"api/constraints/em/#phydrax.constraints.DiscreteInterfaceNormalDJumpConstraint","title":"<code>phydrax.constraints.DiscreteInterfaceNormalDJumpConstraint(field_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, epsilon: DomainFunction | ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete normal electric displacement jump constraint at explicit interface points.</p>"},{"location":"api/constraints/em/#phydrax.constraints.DiscreteInterfaceTangentialEContinuityConstraint","title":"<code>phydrax.constraints.DiscreteInterfaceTangentialEContinuityConstraint(field_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, tangential_values: ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete tangential electric continuity constraint at explicit interface points.</p>"},{"location":"api/constraints/em/#phydrax.constraints.DiscreteInterfaceTangentialHJumpConstraint","title":"<code>phydrax.constraints.DiscreteInterfaceTangentialHJumpConstraint(field_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, Ks_values: ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete tangential magnetic jump constraint at explicit interface points.</p>"},{"location":"api/constraints/em/#integral-global-constraints","title":"Integral / global constraints","text":""},{"location":"api/constraints/em/#phydrax.constraints.EMBoundaryChargeConstraint","title":"<code>phydrax.constraints.EMBoundaryChargeConstraint(field_var: str, domain, /, *, total_free_charge: ArrayLike, var: str = 'x', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Boundary integral constraint for total free charge (Gauss law).</p> <p>For an electric displacement-like field \\(D\\), Gauss' law implies</p> \\[ \\int_{\\partial\\Omega} D\\cdot n\\,dS = Q_{\\text{free}}. \\] <p>This enforces that equality with <code>total_free_charge</code>.</p>"},{"location":"api/constraints/em/#phydrax.constraints.EMPoyntingFluxBoundaryConstraint","title":"<code>phydrax.constraints.EMPoyntingFluxBoundaryConstraint(e_var: str, h_var: str, domain, /, *, target_total_power: ArrayLike, num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Boundary integral constraint for Poynting flux (electromagnetic power).</p> <p>The Poynting vector is \\(S = E\\times H\\). This enforces</p> \\[ \\int_{\\partial\\Omega} (E\\times H)\\cdot n\\,dS = P. \\]"},{"location":"api/constraints/em/#phydrax.constraints.MagneticFluxZeroConstraint","title":"<code>phydrax.constraints.MagneticFluxZeroConstraint(field_var: str, domain, /, *, var: str = 'x', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Boundary integral constraint enforcing zero net magnetic flux.</p> <p>For a magnetic flux density field \\(B\\), one form of \\(\\nabla\\cdot B = 0\\) is</p> \\[ \\int_{\\partial\\Omega} B\\cdot n\\,dS = 0. \\]"},{"location":"api/constraints/enforced/","title":"Enforced constraint ans\u00e4tze","text":"<p>These helpers construct ans\u00e4tze that satisfy constraints by construction.</p> <p>For composition/ordering (multi-field dependencies, applying several enforced constraints, etc.), see Enforced constraint pipelines.</p> <p>Warning</p> <p>Compatibility with coord-separable grids:</p> <ul> <li><code>enforce_neumann</code>, <code>enforce_robin</code>, <code>enforce_traction</code>, and <code>enforce_sommerfeld</code> rely on geometry   boundary normals \\(n(x)\\) (via \\(\\partial/\\partial n\\)) and therefore do not   support coord-separable (tuple-of-axes) evaluation. Phydrax raises a <code>ValueError</code>   if you try to evaluate these ans\u00e4tze on a <code>CoordSeparableBatch</code>.</li> <li><code>enforce_dirichlet</code>, <code>enforce_initial</code>, and <code>enforce_blend</code> do not require boundary normals   and can be used in spectral/FNO-style interior grid evaluations.</li> </ul>"},{"location":"api/constraints/enforced/#phydrax.constraints.enforce_dirichlet","title":"<code>phydrax.constraints.enforce_dirichlet(u: DomainFunction, component: DomainComponent, /, *, var: str = 'x', target: DomainFunction | ArrayLike | None = None) -&gt; DomainFunction</code>","text":"<p>Enforced Dirichlet ansatz enforcing \\(u=g\\) on a component.</p> <p>Constructs an ansatz \\(u^*\\) that satisfies the Dirichlet condition exactly on the selected component (boundary or fixed slice). For a geometry boundary with signed distance field \\(\\phi\\) (so \\(\\phi=0\\) on \\(\\partial\\Omega\\)), this uses</p> \\[ u^*(x) = g(x) + \\phi(x)\\,(u(x) - g(x)), \\] <p>which guarantees \\(u^*(x)=g(x)\\) on \\(\\partial\\Omega\\).</p> <p>For scalar domains (e.g. time), an appropriate vanishing factor \\(\\phi(t)\\) is constructed from \\((t-t_0)\\), \\((t-t_1)\\), etc.</p>"},{"location":"api/constraints/enforced/#phydrax.constraints.enforce_neumann","title":"<code>phydrax.constraints.enforce_neumann(u: DomainFunction, component: DomainComponent, /, *, var: str = 'x', target: DomainFunction | ArrayLike | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Enforced Neumann ansatz enforcing \\(\\partial u/\\partial n = g\\) on a boundary.</p> <p>For a geometry boundary with signed distance field \\(\\phi\\) and outward normal \\(n\\), this constructs</p> \\[ u^* = u + \\frac{\\phi}{\\partial\\phi/\\partial n}\\,\\bigl(g - \\partial u/\\partial n\\bigr), \\] <p>which yields \\(\\partial u^*/\\partial n = g\\) on \\(\\partial\\Omega\\) under mild regularity assumptions.</p>"},{"location":"api/constraints/enforced/#phydrax.constraints.enforce_robin","title":"<code>phydrax.constraints.enforce_robin(u: DomainFunction, component: DomainComponent, /, *, var: str = 'x', dirichlet_coeff: DomainFunction | ArrayLike | None = None, neumann_coeff: DomainFunction | ArrayLike | None = None, target: DomainFunction | ArrayLike | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Enforced Robin ansatz enforcing \\(a\\,u + b\\,\\partial u/\\partial n = g\\).</p> <p>On a geometry boundary, this constructs a corrected field that satisfies the Robin condition exactly by using a signed distance factor \\(\\phi\\) and normal derivative of \\(\\phi\\).</p> <p>Let \\(r = g - a\\,u - b\\,\\partial u/\\partial n\\) be the residual. With signed distance field \\(\\phi\\) and outward normal \\(n\\), define \\(d\\phi/dn = \\partial\\phi/\\partial n\\). The returned ansatz is</p> \\[ u^* \\;=\\; u + \\frac{\\phi}{b\\,(\\partial\\phi/\\partial n)}\\,r, \\] <p>which yields \\(a\\,u^* + b\\,\\partial u^*/\\partial n = g\\) on \\(\\partial\\Omega\\) under mild regularity assumptions.</p>"},{"location":"api/constraints/enforced/#phydrax.constraints.enforce_sommerfeld","title":"<code>phydrax.constraints.enforce_sommerfeld(u: DomainFunction, component: DomainComponent, /, *, var: str = 'x', time_var: str = 't', wavespeed: DomainFunction | ArrayLike | None = None, target: DomainFunction | ArrayLike | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Enforced Sommerfeld/absorbing boundary ansatz.</p> <p>Enforces the first-order radiation condition</p> \\[ \\frac{\\partial u}{\\partial n} + \\frac{1}{c}\\frac{\\partial u}{\\partial t} = g \\] <p>on the selected boundary component by correcting \\(u\\) using a signed-distance factor.</p> <p>With signed distance field \\(\\phi\\) and \\(d\\phi/dn = \\partial\\phi/\\partial n\\), let</p> \\[ r = g - \\frac{\\partial u}{\\partial n} - \\frac{1}{c}\\frac{\\partial u}{\\partial t}. \\] <p>The returned ansatz is</p> \\[ u^* \\;=\\; u + \\frac{\\phi}{\\partial\\phi/\\partial n}\\,r, \\] <p>which yields the Sommerfeld condition on \\(\\partial\\Omega\\) under the same assumptions as <code>enforce_neumann</code>.</p>"},{"location":"api/constraints/enforced/#phydrax.constraints.enforce_traction","title":"<code>phydrax.constraints.enforce_traction(u: DomainFunction, component: DomainComponent, /, *, var: str = 'x', target: DomainFunction | ArrayLike | None = None, lambda_: DomainFunction | ArrayLike, mu: DomainFunction | ArrayLike, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Enforced traction ansatz for linear elasticity on a boundary.</p> <p>For isotropic linear elasticity, the traction is \\(t=\\sigma(u)\\,n\\). This constructs a corrected displacement \\(u^*\\) that aims to satisfy</p> \\[ \\sigma(u^*)\\,n = t_{\\text{target}} \\] <p>on the boundary by adding a displacement correction proportional to the signed distance \\(\\phi\\).</p> <p>Let</p> \\[ r \\;=\\; t_{\\text{target}} - \\sigma(u)\\,n \\] <p>be the traction residual, and decompose it into normal/tangential parts</p> \\[ r_n = (r\\cdot n)\\,n,\\qquad r_t = r - r_n. \\] <p>Using Lam\u00e9 parameters \\(\\lambda,\\mu\\), define the correction field</p> \\[ v \\;=\\; \\frac{r_t}{\\mu} \\;+\\; \\frac{r_n}{\\lambda + 2\\mu}, \\] <p>and return the hard-constraint ansatz</p> \\[ u^*(x) \\;=\\; u(x) + \\phi(x)\\,v(x). \\] <p>In the idealized setting where \\(\\phi\\) is a signed distance field near the boundary (so \\(\\partial\\phi/\\partial n \\approx 1\\)) and \\(v\\) varies slowly in the normal direction, the induced traction correction is approximately \\(\\sigma(\\phi v)\\,n \\approx \\mu\\,v_t + (\\lambda+2\\mu)\\,v_n\\) (with \\(v_n=(v\\cdot n)\\,n\\) and \\(v_t=v-v_n\\)), making \\(u^*\\) enforce the target traction to first order.</p>"},{"location":"api/constraints/enforced/#phydrax.constraints.enforce_initial","title":"<code>phydrax.constraints.enforce_initial(u: DomainFunction, component: DomainComponent, /, *, var: str = 't', targets: Mapping[int, DomainFunction | ArrayLike]) -&gt; DomainFunction</code>","text":"<p>Enforced initial-condition ansatz matching time derivatives at a fixed time.</p> <p>Let \\(t_0\\) be the fixed time selected by <code>component</code> (e.g. <code>FixedStart()</code>). Given targets for derivatives \\(u^{(k)}(t_0)\\) for \\(k=0,\\dots,m\\), this constructs a Taylor-like polynomial</p> \\[ p(t) = \\sum_{k=0}^{m} \\frac{u^{(k)}(t_0)}{k!}\\,(t-t_0)^k \\] <p>and returns</p> \\[ u^*(t) = p(t) + (t-t_0)^{m+1}\\,(u(t)-p(t)), \\] <p>which matches all specified derivatives exactly at \\(t=t_0\\).</p>"},{"location":"api/constraints/enforced/#phydrax.constraints.enforce_blend","title":"<code>phydrax.constraints.enforce_blend(u: DomainFunction, pieces: Sequence[tuple[DomainComponent, DomainFunction]], /, *, var: str = 'x', include_identity_remainder: bool = True, num_reference: int = 3000000, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; DomainFunction</code>","text":"<p>Blend multiple enforced ansatz pieces via ported MLS/BVH weights.</p> <p>Each piece contributes \\(w_i\\,u_i^*\\) and the final output is:</p> \\[ u_{\\text{enforced}} = \\frac{\\sum_i w_i\\,u_i^*}{\\sum_i w_i}. \\] <p>If <code>include_identity_remainder=True</code>, this also adds an identity term for the complement of the union of piece predicates (using <code>component.where[var]</code>), which prevents subset enforced constraints from leaking onto other boundary segments.</p>"},{"location":"api/constraints/solid/","title":"Solid mechanics constraints","text":""},{"location":"api/constraints/solid/#boundary-conditions","title":"Boundary conditions","text":""},{"location":"api/constraints/solid/#phydrax.constraints.ContinuousTractionBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousTractionBoundaryConstraint(displacement_var: str, component: DomainComponent, /, *, lambda_: DomainFunction | ArrayLike, mu: DomainFunction | ArrayLike, traction: DomainFunction | ArrayLike | None = None, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Prescribed traction (Neumann) boundary condition.</p> <p>Enforces \\(\\sigma(u)\\,n = t\\) on the boundary component, where \\(n\\) is the outward normal and \\(t\\) is the prescribed traction (default \\(0\\)).</p> <p>Arguments:</p> <ul> <li><code>displacement_var</code>: Name of the displacement field.</li> <li><code>component</code>: Boundary component.</li> <li><code>lambda_</code>, <code>mu</code>: Lam\u00e9 parameters.</li> <li><code>traction</code>: Target traction \\(t\\) (defaults to 0).</li> <li><code>var</code>: Geometry variable used to compute normals.</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>num_points</code>: Number of boundary samples.</li> <li><code>structure</code>: Sampling structure over labels.</li> <li><code>sampler</code>: Sampling method.</li> <li><code>weight</code>: Scalar weight.</li> <li><code>label</code>: Optional label for logging.</li> <li><code>over</code>: Optional reduction axes.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>FunctionalConstraint</code> enforcing the traction condition.</li> </ul>"},{"location":"api/constraints/solid/#phydrax.constraints.ContinuousNormalDisplacementBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousNormalDisplacementBoundaryConstraint(displacement_var: str, component: DomainComponent, /, *, normal_displacement: DomainFunction | ArrayLike | None = None, var: str = 'x', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Prescribed normal displacement boundary condition.</p> <p>Enforces \\(u\\cdot n = u_n\\) on the boundary component (default \\(u_n=0\\)).</p>"},{"location":"api/constraints/solid/#phydrax.constraints.ContinuousElasticFoundationBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousElasticFoundationBoundaryConstraint(displacement_var: str, component: DomainComponent, /, *, lambda_: DomainFunction | ArrayLike, mu: DomainFunction | ArrayLike, stiffness: DomainFunction | ArrayLike, foundation_displacement: DomainFunction | ArrayLike | None = None, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Elastic foundation boundary condition.</p> <p>Enforces a spring-like relation between traction and displacement:</p> \\[ \\sigma(u)\\,n + k\\,(u-u_0) = 0, \\] <p>where <code>stiffness</code> is the foundation stiffness \\(k\\) and <code>foundation_displacement</code> is \\(u_0\\) (default \\(0\\)).</p>"},{"location":"api/constraints/solid/#phydrax.constraints.ContinuousElasticSymmetryBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousElasticSymmetryBoundaryConstraint(displacement_var: str, component: DomainComponent, /, *, lambda_: DomainFunction | ArrayLike, mu: DomainFunction | ArrayLike, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Elastic symmetry boundary condition.</p> <p>Enforces symmetry by combining: - zero normal displacement: \\(u\\cdot n = 0\\), - zero tangential traction: \\((I-n\\otimes n)\\,\\sigma(u)\\,n = 0\\).</p>"},{"location":"api/constraints/solid/#phydrax.constraints.DiscreteDisplacementBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteDisplacementBoundaryConstraint(displacement_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, displacement_values: ArrayLike, weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete displacement (Dirichlet) constraint at explicit anchor points.</p>"},{"location":"api/constraints/solid/#phydrax.constraints.DiscreteTractionBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteTractionBoundaryConstraint(displacement_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, lambda_: DomainFunction | ArrayLike, mu: DomainFunction | ArrayLike, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete traction (Neumann) constraint at explicit anchor points.</p>"},{"location":"api/constraints/solid/#phydrax.constraints.DiscreteNormalDisplacementBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteNormalDisplacementBoundaryConstraint(displacement_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, var: str = 'x', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete normal displacement constraint at explicit anchor points.</p>"},{"location":"api/constraints/solid/#integral-global-constraints","title":"Integral / global constraints","text":""},{"location":"api/constraints/solid/#phydrax.constraints.SolidTotalReactionBoundaryConstraint","title":"<code>phydrax.constraints.SolidTotalReactionBoundaryConstraint(displacement_var: str, domain, /, *, lambda_: ArrayLike, mu: ArrayLike, target_reaction: ArrayLike, var: str = 'x', num_points: NumPoints | tuple[Any, ...], structure: ProductStructure | None = None, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, where: Mapping[str, Callable] | None = None, where_all: DomainFunction | None = None) -&gt; IntegralEqualityConstraint</code>","text":"<p>Boundary integral constraint for total reaction force.</p> <p>For Cauchy stress \\(\\sigma(u)\\) and outward normal \\(n\\), the traction is \\(t=\\sigma n\\). This enforces a net reaction force condition</p> \\[ \\int_{\\partial\\Omega} \\sigma(u)\\,n\\,dS = F_{\\text{target}}. \\]"},{"location":"api/constraints/thermal/","title":"Thermal constraints","text":""},{"location":"api/constraints/thermal/#boundary-conditions","title":"Boundary conditions","text":""},{"location":"api/constraints/thermal/#phydrax.constraints.ContinuousHeatFluxBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousHeatFluxBoundaryConstraint(temperature_var: str, component: DomainComponent, /, *, k: DomainFunction | ArrayLike, flux: DomainFunction | ArrayLike | None = None, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Prescribed heat-flux (Neumann) boundary condition.</p> <p>Enforces \\(k\\\\,\\\\partial T/\\\\partial n = q\\) on the boundary component, where \\(q\\) is the heat flux (default \\(0\\)).</p> <p>Arguments:</p> <ul> <li><code>temperature_var</code>: Name of the temperature field.</li> <li><code>component</code>: Boundary component.</li> <li><code>k</code>: Thermal conductivity.</li> <li><code>flux</code>: Target flux \\(q\\) (defaults to 0).</li> <li><code>var</code>: Geometry variable used to compute normals.</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>num_points</code>: Number of boundary samples.</li> <li><code>structure</code>: Sampling structure over labels.</li> <li><code>sampler</code>: Sampling method.</li> <li><code>weight</code>: Scalar weight.</li> <li><code>label</code>: Optional label for logging.</li> <li><code>over</code>: Optional reduction axes.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>FunctionalConstraint</code> enforcing the heat-flux condition.</li> </ul>"},{"location":"api/constraints/thermal/#phydrax.constraints.ContinuousConvectionBoundaryConstraint","title":"<code>phydrax.constraints.ContinuousConvectionBoundaryConstraint(temperature_var: str, component: DomainComponent, /, *, h: DomainFunction | ArrayLike, k: DomainFunction | ArrayLike, ambient_temp: DomainFunction | ArrayLike | None = None, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', num_points: int | tuple[Any, ...], structure: Any, sampler: str = 'latin_hypercube', weight: ArrayLike = 1.0, label: str | None = None, over: str | tuple[str, ...] | None = None, reduction: Literal[mean, integral] = 'mean') -&gt; FunctionalConstraint</code>","text":"<p>Convection (Robin) boundary condition.</p> <p>Enforces \\(k\\\\,\\\\partial T/\\\\partial n = h\\\\,(T - T_\\\\infty)\\) on the boundary component, where \\(T_\\\\infty\\) is the ambient temperature (default \\(0\\)).</p> <p>Arguments:</p> <ul> <li><code>temperature_var</code>: Name of the temperature field.</li> <li><code>component</code>: Boundary component.</li> <li><code>h</code>: Convection coefficient.</li> <li><code>k</code>: Thermal conductivity.</li> <li><code>ambient_temp</code>: Ambient temperature \\(T_\\\\infty\\) (defaults to 0).</li> <li><code>var</code>: Geometry variable used to compute normals.</li> <li><code>mode</code>: Differentiation mode (<code>\"reverse\"</code> or <code>\"forward\"</code>).</li> <li><code>num_points</code>: Number of boundary samples.</li> <li><code>structure</code>: Sampling structure over labels.</li> <li><code>sampler</code>: Sampling method.</li> <li><code>weight</code>: Scalar weight.</li> <li><code>label</code>: Optional label for logging.</li> <li><code>over</code>: Optional reduction axes.</li> <li><code>reduction</code>: <code>\"mean\"</code> or <code>\"integral\"</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>FunctionalConstraint</code> enforcing the convection condition.</li> </ul>"},{"location":"api/constraints/thermal/#phydrax.constraints.DiscreteHeatFluxBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteHeatFluxBoundaryConstraint(temperature_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, k: DomainFunction | ArrayLike, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete heat-flux (Neumann-type) constraint at explicit anchor points.</p> <p>Enforces \\(k\\,\\partial T/\\partial n = q\\) at the provided points.</p>"},{"location":"api/constraints/thermal/#phydrax.constraints.DiscreteConvectionBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteConvectionBoundaryConstraint(temperature_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, ambient_values: ArrayLike, h: DomainFunction | ArrayLike, k: DomainFunction | ArrayLike, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete convection (Robin) constraint at explicit anchor points.</p> <p>Enforces \\(k\\,\\partial T/\\partial n = h\\,(T - T_\\infty)\\) at the provided points, where \\(T_\\infty\\) is given by <code>ambient_values</code> (interpolated when needed).</p>"},{"location":"api/constraints/thermal/#phydrax.constraints.DiscreteRobinBoundaryConstraint","title":"<code>phydrax.constraints.DiscreteRobinBoundaryConstraint(constraint_var: str, component: DomainComponent, /, *, points: Mapping[str, ArrayLike] | ArrayLike, values: ArrayLike, dirichlet_coeff: DomainFunction | ArrayLike, neumann_coeff: DomainFunction | ArrayLike, var: str = 'x', mode: Literal[reverse, forward] = 'reverse', weight: ArrayLike = 1.0, label: str | None = None, reduction: Literal[mean, sum] = 'mean') -&gt; PointSetConstraint</code>","text":"<p>Discrete Robin constraint evaluated at explicit boundary anchor points.</p> <p>Enforces \\(c_0 T + c_1\\,\\partial T/\\partial n = g\\) at the provided points.</p>"},{"location":"api/domain/","title":"Domains","text":"<p>Domains describe the geometry and coordinate systems for PDE problems. They are used to sample points, build product structures, and define functions with explicit coordinate labels.</p> <p>For a guide to components and sampling modes (paired vs coord-separable), see Guides \u2192 Domains and sampling.</p>"},{"location":"api/domain/components/","title":"Components","text":"<p>Components select which subset of a domain is being sampled (interior, boundary, fixed-time slices, etc.) and wrap these into <code>DomainComponent</code> objects.</p>"},{"location":"api/domain/components/#component-markers","title":"Component markers","text":""},{"location":"api/domain/components/#phydrax.domain.Interior","title":"<code>phydrax.domain.Interior</code>","text":"<p>Marker selecting the interior of a domain factor.</p> <p>For a geometry factor \\(\\Omega\\subset\\mathbb{R}^d\\), this corresponds to sampling from \\(\\Omega\\) (volume/area/length measure). For a scalar factor like a time interval \\([t_0,t_1]\\), this corresponds to sampling from the interval interior.</p>"},{"location":"api/domain/components/#phydrax.domain.Interior.__init__","title":"<code>__init__()</code>","text":"<p>Create an interior component marker.</p>"},{"location":"api/domain/components/#phydrax.domain.Boundary","title":"<code>phydrax.domain.Boundary</code>","text":"<p>Marker selecting the boundary of a domain factor.</p> <p>For a geometry factor \\(\\Omega\\subset\\mathbb{R}^d\\), this corresponds to sampling from \\(\\partial\\Omega\\) (surface measure). For scalar factors (e.g. time intervals), the \"boundary\" is the discrete set of endpoints (counting measure).</p>"},{"location":"api/domain/components/#phydrax.domain.Boundary.__init__","title":"<code>__init__()</code>","text":"<p>Create a boundary component marker.</p>"},{"location":"api/domain/components/#phydrax.domain.Fixed","title":"<code>phydrax.domain.Fixed</code>","text":"<p>Fix a scalar coordinate to a specific value.</p> <p>Interpreted as a Dirac measure of unit mass at the fixed value. This is supported for scalar domains (like <code>TimeInterval</code>) and is used for slices such as \\(t=t_0\\).</p> <p>Note: Fixing geometry coordinates is not supported by the sampler; use a <code>where</code> mask or construct a lower-dimensional geometry instead.</p>"},{"location":"api/domain/components/#phydrax.domain.Fixed.__init__","title":"<code>__init__(value: ArrayLike)</code>","text":"<p>Create a fixed scalar component at the given value.</p>"},{"location":"api/domain/components/#phydrax.domain.FixedStart","title":"<code>phydrax.domain.FixedStart</code>","text":"<p>Fix a scalar domain to its start endpoint (e.g. \\(t=t_0\\)).</p>"},{"location":"api/domain/components/#phydrax.domain.FixedStart.__init__","title":"<code>__init__()</code>","text":"<p>Create a fixed-start component marker.</p>"},{"location":"api/domain/components/#phydrax.domain.FixedEnd","title":"<code>phydrax.domain.FixedEnd</code>","text":"<p>Fix a scalar domain to its end endpoint (e.g. \\(t=t_1\\)).</p>"},{"location":"api/domain/components/#phydrax.domain.FixedEnd.__init__","title":"<code>__init__()</code>","text":"<p>Create a fixed-end component marker.</p>"},{"location":"api/domain/components/#phydrax.domain.ComponentSpec","title":"<code>phydrax.domain.ComponentSpec</code>","text":"<p>Mapping from domain labels to component selectors.</p> <p>A <code>ComponentSpec</code> assigns each label \\(\\ell\\) in a domain to one of:</p> <ul> <li><code>Interior()</code> : use the interior \\(\\Omega_\\ell\\);</li> <li><code>Boundary()</code> : use the boundary \\(\\partial\\Omega_\\ell\\) (or endpoints for scalars);</li> <li><code>FixedStart()</code> / <code>FixedEnd()</code> : fix a scalar domain to its endpoints;</li> <li><code>Fixed(value)</code> : fix a scalar domain to an arbitrary value.</li> </ul> <p>Any label not explicitly specified defaults to <code>Interior()</code>.</p>"},{"location":"api/domain/components/#phydrax.domain.ComponentSpec.__init__","title":"<code>__init__(by_label: collections.abc.Mapping[str, phydrax.domain._components._AbstractVarComponent] | None = None)</code>","text":"<p>Create a component specification from a <code>{label: component}</code> mapping.</p>"},{"location":"api/domain/components/#phydrax.domain.ComponentSpec.component_for","title":"<code>component_for(label: str) -&gt; _AbstractVarComponent</code>","text":"<p>Return the component selector for <code>label</code> (defaults to <code>Interior()</code>).</p>"},{"location":"api/domain/components/#domain-components","title":"Domain components","text":""},{"location":"api/domain/components/#phydrax.domain.DomainComponent","title":"<code>phydrax.domain.DomainComponent</code>","text":"<p>A domain equipped with component selection, filters, and weights.</p> <p>A <code>DomainComponent</code> represents a product component of a labeled domain. Given a labeled domain \\(\\Omega = \\prod_{\\ell\\in\\mathcal{L}} \\Omega_\\ell\\), and a <code>ComponentSpec</code> selecting a subset/type for each label, the component corresponds to a set (schematically)</p> \\[ \\Omega_{\\text{comp}} = \\prod_{\\ell\\in\\mathcal{L}} \\Omega_\\ell^{(\\text{spec})}, \\] <p>together with its associated product measure. For example:</p> <ul> <li>geometry interior \\(\\Omega_\\ell\\) uses volume/area/length measure;</li> <li>geometry boundary \\(\\partial\\Omega_\\ell\\) uses surface measure;</li> <li>scalar interior uses Lebesgue measure on \\([a,b]\\);</li> <li>scalar boundary uses counting measure on \\(\\{a,b\\}\\) (total mass \\(2\\));</li> <li>fixed scalar slices use a unit-mass Dirac measure.</li> </ul> <p>Additional selection and weighting can be applied via: - <code>where</code>: per-label indicator functions; - <code>where_all</code>: a global indicator <code>DomainFunction</code>; - <code>weight_all</code>: a global weight <code>DomainFunction</code>.</p> <p>These are incorporated downstream in integral/mean estimators and constraint losses.</p>"},{"location":"api/domain/components/#phydrax.domain.DomainComponent.__init__","title":"<code>__init__(*, domain: _AbstractDomain, spec: phydrax.domain._components.ComponentSpec | None = None, where: collections.abc.Mapping[str, collections.abc.Callable] | None = None, where_all: phydrax.domain._function.DomainFunction | None = None, weight_all: phydrax.domain._function.DomainFunction | None = None)</code>","text":""},{"location":"api/domain/components/#phydrax.domain.DomainComponent.measure","title":"<code>measure() -&gt; Array</code>","text":"<p>Return the total measure of this component.</p> <p>This computes the product of the per-label component measures, e.g.</p> \\[ \\mu(\\Omega_{\\text{comp}})=\\prod_{\\ell\\in\\mathcal{L}} \\mu_\\ell\\left(\\Omega_\\ell^{(\\text{spec})}\\right). \\] <p>For scalar boundaries \\(\\{a,b\\}\\) this uses counting measure (mass \\(2\\)), and for fixed slices uses unit mass.</p>"},{"location":"api/domain/components/#phydrax.domain.DomainComponent.sample","title":"<code>sample(num_points: int | tuple[int, ...], *, structure: ProductStructure, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; PointsBatch</code>","text":""},{"location":"api/domain/components/#phydrax.domain.DomainComponent.sample_coord_separable","title":"<code>sample_coord_separable(coord_separable: collections.abc.Mapping[str, int | collections.abc.Sequence[int] | phydrax.domain._grid.AbstractAxisSpec | collections.abc.Sequence[phydrax.domain._grid.AbstractAxisSpec] | phydrax.domain._grid.GridSpec], /, *, num_points: int | tuple[int, ...] = (), dense_structure: phydrax.domain._structure.ProductStructure | None = None, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; CoordSeparableBatch</code>","text":"<p>Sample a coordinate-separable batch.</p> <p>For selected geometry labels, this samples each coordinate axis independently, producing coordinate arrays (and an associated boolean mask) suitable for grid-like evaluation. Any remaining (non-fixed, non-separable) labels are sampled using <code>dense_structure</code>.</p> <p><code>coord_separable</code> values may be: - counts (<code>int</code> or <code>Sequence[int]</code>), using the configured random <code>sampler</code>; - axis specs (<code>AbstractAxisSpec</code>, <code>Sequence[AbstractAxisSpec]</code>, or <code>GridSpec</code>),   producing deterministic grid nodes and attaching per-axis discretization   metadata for quadrature/operators.</p> <p>This is useful when an operator factorizes across coordinate axes, or when a Cartesian grid is desired for quadrature-like reductions.</p>"},{"location":"api/domain/components/#phydrax.domain.DomainComponent.normals","title":"<code>normals(points: phydrax.domain._structure.PointsBatch | phydrax._frozendict.frozendict[str, PyTree[coordax.Field]], /, *, var: str) -&gt; Field</code>","text":"<p>Compute outward unit normals on a geometry boundary.</p> <p>For a geometry label <code>var</code> with boundary component, this returns the unit normal field \\(n(x)\\) on \\(\\partial\\Omega\\).</p> <p>The returned <code>coordax.Field</code> has the same named axes as the provided boundary points.</p>"},{"location":"api/domain/components/#phydrax.domain.DomainComponent.normal","title":"<code>normal(*, var: str) -&gt; DomainFunction</code>","text":"<p>Return a <code>DomainFunction</code> representing the outward unit normal \\(n(x)\\).</p> <p>This is a convenience wrapper that returns a <code>DomainFunction</code> with <code>deps=(var,)</code>. For geometry labels, it is typically used in Neumann-type conditions involving \\(\\partial u/\\partial n\\).</p>"},{"location":"api/domain/components/#phydrax.domain.DomainComponent.sdf","title":"<code>sdf(*, var: str) -&gt; DomainFunction</code>","text":"<p>Return a <code>DomainFunction</code> for the signed distance field \\(\\phi(x)\\).</p> <p>The sign convention is geometry-dependent but typically:</p> <ul> <li>\\(\\phi(x) &lt; 0\\) inside \\(\\Omega\\),</li> <li>\\(\\phi(x) = 0\\) on \\(\\partial\\Omega\\),</li> <li>\\(\\phi(x) &gt; 0\\) outside \\(\\Omega\\).</li> </ul>"},{"location":"api/domain/components/#phydrax.domain.DomainComponentUnion","title":"<code>phydrax.domain.DomainComponentUnion</code>","text":"<p>A finite union of <code>DomainComponent</code> terms.</p> <p>This is used to represent components that are naturally unions, e.g. for a time interval \\([t_0,t_1]\\) the boundary is \\(\\{t=t_0\\}\\cup\\{t=t_1\\}\\).</p> <p>The total measure is the sum of term measures, and sampling allocates points across terms.</p>"},{"location":"api/domain/components/#phydrax.domain.DomainComponentUnion.__init__","title":"<code>__init__(terms: tuple[phydrax.domain._components.DomainComponent, ...])</code>","text":"<p>Create a union from non-empty <code>terms</code>.</p>"},{"location":"api/domain/components/#phydrax.domain.DomainComponentUnion.measure","title":"<code>measure() -&gt; Array</code>","text":"<p>Return the total measure \\(\\mu(\\cup_i \\Omega_i)=\\sum_i \\mu(\\Omega_i)\\).</p>"},{"location":"api/domain/components/#phydrax.domain.DomainComponentUnion.sample","title":"<code>sample(num_points: int | tuple[typing.Any, ...], *, structure: ProductStructure, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0), min_points_per_term: int = 1) -&gt; tuple[phydrax.domain._structure.PointsBatch, ...]</code>","text":"<p>Sample each union term and return a tuple of <code>PointsBatch</code> values.</p>"},{"location":"api/domain/composition/","title":"Composition","text":"<p>Domains can be combined into product domains (e.g. space-time) and then used to define domain-aware functions and constraints.</p>"},{"location":"api/domain/composition/#dataset-factors-omega_textdata","title":"Dataset factors (\\(\\Omega_{\\text{data}}\\))","text":"<p>Many operator-learning workflows decompose the domain as a product</p> \\[ \\Omega = \\Omega_{\\text{data}} \\times \\Omega_x \\times \\Omega_t \\times \\cdots, \\] <p>where \\(\\Omega_{\\text{data}}\\) indexes a finite dataset of input functions/fields (e.g. forcing terms, initial conditions, material parameters) and the remaining factors are geometric/scalar coordinates.</p> <p><code>DatasetDomain</code> is a unary domain that stores an in-memory dataset (a PyTree of arrays with a shared leading dataset axis) and samples by random indexing. This integrates cleanly with:</p> <ul> <li><code>ProductDomain</code> composition via <code>@</code>,</li> <li>structured sampling (<code>dense_structure=ProductStructure(((\"data\",),))</code>),</li> <li><code>Domain.Model(...)</code> for building operator-learning models that take <code>(data, coords...)</code>.</li> </ul>"},{"location":"api/domain/composition/#measure-semantics","title":"Measure semantics","text":"<p><code>DatasetDomain(..., measure=...)</code> controls the measure used by integral/mean reductions:</p> <ul> <li><code>measure=\"probability\"</code>: \\(\\mu(\\Omega_{\\text{data}})=1\\) (treat as an expectation),</li> <li><code>measure=\"count\"</code>: \\(\\mu(\\Omega_{\\text{data}})=N\\) where \\(N\\) is dataset size   (treat as a finite-sum domain).</li> </ul> <p>Example</p> <pre><code>import jax.numpy as jnp\nimport phydrax as phx\n\ndata = jnp.ones((128, 64))     # N=128 samples, each with 64 features\nOmega = phx.domain.DatasetDomain(data, label=\"data\") @ phx.domain.Interval1d(0.0, 1.0)\n</code></pre>"},{"location":"api/domain/composition/#phydrax.domain.ProductDomain","title":"<code>phydrax.domain.ProductDomain</code>","text":"<p>A labeled Cartesian product of unary domains.</p> <p>Given unary domains \\(\\Omega_1,\\dots,\\Omega_k\\) with labels \\(\\ell_1,\\dots,\\ell_k\\), a <code>ProductDomain</code> represents the product</p> \\[ \\Omega = \\Omega_{\\ell_1}\\times\\cdots\\times\\Omega_{\\ell_k}. \\] <p>Labels must be unique unless colliding factors are structurally equivalent, in which case they are de-duplicated. This allows joining domains that share the same label (e.g. two identical <code>TimeInterval</code>s) without ambiguity.</p>"},{"location":"api/domain/composition/#phydrax.domain.ProductDomain.factors","title":"<code>factors</code>  <code>property</code>","text":"<p>Return the unary factors of the product domain.</p>"},{"location":"api/domain/composition/#phydrax.domain.ProductDomain.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Return the label tuple \\((\\ell_1,\\ldots,\\ell_k)\\) for this product domain.</p>"},{"location":"api/domain/composition/#phydrax.domain.ProductDomain.__init__","title":"<code>__init__(*domains: _AbstractDomain)</code>","text":"<p>Create a product domain from unary domains (or nested product domains).</p>"},{"location":"api/domain/composition/#phydrax.domain.ProductDomain.factor","title":"<code>factor(label: str) -&gt; _AbstractUnaryDomain</code>","text":"<p>Return the unary factor corresponding to <code>label</code>.</p>"},{"location":"api/domain/composition/#phydrax.domain.ProductDomain.equivalent","title":"<code>equivalent(other: object) -&gt; bool</code>","text":"<p>Return whether <code>other</code> is structurally equivalent to this domain.</p>"},{"location":"api/domain/composition/#phydrax.domain.ProductDomain.boundary","title":"<code>boundary()</code>","text":"<p>Return the boundary as a <code>DomainComponentUnion</code>.</p> <p>This constructs a union over boundary terms for each factor:</p> <ul> <li>For geometry factors, one term with that label set to <code>Boundary()</code>.</li> <li>For scalar factors (e.g. time), two terms corresponding to <code>FixedStart()</code>   and <code>FixedEnd()</code>.</li> </ul> <p>This mirrors the common decomposition of \\(\\partial(\\Omega_x\\times[t_0,t_1])\\) into spatial boundary and initial/final time slices.</p>"},{"location":"api/domain/composition/#phydrax.domain.DatasetDomain","title":"<code>phydrax.domain.DatasetDomain</code>","text":"<p>A unary domain over a finite in-memory dataset.</p> <p>A <code>DatasetDomain</code> stores a PyTree of arrays where every leaf has a leading dataset axis of the same length <code>N</code>. Sampling draws a batch of indices uniformly and returns the corresponding slice from each leaf.</p> <p>This is intended for product domains like <code>Omega_data @ Omega_x</code>, where <code>data</code> samples are paired/broadcast with spatial points.</p>"},{"location":"api/domain/composition/#phydrax.domain.DatasetDomain.size","title":"<code>size</code>  <code>property</code>","text":""},{"location":"api/domain/composition/#phydrax.domain.DatasetDomain.measure","title":"<code>measure</code>  <code>property</code>","text":""},{"location":"api/domain/composition/#phydrax.domain.DatasetDomain.__init__","title":"<code>__init__(data: PyTree[ArrayLike], /, *, label: str = 'data', measure: Literal[probability, count] = 'probability')</code>","text":""},{"location":"api/domain/composition/#phydrax.domain.DatasetDomain.sample","title":"<code>sample(num_points: int, *, sampler: str = 'uniform', key: Key[Array, ''] = jr.key(0)) -&gt; PyTree[Array]</code>","text":""},{"location":"api/domain/functions/","title":"Functions","text":"<p><code>DomainFunction</code> wraps callables with explicit domain metadata, so that operators and constraints can compose without losing coordinate meaning.</p>"},{"location":"api/domain/functions/#phydrax.domain.DomainFunction","title":"<code>phydrax.domain.DomainFunction</code>","text":"<p>A callable with explicit domain and coordinate semantics.</p> <p>A <code>DomainFunction</code> represents a mathematical map</p> \\[ u:\\Omega \\to \\mathbb{R}^m, \\] <p>where the domain \\(\\Omega\\) is a <code>phydrax.domain</code> object carrying labeled factors (e.g. a space-time domain \\(\\Omega = \\Omega_x \\times \\Omega_t\\) with labels <code>\"x\"</code> and <code>\"t\"</code>). The tuple <code>deps</code> specifies which labels the function actually depends on.</p> <p>Phydrax operators (gradients, divergences, integrals, etc.) act on <code>DomainFunction</code> objects, and constraints evaluate them on sampled batches.</p> <p>Algebra</p> <p><code>DomainFunction</code> implements pointwise arithmetic. For example, for compatible domains,</p> \\[ (u+v)(z)=u(z)+v(z),\\qquad (uv)(z)=u(z)v(z), \\] <p>and when combining functions with different domains, the domains are joined and both functions are promoted to the joined domain.</p> <p>Notes</p> <ul> <li>If <code>func</code> is array-like, it is treated as a constant function on \\(\\Omega\\).</li> <li>If <code>func</code> is callable, Phydrax passes randomness through a keyword-only <code>key</code>   argument (when provided by downstream sampling/solvers).</li> <li>Evaluation returns a <code>coordax.Field</code> whose named axes are inferred from the   sampling structure (paired blocks and/or coord-separable axes).</li> </ul>"},{"location":"api/domain/functions/#phydrax.domain.DomainFunction.T","title":"<code>T</code>  <code>property</code>","text":"<p>Transpose the last two array axes of the output.</p> <p>If \\(u(z)\\in\\mathbb{R}^{m\\times n}\\) then \\((u^T)(z)=u(z)^T\\).</p>"},{"location":"api/domain/functions/#phydrax.domain.DomainFunction.__init__","title":"<code>__init__(*, domain: _AbstractDomain, deps: collections.abc.Sequence[str], func: collections.abc.Callable | ArrayLike | None, metadata: collections.abc.Mapping[str, typing.Any] | None = None)</code>","text":""},{"location":"api/domain/functions/#phydrax.domain.DomainFunction.depends_on","title":"<code>depends_on(var: str) -&gt; bool</code>","text":"<p>Return whether this function depends on the labeled variable <code>var</code>.</p>"},{"location":"api/domain/functions/#phydrax.domain.DomainFunction.promote","title":"<code>promote(new_domain: _AbstractDomain) -&gt; DomainFunction</code>","text":"<p>View this function as defined on a larger domain.</p> <p>If \\(\\Omega\\subseteq\\Omega'\\), then promotion constructs \\(u':\\Omega'\\to\\mathbb{R}^m\\) by ignoring the extra coordinates:</p> \\[ u'(z) = u(z|_{\\Omega}). \\] <p>In practice this means that all labels of the current domain must appear in <code>new_domain.labels</code>, and the underlying callable is reused unchanged.</p>"},{"location":"api/domain/functions/#phydrax.domain.DomainFunction.with_metadata","title":"<code>with_metadata(**metadata: typing.Any) -&gt; DomainFunction</code>","text":"<p>Return a copy with <code>metadata</code> merged into the existing metadata.</p>"},{"location":"api/domain/functions/#phydrax.domain.DomainFunction.__call__","title":"<code>__call__(points: phydrax.domain._structure.PointsBatch | phydrax.domain._structure.CoordSeparableBatch | phydrax._frozendict.frozendict[str, PyTree[coordax.Field]], *, key: Key[Array, ''] = jr.key(0), **kwargs: typing.Any) -&gt; Field</code>","text":""},{"location":"api/domain/geometry1d/","title":"Geometry (1D)","text":""},{"location":"api/domain/geometry1d/#phydrax.domain.Interval1d","title":"<code>phydrax.domain.Interval1d</code>","text":"<p>A 1D closed interval geometry.</p> <p>Represents the domain</p> \\[ \\Omega = [a,b]\\subset\\mathbb{R}, \\] <p>with boundary \\(\\partial\\Omega = \\{a,b\\}\\) and outward normal \\(n(a)=-1\\), \\(n(b)=+1\\).</p> <p>Sampling supports both: - <code>sample_interior</code>: draws points in \\([a,b]\\) (optionally filtered by a predicate); - <code>sample_boundary</code>: draws from the discrete boundary set \\(\\{a,b\\}\\).</p>"},{"location":"api/domain/geometry1d/#phydrax.domain.Interval1d.length","title":"<code>length</code>  <code>property</code>","text":"<p>Return the interval length \\(b-a\\).</p>"},{"location":"api/domain/geometry1d/#phydrax.domain.Interval1d.bounds","title":"<code>bounds</code>  <code>property</code>","text":""},{"location":"api/domain/geometry1d/#phydrax.domain.Interval1d.__init__","title":"<code>__init__(start: ArrayLike, end: ArrayLike)</code>","text":""},{"location":"api/domain/geometry1d/#phydrax.domain.Interval1d.sample_interior","title":"<code>sample_interior(num_points: int, *, where: collections.abc.Callable | None = None, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/domain/geometry1d/#phydrax.domain.Interval1d.sample_boundary","title":"<code>sample_boundary(num_points: int, *, where: collections.abc.Callable | None = None, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/domain/geometry2d/","title":"Geometry (2D)","text":""},{"location":"api/domain/geometry2d/#mesh-based-geometries","title":"Mesh-based geometries","text":""},{"location":"api/domain/geometry2d/#boolean-csg-operations","title":"Boolean / CSG operations","text":"<p><code>Geometry2DFromCAD</code> supports boolean operations via operator overloading:</p> <ul> <li><code>A + B</code>: union (\\(\\Omega = \\Omega_A \\cup \\Omega_B\\))</li> <li><code>A - B</code>: difference (\\(\\Omega = \\Omega_A \\setminus \\Omega_B\\))</li> <li><code>A &amp; B</code>: intersection (\\(\\Omega = \\Omega_A \\cap \\Omega_B\\))</li> </ul> <p>Example</p> <pre><code>import phydrax as phx\n\n# In real workflows you can load meshes from disk via Geometry2DFromCAD(\"path.stl\").\n# For a runnable example without external files, use primitives (they produce CAD-backed geometries).\nA = phx.domain.Circle(center=(0.0, 0.0), radius=1.0)\nB = phx.domain.Square(center=(0.25, 0.0), side=1.0)\n\n#     U = A + B\n#     D = A - B\n#     I = A &amp; B\n</code></pre>"},{"location":"api/domain/geometry2d/#phydrax.domain.Geometry2DFromCAD","title":"<code>phydrax.domain.Geometry2DFromCAD</code>","text":"<p>A 2D geometry represented by a triangulated surface mesh.</p> <p>This class treats a watertight triangulated mesh as defining a planar region \\(\\Omega\\subset\\mathbb{R}^2\\). Sampling routines draw:</p> <ul> <li>interior points \\(x\\in\\Omega\\) by sampling triangles proportional to their area;</li> <li>boundary points \\(x\\in\\partial\\Omega\\) by sampling edges proportional to length.</li> </ul> <p>The geometry also provides a smooth signed distance-like function \\(\\phi(x)\\) (via <code>adf</code>) that is used for containment tests and for estimating normals when needed.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Geometry2DFromCAD.__init__","title":"<code>__init__(mesh: meshio._mesh.Mesh | pathlib.Path | str, *, recenter: bool = True)</code>","text":""},{"location":"api/domain/geometry2d/#phydrax.domain.Geometry2DFromCAD.__add__","title":"<code>__add__(other: Geometry2DFromCAD) -&gt; Geometry2DFromCAD</code>","text":"<p>Union of two 2D geometries via extruded 3D CSG.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Geometry2DFromCAD.__sub__","title":"<code>__sub__(other: Geometry2DFromCAD) -&gt; Geometry2DFromCAD</code>","text":"<p>Difference (self minus other) of two 2D geometries via extruded 3D CSG.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Geometry2DFromCAD.__and__","title":"<code>__and__(other: Geometry2DFromCAD) -&gt; Geometry2DFromCAD</code>","text":"<p>Intersection of two 2D geometries via extruded 3D CSG.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Geometry2DFromCAD.sample_interior","title":"<code>sample_interior(num_points: int, *, where: collections.abc.Callable | None = None, sampler: str = 'latin_hypercube', interior_edge_fraction: float = 0.0, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Sample points from the interior of \\(\\Omega\\).</p> <p>Returns an array of shape <code>(num_points, 2)</code> containing points in \\(\\Omega\\subset\\mathbb{R}^2\\), optionally filtered by <code>where(x)</code>.</p> <p>The optional <code>interior_edge_fraction</code> can be used to bias samples towards interior edges (useful for capturing sharp features in PDE solutions).</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Geometry2DFromCAD.sample_boundary","title":"<code>sample_boundary(num_points: int, *, where: collections.abc.Callable | None = None, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Sample points from the boundary \\(\\partial\\Omega\\).</p> <p>Returns an array of shape <code>(num_points, 2)</code> containing boundary points in \\(\\partial\\Omega\\), optionally filtered by <code>where(x)</code>.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Geometry2DFromPointCloud","title":"<code>phydrax.domain.Geometry2DFromPointCloud(points: ArrayLike, *, recenter: bool = True, alpha: float | None = None, tol: float | None = None, offset: float | None = None, bound: float | str | None = None, progress_bar: bool = False) -&gt; Geometry2DFromCAD</code>","text":"<p>Reconstruct a 2D mesh geometry from a boundary point cloud.</p> <p>Interprets <code>points</code> as samples from (or near) the boundary \\(\\partial\\Omega\\) of an unknown planar region \\(\\Omega\\subset\\mathbb{R}^2\\). A triangulation is constructed in the plane and used to build a <code>Geometry2DFromCAD</code> instance.</p> <p>Arguments:</p> <ul> <li><code>points</code>: Array-like of shape <code>(N, 2)</code> (or <code>(N, &gt;=2)</code>, where only the first two   coordinates are used).</li> <li><code>recenter</code>: Whether to recenter the reconstructed mesh coordinates.</li> <li><code>alpha</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> <li><code>tol</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> <li><code>offset</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> <li><code>bound</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> <li><code>progress_bar</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> </ul>"},{"location":"api/domain/geometry2d/#primitives","title":"Primitives","text":""},{"location":"api/domain/geometry2d/#phydrax.domain.Circle","title":"<code>phydrax.domain.Circle(center: tuple[float, float], radius: float) -&gt; Geometry2DFromCAD</code>","text":"<p>A disk (filled circle) geometry.</p> <p>Defines the set</p> \\[ \\Omega = \\{x\\in\\mathbb{R}^2 : \\|x-c\\|_2 \\le r\\}, \\] <p>with center \\(c\\in\\mathbb{R}^2\\) and radius \\(r&gt;0\\).</p> <p>Arguments:</p> <ul> <li><code>center</code>: The center \\(c=(c_x,c_y)\\).</li> <li><code>radius</code>: The radius \\(r\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry2DFromCAD</code> representing the circle.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Ellipse","title":"<code>phydrax.domain.Ellipse(center: tuple[float, float], x_radius: float, y_radius: float) -&gt; Geometry2DFromCAD</code>","text":"<p>A filled ellipse geometry.</p> <p>Defines the set</p> \\[ \\Omega = \\left\\{(x,y)\\in\\mathbb{R}^2 :   \\left(\\frac{x-c_x}{r_x}\\right)^2 + \\left(\\frac{y-c_y}{r_y}\\right)^2 \\le 1 \\right\\}. \\] <p>Arguments:</p> <ul> <li><code>center</code>: The center \\(c=(c_x,c_y)\\).</li> <li><code>x_radius</code>: Semi-axis length \\(r_x&gt;0\\).</li> <li><code>y_radius</code>: Semi-axis length \\(r_y&gt;0\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry2DFromCAD</code> representing the ellipse.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Rectangle","title":"<code>phydrax.domain.Rectangle(center: tuple[float, float], width: float, height: float) -&gt; Geometry2DFromCAD</code>","text":"<p>An axis-aligned rectangle geometry.</p> <p>Defines the set</p> \\[ \\Omega = \\{(x,y)\\in\\mathbb{R}^2 :   |x-c_x|\\le \\tfrac{w}{2},\\ |y-c_y|\\le \\tfrac{h}{2}\\}. \\] <p>Arguments:</p> <ul> <li><code>center</code>: The center \\(c=(c_x,c_y)\\).</li> <li><code>width</code>: Width \\(w&gt;0\\).</li> <li><code>height</code>: Height \\(h&gt;0\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry2DFromCAD</code> representing the rectangle.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Square","title":"<code>phydrax.domain.Square(center: tuple[float, float], side: float) -&gt; Geometry2DFromCAD</code>","text":"<p>An axis-aligned square geometry.</p> <p>This is the special case of <code>Rectangle</code> with width = height = <code>side</code>.</p> <p>Arguments:</p> <ul> <li><code>center</code>: The center \\(c=(c_x,c_y)\\).</li> <li><code>side</code>: Side length \\(s&gt;0\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry2DFromCAD</code> representing the square.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Polygon","title":"<code>phydrax.domain.Polygon(vertices: collections.abc.Sequence[tuple[float, float]]) -&gt; Geometry2DFromCAD</code>","text":"<p>A polygonal planar region defined by its vertices.</p> <p>Given vertices \\((v_1,\\dots,v_n)\\) ordered around the boundary (clockwise or counter-clockwise), this constructs a planar region whose boundary is the piecewise-linear closed curve connecting consecutive vertices.</p> <p>Arguments:</p> <ul> <li><code>vertices</code>: Sequence of vertices \\(v_i\\in\\mathbb{R}^2\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry2DFromCAD</code> representing the polygon.</p>"},{"location":"api/domain/geometry2d/#phydrax.domain.Triangle","title":"<code>phydrax.domain.Triangle(vertices: collections.abc.Sequence[tuple[float, float]]) -&gt; Geometry2DFromCAD</code>","text":"<p>A triangular planar region defined by three vertices.</p> <p>Arguments:</p> <ul> <li><code>vertices</code>: The three vertices \\(v_1,v_2,v_3\\in\\mathbb{R}^2\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry2DFromCAD</code> representing the triangle.</p>"},{"location":"api/domain/geometry3d/","title":"Geometry (3D)","text":""},{"location":"api/domain/geometry3d/#mesh-based-geometries","title":"Mesh-based geometries","text":""},{"location":"api/domain/geometry3d/#boolean-csg-operations","title":"Boolean / CSG operations","text":"<p><code>Geometry3DFromCAD</code> supports boolean operations via operator overloading:</p> <ul> <li><code>A + B</code>: union (\\(\\Omega = \\Omega_A \\cup \\Omega_B\\))</li> <li><code>A - B</code>: difference (\\(\\Omega = \\Omega_A \\setminus \\Omega_B\\))</li> <li><code>A &amp; B</code>: intersection (\\(\\Omega = \\Omega_A \\cap \\Omega_B\\))</li> </ul> <p>Example</p> <pre><code>import phydrax as phx\n\n# In real workflows you can load meshes from disk via Geometry3DFromCAD(\"path.stl\").\n# For a runnable example without external files, use primitives (they produce CAD-backed geometries).\nA = phx.domain.Sphere(center=(0.0, 0.0, 0.0), radius=1.0)\nB = phx.domain.Cube(center=(0.25, 0.0, 0.0), side=1.2)\n\n#     U = A + B\n#     D = A - B\n#     I = A &amp; B\n</code></pre>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD","title":"<code>phydrax.domain.Geometry3DFromCAD</code>","text":"<p>A 3D geometry represented by a watertight surface mesh.</p> <p>This class treats a closed triangulated surface mesh as defining a solid region \\(\\Omega\\subset\\mathbb{R}^3\\). Sampling routines draw:</p> <ul> <li>boundary points \\(x\\in\\partial\\Omega\\) by sampling triangles proportional to their area;</li> <li>interior points \\(x\\in\\Omega\\) via mesh-based strategies (see <code>sample_interior</code>).</li> </ul> <p>A smooth signed distance-like function \\(\\phi(x)\\) is provided via <code>adf</code>, and is used for containment tests and for estimating boundary normals.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD.__init__","title":"<code>__init__(mesh: trimesh.base.Trimesh | meshio._mesh.Mesh | pathlib.Path | str, *, recenter: bool = False, immersed: bool = False)</code>","text":""},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD.__add__","title":"<code>__add__(other: Geometry3DFromCAD) -&gt; Geometry3DFromCAD</code>","text":"<p>Boolean union of two solids: \\(\\Omega = \\Omega_1 \\cup \\Omega_2\\).</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD.__sub__","title":"<code>__sub__(other: Geometry3DFromCAD) -&gt; Geometry3DFromCAD</code>","text":"<p>Boolean difference of two solids: \\(\\Omega = \\Omega_1 \\setminus \\Omega_2\\).</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD.__and__","title":"<code>__and__(other: Geometry3DFromCAD) -&gt; Geometry3DFromCAD</code>","text":"<p>Boolean intersection of two solids: \\(\\Omega = \\Omega_1 \\cap \\Omega_2\\).</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD.sample_interior","title":"<code>sample_interior(num_points: int, *, where: collections.abc.Callable | None = None, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Sample points from the interior of \\(\\Omega\\).</p> <p>Returns an array of shape <code>(num_points, 3)</code> containing points in \\(\\Omega\\subset\\mathbb{R}^3\\), optionally filtered by <code>where(x)</code>.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD.sample_boundary","title":"<code>sample_boundary(num_points: int, *, where: collections.abc.Callable | None = None, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Sample points from the boundary \\(\\partial\\Omega\\).</p> <p>Returns an array of shape <code>(num_points, 3)</code> containing boundary points, optionally filtered by <code>where(x)</code>.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD.translate","title":"<code>translate(offset: ArrayLike) -&gt; Geometry3DFromCAD</code>","text":"<p>Return a translated copy of the geometry.</p> <p>Applies the rigid transform \\(x \\mapsto x + b\\) with translation vector \\(b\\in\\mathbb{R}^3\\).</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromCAD.scale","title":"<code>scale(factor: ArrayLike) -&gt; Geometry3DFromCAD</code>","text":"<p>Return a uniformly scaled copy of the geometry.</p> <p>Applies the dilation \\(x \\mapsto s x\\) with scalar \\(s&gt;0\\).</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromPointCloud","title":"<code>phydrax.domain.Geometry3DFromPointCloud(points: ArrayLike, *, recenter: bool = True, nbr_sz: int | None = None, radius: float | None = None, sample_spacing: float | None = None, progress_bar: bool = False) -&gt; Geometry3DFromCAD</code>","text":"<p>Reconstruct a 3D mesh geometry from a surface point cloud.</p> <p>Interprets <code>points</code> as samples from (or near) the surface \\(\\partial\\Omega\\) of an unknown solid \\(\\Omega\\subset\\mathbb{R}^3\\). A triangulated surface is reconstructed and used to build a <code>Geometry3DFromCAD</code>.</p> <p>Arguments:</p> <ul> <li><code>points</code>: Array-like of shape <code>(N, 3)</code> (or <code>(N, &gt;=3)</code>, where only the first three   coordinates are used).</li> <li><code>recenter</code>: Whether to recenter the reconstructed mesh coordinates.</li> <li><code>nbr_sz</code>: Optional PyVista <code>reconstruct_surface</code> control (passed through when supported).</li> <li><code>radius</code>: Optional PyVista <code>reconstruct_surface</code> control (passed through when supported).</li> <li><code>sample_spacing</code>: Optional PyVista <code>reconstruct_surface</code> control (passed through when supported).</li> <li><code>progress_bar</code>: Optional PyVista <code>reconstruct_surface</code> control (passed through when supported).</li> </ul>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromDEM","title":"<code>phydrax.domain.Geometry3DFromDEM(points_or_grid: ArrayLike, *, recenter: bool = True, alpha: float | None = None, tol: float | None = None, bound: float | str | None = None, progress_bar: bool = False, extrude_depth: float = 1.0, x: ArrayLike | None = None, y: ArrayLike | None = None) -&gt; Geometry3DFromCAD</code>","text":"<p>Create a (roughly) watertight 3D geometry from a 2.5D DEM.</p> <p>The input is interpreted as a height field \\(z=z(x,y)\\) sampled on a grid or as scattered \\((x,y,z)\\) points. A triangulated surface is constructed and (when supported) extruded downward to produce a closed solid suitable for sampling.</p> <p>Arguments:</p> <ul> <li><code>points_or_grid</code>: Either a grid of shape <code>(ny, nx)</code> with heights, or an array of   points of shape <code>(N, 3)</code> (or <code>(N, &gt;=3)</code>).</li> <li><code>recenter</code>: Whether to recenter the reconstructed mesh coordinates.</li> <li><code>alpha</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> <li><code>tol</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> <li><code>bound</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> <li><code>progress_bar</code>: Optional PyVista <code>delaunay_2d</code> control (passed through when supported).</li> <li><code>extrude_depth</code>: Extrusion depth used to \"close\" the surface.</li> <li><code>x</code>: Optional coordinate vector for the height grid.</li> <li><code>y</code>: Optional coordinate vector for the height grid.</li> </ul>"},{"location":"api/domain/geometry3d/#phydrax.domain.Geometry3DFromLidarScene","title":"<code>phydrax.domain.Geometry3DFromLidarScene(points: ArrayLike, *, recenter: bool = True, roi: tuple[float, float, float, float, float, float] | None = None, voxel_size: float | None = None, nbr_sz: int | None = None, radius: float | None = None, sample_spacing: float | None = None, progress_bar: bool = False, close_depth: float = 0.5) -&gt; Geometry3DFromCAD</code>","text":"<p>Construct a mesh geometry from LiDAR scene points.</p> <p>This helper optionally:</p> <ul> <li>crops the point cloud to a region of interest (ROI),</li> <li>voxel-downsamples the points,</li> <li>reconstructs a surface \\(\\partial\\Omega\\),</li> <li>extrudes it to obtain a closed solid.</li> </ul> <p>Arguments:</p> <ul> <li><code>points</code>: Array-like of shape <code>(N, 3)</code> (or <code>(N, &gt;=3)</code>).</li> <li><code>recenter</code>: Whether to recenter the reconstructed mesh coordinates.</li> <li><code>roi</code>: Optional axis-aligned ROI <code>(xmin, xmax, ymin, ymax, zmin, zmax)</code>.</li> <li><code>voxel_size</code>: Optional voxel downsampling size.</li> <li><code>nbr_sz</code>: Optional PyVista <code>reconstruct_surface</code> control (passed through when supported).</li> <li><code>radius</code>: Optional PyVista <code>reconstruct_surface</code> control (passed through when supported).</li> <li><code>sample_spacing</code>: Optional PyVista <code>reconstruct_surface</code> control (passed through when supported).</li> <li><code>progress_bar</code>: Optional PyVista <code>reconstruct_surface</code> control (passed through when supported).</li> <li><code>close_depth</code>: Extrusion depth used to close the reconstructed surface.</li> </ul>"},{"location":"api/domain/geometry3d/#primitives","title":"Primitives","text":""},{"location":"api/domain/geometry3d/#phydrax.domain.Sphere","title":"<code>phydrax.domain.Sphere(center: tuple[float, float, float], radius: float) -&gt; Geometry3DFromCAD</code>","text":"<p>A solid sphere geometry.</p> <p>Defines</p> \\[ \\Omega = \\{x\\in\\mathbb{R}^3:\\|x-c\\|_2 \\le r\\}. \\] <p>Arguments:</p> <ul> <li><code>center</code>: The center \\(c\\in\\mathbb{R}^3\\).</li> <li><code>radius</code>: The radius \\(r&gt;0\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry3DFromCAD</code> representing the sphere.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Ellipsoid","title":"<code>phydrax.domain.Ellipsoid(center: tuple[float, float, float], radii: tuple[float, float, float]) -&gt; Geometry3DFromCAD</code>","text":"<p>A solid ellipsoid geometry.</p> <p>Defines</p> \\[ \\Omega = \\left\\{x\\in\\mathbb{R}^3:   \\left(\\frac{x_1-c_1}{r_1}\\right)^2+   \\left(\\frac{x_2-c_2}{r_2}\\right)^2+   \\left(\\frac{x_3-c_3}{r_3}\\right)^2 \\le 1 \\right\\}. \\] <p>Arguments:</p> <ul> <li><code>center</code>: The center \\(c\\in\\mathbb{R}^3\\).</li> <li><code>radii</code>: Semi-axis lengths \\((r_1,r_2,r_3)\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry3DFromCAD</code> representing the ellipsoid.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Cuboid","title":"<code>phydrax.domain.Cuboid(center: tuple[float, float, float], dimensions: tuple[float, float, float]) -&gt; Geometry3DFromCAD</code>","text":"<p>An axis-aligned box (cuboid) geometry.</p> <p>Defines</p> \\[ \\Omega = \\{x\\in\\mathbb{R}^3:   |x_1-c_1|\\le \\tfrac{d_x}{2},\\   |x_2-c_2|\\le \\tfrac{d_y}{2},\\   |x_3-c_3|\\le \\tfrac{d_z}{2}\\}. \\] <p>Arguments:</p> <ul> <li><code>center</code>: The center \\(c\\in\\mathbb{R}^3\\).</li> <li><code>dimensions</code>: Side lengths \\((d_x,d_y,d_z)\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry3DFromCAD</code> representing the cuboid.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Cube","title":"<code>phydrax.domain.Cube(center: tuple[float, float, float], side: float) -&gt; Geometry3DFromCAD</code>","text":"<p>An axis-aligned cube geometry.</p> <p>This is the special case of <code>Cuboid</code> with all side lengths equal to <code>side</code>.</p> <p>Arguments:</p> <ul> <li><code>center</code>: The center \\(c\\in\\mathbb{R}^3\\).</li> <li><code>side</code>: Side length \\(s&gt;0\\).</li> </ul> <p>Returns:</p> <p>A <code>Geometry3DFromCAD</code> representing the cube.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Cylinder","title":"<code>phydrax.domain.Cylinder(face_center: collections.abc.Sequence | ArrayLike, axis: collections.abc.Sequence | ArrayLike, radius: float, angle: float = 6.283185307179586) -&gt; Geometry3DFromCAD</code>","text":"<p>A solid cylinder geometry.</p> <p>Constructs a cylinder by extruding a disk of radius \\(r\\) along an axis vector \\(a\\in\\mathbb{R}^3\\) of length \\(h=\\|a\\|_2\\) starting from <code>face_center</code>.</p> <p>Arguments:</p> <ul> <li><code>face_center</code>: Center of the starting face.</li> <li><code>axis</code>: Extrusion vector \\(a\\) (its direction sets the cylinder axis).</li> <li><code>radius</code>: Radius \\(r&gt;0\\).</li> <li><code>angle</code>: Angular opening in radians (currently full cylinders are the common use).</li> </ul> <p>Returns:</p> <p>A <code>Geometry3DFromCAD</code> representing the cylinder.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Cone","title":"<code>phydrax.domain.Cone(base_center: collections.abc.Sequence | ArrayLike, axis: collections.abc.Sequence | ArrayLike, radius0: float, radius1: float = 0.0, angle: float = 6.283185307179586) -&gt; Geometry3DFromCAD</code>","text":"<p>A solid cone (or conical frustum) geometry.</p> <p>Constructs a cone/frustum by extruding a circle of radius <code>radius0</code> along an axis vector, linearly varying the radius to <code>radius1</code> at the end.</p> <p>Arguments:</p> <ul> <li><code>base_center</code>: Center of the base face.</li> <li><code>axis</code>: Extrusion vector (its length sets the height).</li> <li><code>radius0</code>: Base radius \\(r_0\\).</li> <li><code>radius1</code>: Top radius \\(r_1\\) (use \\(0\\) for a pointed cone).</li> <li><code>angle</code>: Angular opening in radians.</li> </ul> <p>Returns:</p> <p>A <code>Geometry3DFromCAD</code> representing the cone.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Torus","title":"<code>phydrax.domain.Torus(center: collections.abc.Sequence | ArrayLike, inner_radius: float, outer_radius: float, angle: float = 6.283185307179586) -&gt; Geometry3DFromCAD</code>","text":"<p>A solid torus geometry.</p> <p>This helper interprets <code>inner_radius</code>/<code>outer_radius</code> as the inner/outer radii of the torus tube. It converts them to the usual major/minor radii via \\(R=\\tfrac{1}{2}(r_{\\texttt{in}}+r_{\\texttt{out}})\\) and \\(r=\\tfrac{1}{2}(r_{\\texttt{out}}-r_{\\texttt{in}})\\).</p> <p>Arguments:</p> <ul> <li><code>center</code>: Center translation of the torus.</li> <li><code>inner_radius</code>: Inner tube radius \\(r_{\\texttt{in}}\\).</li> <li><code>outer_radius</code>: Outer tube radius \\(r_{\\texttt{out}}\\).</li> <li><code>angle</code>: Angular opening in radians.</li> </ul> <p>Returns:</p> <p>A <code>Geometry3DFromCAD</code> representing the torus.</p>"},{"location":"api/domain/geometry3d/#phydrax.domain.Wedge","title":"<code>phydrax.domain.Wedge(x0: collections.abc.Sequence | ArrayLike, extends: collections.abc.Sequence | ArrayLike, top_extent: float) -&gt; Geometry3DFromCAD</code>","text":"<p>A right angular wedge geometry.</p> <p>Constructs a wedge-like solid defined by a right-angle corner and edge extents. This is useful for simple ramp/wedge test geometries in mechanics and CFD.</p> <p>Arguments:</p> <ul> <li><code>x0</code>: Coordinates of the reference corner.</li> <li><code>extends</code>: Edge extents along each axis.</li> <li><code>top_extent</code>: Controls the top face extent along the \\(x\\) direction.</li> </ul> <p>Returns:</p> <p>A <code>Geometry3DFromCAD</code> representing the wedge.</p>"},{"location":"api/domain/sampling/","title":"Sampling","text":"<p>Structured sampling yields batches that preserve axis meaning (via named axes), so that operators and constraints can keep shape semantics without manual broadcasting.</p> <p>For a conceptual overview (product structures, components, and coord-separable grids), see Guides \u2192 Domains and sampling.</p>"},{"location":"api/domain/sampling/#paired-vs-coord-separable-sampling","title":"Paired vs coord-separable sampling","text":"<p>Phydrax supports two complementary structured sampling modes:</p> <ul> <li>Paired sampling (<code>PointsBatch</code>): samples points in each block of a <code>ProductStructure</code>.   This is the default mode used by most pointwise PDE residual constraints.</li> <li>Coord-separable sampling (<code>CoordSeparableBatch</code>): samples 1D coordinate axes for selected   geometry labels and evaluates on the implied Cartesian grid (with an interior mask).   This is the natural mode for FFT/basis/spectral operators and neural operators (FNO, DeepONet).</li> </ul> <p>Coord-separable sampling is driven by <code>DomainComponent.sample_coord_separable(...)</code>, which takes:</p> <ul> <li><code>coord_separable</code>: a mapping from geometry label (e.g. <code>\"x\"</code>) to either   counts (<code>int</code> / <code>Sequence[int]</code>) or basis-aware axis specs (<code>AbstractAxisSpec</code> implementations / <code>GridSpec</code>);</li> <li><code>dense_structure</code> + <code>num_points</code>: how to sample any remaining non-fixed, non-separable labels   (e.g. <code>\"data\"</code> for operator-learning datasets).</li> </ul> <p>Example</p> <p>Coord-separable grid evaluation on an interval:</p> <pre><code>import jax.random as jr\nimport phydrax as phx\n\ngeom = phx.domain.Interval1d(0.0, 1.0)\ncomponent = geom.component()\n\nbatch = component.sample_coord_separable(\n    {\"x\": phx.domain.FourierAxisSpec(64)},\n    key=jr.key(0),\n)\n</code></pre> <p>Note</p> <p>A <code>CoordSeparableBatch</code> stores:</p> <ul> <li><code>coord_axes_by_label</code>: per-label axis names (for shape/dims inference),</li> <li><code>coord_mask_by_label</code>: per-label interior masks on the Cartesian grid,</li> <li><code>axis_discretization_by_axis</code>: optional per-axis metadata (nodes/weights/basis),   used by quadrature and basis backends.</li> </ul>"},{"location":"api/domain/sampling/#phydrax.domain.ProductStructure","title":"<code>phydrax.domain.ProductStructure</code>","text":"<p>Describes how a product domain is sampled into named axes.</p> <p>Phydrax uses labeled product domains, e.g. \\(\\Omega = \\Omega_x \\times \\Omega_t\\) with labels <code>\"x\"</code> and <code>\"t\"</code>. When sampling points from a <code>DomainComponent</code>, we often want to control which variables are sampled jointly and which are sampled in separate blocks.</p> <p>A <code>ProductStructure</code> defines a partition of the (non-fixed) labels into blocks <code>(B_1, \\dots, B_k)</code>. For each block \\(B_j\\) we sample \\(n_j\\) joint points in \\(\\prod_{\\ell\\in B_j}\\Omega_\\ell\\). Each block corresponds to one named sampling axis (e.g. <code>__phydra_blk__x__t</code>), and values evaluated on the resulting <code>PointsBatch</code> are <code>coordax.Field</code>s carrying those axis names.</p> <p>For example:</p> <ul> <li><code>ProductStructure(((\"x\", \"t\"),))</code> samples paired space-time points.</li> <li><code>ProductStructure(((\"x\",), (\"t\",)))</code> samples space and time independently,   producing a Cartesian product grid in evaluation.</li> </ul>"},{"location":"api/domain/sampling/#phydrax.domain.ProductStructure.__init__","title":"<code>__init__(blocks: tuple[tuple[str, ...], ...], *, axis_names: tuple[str, ...] | None = None)</code>","text":""},{"location":"api/domain/sampling/#phydrax.domain.ProductStructure.canonicalize","title":"<code>canonicalize(domain_labels: tuple[str, ...], *, fixed_labels: frozenset[str] = frozenset()) -&gt; ProductStructure</code>","text":"<p>Return a structure with blocks ordered canonically for a domain.</p> <p>Canonicalization enforces:</p> <ul> <li>Every non-fixed domain label appears in exactly one block.</li> <li>Each block is sorted in the order it appears in <code>domain_labels</code>.</li> <li><code>axis_names</code> is set (generated if missing).</li> </ul> <p>This is required before constructing a <code>PointsBatch</code>, since named axes are derived from the canonical blocks.</p>"},{"location":"api/domain/sampling/#phydrax.domain.ProductStructure.axis_for","title":"<code>axis_for(label: str) -&gt; str | None</code>","text":"<p>Return the sampling axis name corresponding to <code>label</code> (or <code>None</code> if fixed).</p>"},{"location":"api/domain/sampling/#phydrax.domain.PointsBatch","title":"<code>phydrax.domain.PointsBatch</code>","text":"<p>A labeled batch of sampled points with explicit axis semantics.</p> <p>A <code>PointsBatch</code> is a mapping <code>{label: coordax.Field}</code> paired with a canonicalized <code>ProductStructure</code>. Each label's point array is stored as a <code>coordax.Field</code> whose named axes correspond to the sampling block(s) that include that label.</p> <p>If a label is in a block with axis name <code>a</code>, then its sampled points carry a named dimension <code>a</code> of length equal to the number of samples in that block.</p>"},{"location":"api/domain/sampling/#phydrax.domain.PointsBatch.__init__","title":"<code>__init__(points: phydrax._frozendict.frozendict[str, PyTree[coordax.Field]], structure: ProductStructure)</code>","text":"<p>Construct a <code>PointsBatch</code> from sampled points and a canonical structure.</p>"},{"location":"api/domain/sampling/#phydrax.domain.QuadratureBatch","title":"<code>phydrax.domain.QuadratureBatch</code>","text":"<p>Quadrature weights associated with a <code>PointsBatch</code>.</p> <p>A <code>QuadratureBatch</code> stores one 1D weight field per sampling axis. The total tensor-product weight is</p> \\[ w(z) = \\prod_{a \\in \\mathcal{A}} w_a, \\] <p>where each \\(w_a\\) is a <code>coordax.Field</code> with dims <code>(a,)</code>. These weights are used by integral estimators such as <code>phydrax.operators.integral</code>.</p>"},{"location":"api/domain/sampling/#phydrax.domain.QuadratureBatch.__init__","title":"<code>__init__(batch: PointsBatch, *, weights_by_axis: phydrax._frozendict.frozendict[str, coordax.Field] | collections.abc.Mapping[str, coordax.Field])</code>","text":""},{"location":"api/domain/sampling/#phydrax.domain.QuadratureBatch.total_weight","title":"<code>total_weight() -&gt; Field</code>","text":"<p>Return the product weight field.</p> <p>If <code>weights_by_axis = {a: w_a}</code>, returns \\(w=\\prod_a w_a\\) as a <code>coordax.Field</code>.</p>"},{"location":"api/domain/sampling/#phydrax.domain.CoordSeparableBatch","title":"<code>phydrax.domain.CoordSeparableBatch</code>","text":"<p>A batch that separates coordinate axes for selected geometry labels.</p> <p>For some geometries it is efficient to sample each coordinate axis independently, e.g. draw \\((x_1,\\dots,x_{n_1})\\) and \\((y_1,\\dots,y_{n_2})\\) separately and evaluate on the implied grid.</p> <p>A <code>CoordSeparableBatch</code> stores: - <code>coord_axes_by_label</code>: which named axes correspond to each coordinate component,   e.g. <code>(\"x0\", \"x1\")</code> for a 2D geometry label. - <code>coord_mask_by_label</code>: a mask <code>coordax.Field</code> that can be used to exclude   coordinate combinations outside an irregular geometry (e.g. AABB grid masking). - <code>dense_structure</code>: a normal <code>ProductStructure</code> for any remaining (non-separable)   labels sampled in paired blocks.</p>"},{"location":"api/domain/sampling/#phydrax.domain.CoordSeparableBatch.__init__","title":"<code>__init__(points: phydrax._frozendict.frozendict[str, PyTree[coordax.Field]], *, dense_structure: ProductStructure, coord_axes_by_label: phydrax._frozendict.frozendict[str, tuple[str, ...]] | collections.abc.Mapping[str, tuple[str, ...]], coord_mask_by_label: phydrax._frozendict.frozendict[str, coordax.Field] | collections.abc.Mapping[str, coordax.Field], axis_discretization_by_axis: phydrax._frozendict.frozendict[str, phydrax.domain._grid.AxisDiscretization] | collections.abc.Mapping[str, phydrax.domain._grid.AxisDiscretization] | None = None)</code>","text":"<p>Construct a coordinate-separable batch of points.</p>"},{"location":"api/domain/sampling/#coord-separable-grids","title":"Coord-separable grids","text":""},{"location":"api/domain/sampling/#phydrax.domain.AxisDiscretization","title":"<code>phydrax.domain.AxisDiscretization</code>","text":"<p>Materialized 1D discretization data for a single coordinate axis.</p> <p>This bundles:</p> <ul> <li><code>nodes</code>: 1D coordinates \\(x_j\\) along an axis.</li> <li><code>quad_weights</code>: optional 1D quadrature weights \\(w_j\\) for approximating 1D integrals.</li> <li><code>basis</code>: a hint describing how the axis was constructed (<code>\"fourier\"</code>, <code>\"sine\"</code>,   <code>\"cosine\"</code>, <code>\"legendre\"</code>, <code>\"uniform\"</code>),</li> <li><code>periodic</code>: whether the axis should be treated as periodic (useful for FFT/Fourier methods).</li> </ul> <p>When <code>quad_weights</code> are present, they approximate</p> \\[ \\int_a^b f(x)\\,dx \\approx \\sum_j w_j f(x_j), \\]"},{"location":"api/domain/sampling/#phydrax.domain.AxisDiscretization.__init__","title":"<code>__init__(*, nodes: Array, quad_weights: Array | None, basis: Literal[uniform, fourier, sine, cosine, legendre], periodic: bool)</code>","text":""},{"location":"api/domain/sampling/#phydrax.domain.AbstractAxisSpec","title":"<code>phydrax.domain.AbstractAxisSpec</code>","text":"<p>Abstract base class for 1D grid/basis axis specifications.</p> <p>An <code>AxisSpec</code> is an instruction for how to discretize a 1D coordinate axis on an interval \\([a,b]\\). Calling <code>materialize(a, b)</code> produces an <code>AxisDiscretization</code> with nodes (and possibly quadrature weights) for that axis.</p>"},{"location":"api/domain/sampling/#phydrax.domain.AbstractAxisSpec.__init__","title":"<code>__init__(n: int)</code>","text":""},{"location":"api/domain/sampling/#phydrax.domain.GridSpec","title":"<code>phydrax.domain.GridSpec</code>","text":"<p>A per-label grid spec: one axis spec per coordinate component.</p> <p>For a geometry variable with <code>var_dim=d</code>, use <code>GridSpec(axes=(spec0, ..., spec{d-1}))</code> to specify a different <code>AxisSpec</code> per coordinate axis.</p>"},{"location":"api/domain/sampling/#phydrax.domain.GridSpec.__init__","title":"<code>__init__(axes: Sequence[AbstractAxisSpec])</code>","text":""},{"location":"api/domain/sampling/#phydrax.domain.UniformAxisSpec","title":"<code>phydrax.domain.UniformAxisSpec</code>","text":"<p>Uniform grid on \\([a,b]\\).</p> <p>Uses <code>jax.numpy.linspace(a, b, n, endpoint=...)</code>. Quadrature weights default to trapezoid weights when <code>endpoint=True</code> and uniform weights when the axis is treated as periodic (either <code>periodic=True</code> or <code>endpoint=False</code>).</p>"},{"location":"api/domain/sampling/#phydrax.domain.UniformAxisSpec.__init__","title":"<code>__init__(n: int, *, endpoint: bool = True, periodic: bool = False)</code>","text":""},{"location":"api/domain/sampling/#phydrax.domain.FourierAxisSpec","title":"<code>phydrax.domain.FourierAxisSpec</code>","text":"<p>Uniform periodic grid for Fourier/FFT methods (endpoint excluded).</p> <p>Uses the nodes</p> \\[ x_j = a + (b-a)\\frac{j}{n},\\quad j=0,\\dots,n-1, \\] <p>with uniform weights \\(w_j=(b-a)/n\\). The resulting axis is marked <code>periodic=True</code>.</p>"},{"location":"api/domain/sampling/#phydrax.domain.SineAxisSpec","title":"<code>phydrax.domain.SineAxisSpec</code>","text":"<p>Uniform interior grid (cell-centered) suitable for sine-like expansions.</p> <p>Uses the nodes</p> \\[ x_j = a + (b-a)\\frac{j+\\tfrac12}{n},\\quad j=0,\\dots,n-1, \\] <p>with uniform weights \\(w_j=(b-a)/n\\). The resulting axis is non-periodic.</p>"},{"location":"api/domain/sampling/#phydrax.domain.CosineAxisSpec","title":"<code>phydrax.domain.CosineAxisSpec</code>","text":"<p>Uniform endpoint-including grid suitable for cosine-like expansions.</p> <p>Uses the nodes</p> \\[ x_j = a + (b-a)\\frac{j}{n-1},\\quad j=0,\\dots,n-1, \\] <p>with trapezoid weights \\(w_0=w_{n-1}=\\tfrac12\\Delta x\\), \\(w_j=\\Delta x\\) otherwise. The resulting axis is non-periodic.</p>"},{"location":"api/domain/sampling/#phydrax.domain.LegendreAxisSpec","title":"<code>phydrax.domain.LegendreAxisSpec</code>","text":"<p>Legendre Gauss/Radau/Lobatto nodes and weights (via orthax).</p> <p>orthax returns canonical nodes \\(\\xi_j\\in[-1,1]\\) and weights \\(w_j\\), which are mapped to \\([a,b]\\) via</p> \\[ x_j=\\tfrac{b-a}{2}\\,\\xi_j+\\tfrac{a+b}{2},\\qquad \\tilde w_j=\\tfrac{b-a}{2}\\,w_j. \\]"},{"location":"api/domain/sampling/#phydrax.domain.LegendreAxisSpec.__init__","title":"<code>__init__(n: int, *, kind: Literal[gauss, radau, lobatto] = 'gauss')</code>","text":""},{"location":"api/domain/sampling/#axis-conventions-nodes-weights","title":"Axis conventions (nodes + weights)","text":"<p>Many basis-aware operators (spectral derivatives, quadrature) want both:</p> <ul> <li>nodes \\(x_j\\) on an axis \\([a,b]\\),</li> <li>quadrature weights \\(w_j\\) to approximate \\(\\int_a^b f(x)\\,dx \\approx \\sum_j w_j f(x_j)\\).</li> </ul> <p>When you sample with axis specs (<code>AbstractAxisSpec</code> implementations) / <code>GridSpec</code>, Phydrax materializes an <code>AxisDiscretization</code> and attaches it on the batch (so downstream operators can reuse nodes/weights).</p>"},{"location":"api/domain/sampling/#fourier-periodic-endpoint-excluded","title":"Fourier (periodic, endpoint excluded)","text":"<p>For <code>FourierAxisSpec(n)</code>:</p> \\[ x_j = a + (b-a)\\frac{j}{n},\\quad j=0,\\dots,n-1,\\qquad w_j = \\frac{b-a}{n}. \\]"},{"location":"api/domain/sampling/#sine-cell-centered-interior-grid","title":"Sine (cell-centered interior grid)","text":"<p>For <code>SineAxisSpec(n)</code>:</p> \\[ x_j = a + (b-a)\\frac{j+\\tfrac12}{n},\\quad j=0,\\dots,n-1,\\qquad w_j = \\frac{b-a}{n}. \\]"},{"location":"api/domain/sampling/#cosine-endpoint-grid-trapezoid-weights","title":"Cosine (endpoint grid + trapezoid weights)","text":"<p>For <code>CosineAxisSpec(n)</code>:</p> \\[ x_j = a + (b-a)\\frac{j}{n-1},\\quad j=0,\\dots,n-1, \\] <p>and trapezoid weights \\(w_0=w_{n-1}=\\tfrac12\\Delta x\\), \\(w_j=\\Delta x\\) otherwise.</p>"},{"location":"api/domain/sampling/#legendre-orthax-gauss-radau-lobatto","title":"Legendre (orthax Gauss / Radau / Lobatto)","text":"<p>For <code>LegendreAxisSpec(n)</code>, orthax produces nodes \\(\\xi_j\\in[-1,1]\\) and weights \\(w_j\\) for the canonical interval. Phydrax maps them to \\([a,b]\\) via</p> \\[ x_j=\\tfrac{b-a}{2}\\,\\xi_j+\\tfrac{a+b}{2},\\qquad \\tilde w_j=\\tfrac{b-a}{2}\\,w_j. \\]"},{"location":"api/domain/time/","title":"Time","text":"<p><code>TimeInterval</code> is an alias of <code>ScalarInterval</code> with default label <code>\"t\"</code>. Use <code>ScalarInterval(..., label=\"...\")</code> for generic scalar axes.</p>"},{"location":"api/domain/time/#phydrax.domain.TimeInterval","title":"<code>phydrax.domain.TimeInterval</code>","text":"<p>A closed finite 1D scalar interval domain.</p> <p>Represents the domain</p> \\[ \\Omega_{\\ell} = [a, b], \\] <p>with label given by <code>label</code>. The measure is the interval length \\(|\\Omega_{\\ell}|=b-a\\).</p> <p>Sampling draws points \\(x_i\\in[a,b]\\) using the chosen sampler (uniform, Latin hypercube, Sobol, etc.), optionally filtered by a predicate <code>where(x)</code>.</p>"},{"location":"api/domain/time/#phydrax.domain.TimeInterval.extent","title":"<code>extent</code>  <code>property</code>","text":"<p>Return the interval length \\(b-a\\).</p>"},{"location":"api/domain/time/#phydrax.domain.TimeInterval.measure","title":"<code>measure</code>  <code>property</code>","text":"<p>Return the measure \\(|\\Omega_{\\ell}|\\) (equal to <code>extent</code>).</p>"},{"location":"api/domain/time/#phydrax.domain.TimeInterval.bounds","title":"<code>bounds</code>  <code>property</code>","text":"<p>Return an iterator over \\((a, b)\\).</p>"},{"location":"api/domain/time/#phydrax.domain.TimeInterval.__init__","title":"<code>__init__(start: float, end: float, *, label: str = 't')</code>","text":""},{"location":"api/domain/time/#phydrax.domain.TimeInterval.sample","title":"<code>sample(num_points: int, *, sampler: str = 'latin_hypercube', where: collections.abc.Callable | None = None, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/domain/time/#phydrax.domain.TimeInterval.fixed","title":"<code>fixed(which: str) -&gt; Array</code>","text":""},{"location":"api/nn/","title":"Neural networks","text":"<p>Phydrax models are Equinox modules with explicit <code>in_size</code> / <code>out_size</code> semantics and support for structured inputs used in product-domain factorization.</p> <p>Note</p> <p>Key notes:</p> <ul> <li>Most models are pointwise: use <code>jax.vmap</code> for batching.</li> <li><code>out_size=\"scalar\"</code> indicates scalar outputs (typically shape <code>()</code>).</li> <li>Structured models accept tuple inputs like <code>(x1, x2, ..., xd)</code>.</li> <li>Neural operator architectures (DeepONet/FNO) are intentionally minimal reference   implementations; extend them for production features and scaling needs.</li> </ul>"},{"location":"api/nn/activations/","title":"Activations","text":"<p>Trainable nonlinearities.</p> <p>Note</p> <p>Key notes:</p> <ul> <li><code>Stan</code> is a self-scalable tanh: \\(\\operatorname{tanh}(x)\\,(1+\\beta x)\\).</li> <li><code>AdaptiveActivation</code> wraps \\(\\sigma\\) as \\(x\\mapsto\\sigma(ax)\\).</li> </ul>"},{"location":"api/nn/activations/#phydrax.nn.Stan","title":"<code>phydrax.nn.Stan</code>","text":"<p>Self-scalable tanh (Stan) activation.</p> <p>Applies</p> \\[ \\text{Stan}_\\beta(x)=\\tanh(x)\\,(1+\\beta x), \\] <p>with trainable \\(\\beta\\) (scalar or broadcastable array).</p>"},{"location":"api/nn/activations/#phydrax.nn.Stan.__init__","title":"<code>__init__(shape: int | collections.abc.Sequence[int] | None = None, *, key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Arguments:</p> <ul> <li><code>shape</code>: Shape of \\(\\beta\\) (use <code>None</code> for a scalar).</li> <li><code>key</code>: PRNG key (unused; included for API compatibility).</li> </ul>"},{"location":"api/nn/activations/#phydrax.nn.Stan.__call__","title":"<code>__call__(x: Array) -&gt; Array</code>","text":"<p>Apply \\(\\text{Stan}_\\beta\\) to <code>x</code>.</p> <p>Computes \\(\\tanh(x)\\,(1+\\beta x)\\) with broadcasting over the shape of <code>beta</code>.</p>"},{"location":"api/nn/activations/#phydrax.nn.AdaptiveActivation","title":"<code>phydrax.nn.AdaptiveActivation</code>","text":"<p>Adaptive activation wrapper.</p> <p>Wraps an activation \\(\\sigma\\) as</p> \\[ x\\mapsto\\sigma(a x), \\] <p>where \\(a\\) is a trainable scalar (layer-wise) or broadcastable vector (neuron-wise).</p>"},{"location":"api/nn/activations/#phydrax.nn.AdaptiveActivation.__init__","title":"<code>__init__(fn: collections.abc.Callable[[Array], Array], /, *, shape: int | collections.abc.Sequence[int] | None = None, key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Arguments:</p> <ul> <li><code>fn</code>: Base activation function \\(\\sigma\\).</li> <li><code>shape</code>: Shape of the trainable coefficient \\(a\\) (use <code>None</code> for a scalar).</li> <li><code>key</code>: PRNG key (unused; included for API compatibility).</li> </ul>"},{"location":"api/nn/activations/#phydrax.nn.AdaptiveActivation.__call__","title":"<code>__call__(x: Array) -&gt; Array</code>","text":"<p>Apply the adaptive activation to <code>x</code>.</p> <p>Computes \\(\\sigma(a x)\\) where \\(\\sigma\\) is the wrapped <code>fn</code> and \\(a\\) is the trainable coefficient.</p>"},{"location":"api/nn/architectures/","title":"Architectures","text":"<p>Common end-to-end model families (dense, separable, polynomial, and complex-valued).</p> <p>Note</p> <p>Key notes:</p> <ul> <li><code>MLP</code> is a standard feed-forward network with optional residual connection.</li> <li><code>KAN</code> replaces activations with polynomial edge functions.</li> <li><code>FeynmaNN</code> builds complex hidden states with a sum-over-paths block.</li> </ul>"},{"location":"api/nn/architectures/#phydrax.nn.MLP","title":"<code>phydrax.nn.MLP</code>","text":"<p>Multi-Layer Perceptron (MLP).</p> <p>For input \\(x\\in\\mathbb{R}^{d_\\text{in}}\\) this model applies a sequence of affine maps and nonlinearities. Writing \\(h^{(0)}=x\\), a depth-\\(L\\) network is</p> \\[ h^{(k)}=\\sigma_k\\!\\left(W_k h^{(k-1)}+b_k\\right),\\qquad k=1,\\dots,L, \\] <p>where hidden layers use <code>activation</code>, the final <code>Linear</code> layer uses the identity nonlinearity, and the output activation \\(\\phi\\) (<code>final_activation</code>) is applied outside the last layer:</p> \\[ y=\\phi\\!\\left(h^{(L)}\\right). \\] <p>If <code>skip_connection=True</code> then a residual term is added before \\(\\phi\\):</p> \\[ h^{(L)}\\leftarrow h^{(L)} + P x, \\] <p>where \\(P\\) is the identity when \\(d_\\text{in}=d_\\text{out}\\) and otherwise a learned linear projection.</p>"},{"location":"api/nn/architectures/#phydrax.nn.MLP.__init__","title":"<code>__init__(*, in_size: typing.Union[int, collections.abc.Sequence[int], typing.Literal['scalar']], out_size: typing.Union[int, collections.abc.Sequence[int], typing.Literal['scalar']], width_size: int | None = None, depth: int | None = None, hidden_sizes: collections.abc.Sequence[int] | None = None, activation: Callable = tanh, final_activation: collections.abc.Callable | None = None, skip_connection: bool = False, rwf: bool | tuple[float, float] = False, use_bias: bool = True, use_final_bias: bool = True, initializer: str = 'glorot_normal', key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Construct an MLP.</p> <p>You may specify the hidden layout either with (<code>width_size</code>, <code>depth</code>) or with an explicit <code>hidden_sizes</code> sequence.</p> <p>Arguments:</p> <ul> <li><code>in_size</code>: Input value size: <code>\"scalar\"</code>, <code>d</code> (vector), or <code>(..., ...)</code> (tensor).</li> <li><code>out_size</code>: Output value size: <code>\"scalar\"</code>, <code>m</code> (vector), or <code>(..., ...)</code> (tensor).</li> <li><code>width_size</code>: Uniform hidden width (mutually exclusive with <code>hidden_sizes</code>).</li> <li><code>depth</code>: Number of hidden layers (mutually exclusive with <code>hidden_sizes</code>).</li> <li><code>hidden_sizes</code>: Explicit hidden layer sizes.</li> <li><code>activation</code>: Hidden-layer activation (callable).</li> <li><code>final_activation</code>: Output activation (default: identity).</li> <li><code>skip_connection</code>: If <code>True</code>, adds a residual connection to the pre-activation output.</li> <li><code>rwf</code>: Random Weight Factorization for <code>Linear</code> layers; if <code>(\\mu,\\sigma)</code>,   initializes \\(s\\sim\\mathcal{N}(\\mu,\\sigma^2)\\).</li> <li><code>use_bias</code>: Whether to use biases in hidden <code>Linear</code> layers.</li> <li><code>use_final_bias</code>: Whether to use a bias in the final <code>Linear</code> layer.</li> <li><code>initializer</code>: Weight initializer name for <code>Linear</code> layers.</li> <li><code>key</code>: PRNG key.</li> </ul>"},{"location":"api/nn/architectures/#phydrax.nn.MLP.__call__","title":"<code>__call__(x: Array, /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Evaluate the MLP at <code>x</code>.</p> <p>Arguments:</p> <ul> <li><code>x</code>: Input with trailing value shape implied by <code>in_size</code>. Leading axes are free.</li> <li><code>key</code>: PRNG key forwarded to layers (most layers are deterministic and   ignore it; it is present for API consistency).</li> </ul> <p>Returns:</p> <ul> <li>Output with trailing value shape implied by <code>out_size</code>. If <code>out_size == \"scalar\"</code>,   returns a scalar per leading index (no trailing value axis).</li> </ul>"},{"location":"api/nn/architectures/#phydrax.nn.KAN","title":"<code>phydrax.nn.KAN</code>","text":"<p>Kolmogorov-Arnold Network (KAN) with orthogonal polynomial edge functions.</p> <p>Stacks <code>KANLayer</code> blocks; each edge uses a degree-<code>degree</code> orthogonal polynomial expansion (Chebyshev by default).</p> <p>Enable <code>use_tanh=True</code> to map pre-activations into \\([-1,1]\\) before evaluating the basis.</p>"},{"location":"api/nn/architectures/#phydrax.nn.KAN.__init__","title":"<code>__init__(*, in_size: typing.Union[int, collections.abc.Sequence[int], typing.Literal['scalar']], out_size: typing.Union[int, collections.abc.Sequence[int], typing.Literal['scalar']], width_size: int | None = None, depth: int | None = None, hidden_sizes: collections.abc.Sequence[int] | None = None, degree: int | collections.abc.Sequence[int] = 5, use_tanh: bool = False, scale_mode: typing.Literal['edge', 'input', 'none'] = 'edge', init: typing.Literal['default', 'identity'] = 'default', autoscale: bool = False, final_activation: collections.abc.Callable | None = None, skip_connection: bool = True, use_bias: bool = True, poly: str = 'chebyshev', poly_params: dict | None = None, key: Key[Array, ''] = jr.key(0))</code>","text":""},{"location":"api/nn/architectures/#phydrax.nn.KAN.__call__","title":"<code>__call__(x: Array, /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Evaluate the KAN at <code>x</code>.</p> <p>Applies the stacked <code>KANLayer</code>s and an optional residual connection, then applies <code>final_activation</code> to the result.</p>"},{"location":"api/nn/architectures/#phydrax.nn.FeynmaNN","title":"<code>phydrax.nn.FeynmaNN</code>","text":"<p>Feynman path-integral style network with complex hidden blocks.</p> <p>This model builds a complex-valued hidden state and updates it with a sum-over-paths block. For a hidden vector \\(z\\) and \\(K\\) paths, one block computes</p> \\[ \\text{Block}(z)   = \\sum_{k=1}^{K} g_k\\;e^{i\\,\\alpha_k(z)}\\,(W_k z + b_k), \\] <p>where \\(g=\\text{softmax}(\\text{logits})\\) are learned gates and \\(\\alpha(z)\\) is produced by a small real action network (scaled by <code>phase_scale</code>).</p> <p>The nonlinearity is ModReLU:</p> \\[ \\text{ModReLU}(z)=\\mathop{\\text{max}}(|z|+b,0)\\,\\frac{z}{|z|+\\varepsilon}. \\] <p>Stacking <code>depth</code> blocks yields a complex latent representation which is mapped to the requested output either by a real readout (concatenating \\(\\Re z\\) and \\(\\Im z\\)) or by a complex linear projection.</p>"},{"location":"api/nn/architectures/#phydrax.nn.FeynmaNN.__init__","title":"<code>__init__(*, in_size: typing.Union[int, typing.Literal['scalar']], out_size: typing.Union[int, typing.Literal['scalar']], width_size: int, depth: int, num_paths: int = 4, width_action: int = 32, phase_scale: float = 1.0, final_activation: collections.abc.Callable | None = None, modrelu_bias_init: float = 0.0, learn_gates: bool = True, key: Key[Array, ''] = jr.key(0), rwf: bool | tuple[float, float] = False, keep_output_complex: bool = False)</code>","text":""},{"location":"api/nn/architectures/#phydrax.nn.FeynmaNN.__call__","title":"<code>__call__(x: Array, /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/nn/architectures/#operator-networks","title":"Operator networks","text":"<p>Operator-learning models typically consume structured inputs from product domains, e.g. \\((\\text{data}, x)\\) for a dataset factor and a spatial geometry.</p> <p>Phydrax's <code>Domain.Model(...)</code> wrapper will pass dependency arguments to models as either:</p> <ul> <li>point inputs (dense sampling): coordinate arrays with leading batch axes, or</li> <li>coord-separable inputs: tuples of 1D coordinate axes (from <code>CoordSeparableBatch</code>).</li> </ul> <p>Note</p> <p>Input conventions:</p> <ul> <li><code>DeepONet</code> expects <code>(branch_input, coords...)</code>, where <code>coords</code> are either   <code>coord_dim</code> separate 1D axes (grid mode) or a single array with trailing dimension <code>coord_dim</code> (point mode).</li> <li><code>FNO1d</code> expects <code>(grid_values, x_axis)</code> and requires grid evaluation (<code>x_axis</code> must be 1D with length &gt; 1).</li> <li><code>FNO2d</code> expects <code>(grid_values, x_axis, y_axis)</code> and requires grid evaluation (<code>x_axis</code>, <code>y_axis</code> 1D with length &gt; 1).</li> <li>These operator models are minimal implementations intended as building blocks; for   production use you may want additional features (padding/dealiasing, normalization,   richer positional encodings, batching utilities, etc.).</li> </ul>"},{"location":"api/nn/architectures/#phydrax.nn.DeepONet","title":"<code>phydrax.nn.DeepONet</code>","text":"<p>Minimal Deep Operator Network (DeepONet) for structured inputs.</p> <p>DeepONet represents an operator \\(G\\) by a low-rank expansion</p> \\[ (Gf)(x)\\;\\approx\\;\\sum_{k=1}^p b_k(f)\\,t_k(x), \\] <p>where the branch network maps the input function/data \\(f\\) to coefficients \\(b(f)\\in\\mathbb{R}^p\\) and the trunk network maps coordinates \\(x\\) to basis values \\(t(x)\\in\\mathbb{R}^p\\) (optionally replicated for vector outputs).</p> <p>Expects a tuple input <code>(branch_input, coords...)</code>. For point inputs, <code>coords</code> may be a single array with trailing dimension <code>coord_dim</code>. For coord-separable grid inputs, <code>coords</code> should be <code>coord_dim</code> separate 1D axis arrays.</p>"},{"location":"api/nn/architectures/#phydrax.nn.DeepONet.__init__","title":"<code>__init__(*, branch: _AbstractBaseModel, trunk: _AbstractBaseModel, coord_dim: int, latent_size: int, out_size: int | Literal[scalar] = 'scalar', in_size: int | Literal[scalar] = 'scalar')</code>","text":""},{"location":"api/nn/architectures/#phydrax.nn.DeepONet.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/nn/architectures/#phydrax.nn.FNO1d","title":"<code>phydrax.nn.FNO1d</code>","text":"<p>Minimal 1D Fourier Neural Operator for coord-separable grid evaluation.</p> <p>Input convention (structured tuple):</p> <ul> <li><code>data</code>: grid values with leading axis length <code>n</code> (shape <code>(n,)</code> or <code>(n, c_in)</code>),</li> <li><code>x_axis</code>: 1D coordinate axis of shape <code>(n,)</code> (must have <code>n&gt;1</code>).</li> </ul> <p>The axis values are used for sanity checking and to enforce \"grid mode\" usage.</p>"},{"location":"api/nn/architectures/#phydrax.nn.FNO1d.__init__","title":"<code>__init__(*, in_channels: int | Literal[scalar] = 'scalar', out_channels: int | Literal[scalar] = 'scalar', width: int = 32, depth: int = 4, modes: int = 16, key: Key[Array, ''] = jr.key(0))</code>","text":""},{"location":"api/nn/architectures/#phydrax.nn.FNO1d.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/nn/architectures/#phydrax.nn.FNO2d","title":"<code>phydrax.nn.FNO2d</code>","text":"<p>Minimal 2D Fourier Neural Operator for coord-separable grid evaluation.</p> <p>Input convention (structured tuple):</p> <ul> <li><code>data</code>: grid values with leading axes <code>(n_x, n_y)</code> (optionally with channels),</li> <li><code>x_axis</code>: 1D coordinate axis of shape <code>(n_x,)</code> (must have <code>n_x&gt;1</code>),</li> <li><code>y_axis</code>: 1D coordinate axis of shape <code>(n_y,)</code> (must have <code>n_y&gt;1</code>).</li> </ul> <p>The axis values are used for sanity checking and to enforce \"grid mode\" usage.</p>"},{"location":"api/nn/architectures/#phydrax.nn.FNO2d.__init__","title":"<code>__init__(*, in_channels: int | Literal[scalar] = 'scalar', out_channels: int | Literal[scalar] = 'scalar', width: int = 32, depth: int = 4, modes: int = 12, modes_y: int | None = None, key: Key[Array, ''] = jr.key(0))</code>","text":""},{"location":"api/nn/architectures/#phydrax.nn.FNO2d.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/nn/embeddings/","title":"Embeddings","text":"<p>Input feature maps for coordinate-based learning.</p> <p>Note</p> <p>Key notes:</p> <ul> <li>Random Fourier features approximate stationary kernels via \\(\\phi(x)=[\\cos(Bx),\\sin(Bx)]\\).</li> </ul>"},{"location":"api/nn/embeddings/#phydrax.nn.RandomFourierFeatureEmbeddings","title":"<code>phydrax.nn.RandomFourierFeatureEmbeddings</code>","text":"<p>Random Fourier feature embedding.</p> <p>Samples a (possibly multi-block) Gaussian matrix \\(B\\) and returns</p> \\[ \\phi(x)=\\big[\\cos(Bx),\\ \\sin(Bx)\\big]. \\]"},{"location":"api/nn/embeddings/#phydrax.nn.RandomFourierFeatureEmbeddings.__init__","title":"<code>__init__(*, in_size: typing.Union[int, collections.abc.Sequence[int], typing.Literal['scalar']], out_size: int = 32, mu: ArrayLike | collections.abc.Sequence[ArrayLike] = 0.0, sigma: ArrayLike | collections.abc.Sequence[ArrayLike] = 1.0, trainable: bool = False, key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Arguments:</p> <ul> <li><code>in_size</code>: Input value size. The input is flattened to a vector.</li> <li><code>out_size</code>: Output feature size (must be even; includes cos and sin parts).</li> <li><code>mu</code>: Mean for Gaussian \\(B\\) blocks (scalar or sequence for multiscale).</li> <li><code>sigma</code>: Standard deviation for Gaussian \\(B\\) blocks (scalar or sequence for multiscale).</li> <li><code>trainable</code>: If <code>True</code>, learns \\(B\\); otherwise stops gradients through \\(B\\).</li> <li><code>key</code>: PRNG key.</li> </ul>"},{"location":"api/nn/embeddings/#phydrax.nn.RandomFourierFeatureEmbeddings.__call__","title":"<code>__call__(x: Array, /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/nn/layers/","title":"Layers","text":"<p>Low-level model building blocks.</p> <p>Note</p> <p>Key notes:</p> <ul> <li><code>Linear</code> supports Random Weight Factorization (RWF) and optional complex parameters.</li> </ul>"},{"location":"api/nn/layers/#phydrax.nn.Linear","title":"<code>phydrax.nn.Linear</code>","text":"<p>Affine layer with optional activation.</p> <p>Computes</p> \\[ y=\\phi(Wx+b), \\] <p>where \\(\\phi\\) is <code>activation</code> (or the identity). If Random Weight Factorization (RWF) is enabled, parameters are represented as an unscaled weight matrix \\(V\\) and per-output log-scales \\(s\\), and the layer applies</p> \\[ y=\\phi\\!\\left(\\operatorname{diag}(e^s)\\,Vx + b\\right). \\] <p>If <code>enforce_positive_weights=True</code>, weights are constrained via \\(W=\\operatorname{softplus}(W_\\text{raw})\\).</p>"},{"location":"api/nn/layers/#phydrax.nn.Linear.__init__","title":"<code>__init__(*, in_size: typing.Union[int, collections.abc.Sequence[int], typing.Literal['scalar']], out_size: typing.Union[int, collections.abc.Sequence[int], typing.Literal['scalar']], activation: collections.abc.Callable | None = None, initializer: str = 'glorot_normal', rwf: bool | tuple[float, float] = True, use_random_weight_factorization: bool | None = None, use_bias: bool = True, bias_init_lim: float = 1.0, enforce_positive_weights: bool = False, key: Key[Array, ''] = jr.key(0))</code>","text":""},{"location":"api/nn/layers/#phydrax.nn.Linear.__call__","title":"<code>__call__(x: Array, /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":""},{"location":"api/nn/structured/","title":"Structured models","text":"<p>Models that exploit product-domain structure via low-rank factorization.</p> <p>Note</p> <p>Key notes:</p> <ul> <li><code>Separable</code> implements a CP-style expansion \\(u=\\sum_\\ell\\prod_i g_i^\\ell\\).</li> <li><code>LatentContractionModel</code> generalizes this to named factor models and flexible inputs.</li> </ul>"},{"location":"api/nn/structured/#phydrax.nn.Separable","title":"<code>phydrax.nn.Separable</code>","text":"<p>Separable wrapper using pre-initialized scalar models per coordinate.</p> <p>Each coordinate model maps a scalar \\(x_i\\) to <code>latent_size * out_size</code> features (reshaped to \\((L,m)\\)). The wrapper multiplies per-coordinate features elementwise and sums over the latent axis:</p> \\[ u_o(x)=\\sum_{\\ell=1}^{L}\\prod_{i=1}^{d} g_{i,\\ell,o}(x_i). \\] <p>Supports regular array inputs and separable tuple inputs (a tuple of 1D coordinate arrays).</p>"},{"location":"api/nn/structured/#phydrax.nn.Separable.__init__","title":"<code>__init__(*, in_size: typing.Union[int, typing.Literal['scalar']], out_size: typing.Union[int, typing.Literal['scalar']], latent_size: int, models: collections.abc.Sequence[phydrax.nn.models.core._base._AbstractBaseModel], output_activation: collections.abc.Callable | None = None, keep_outputs_complex: bool = False, split_input: int | None = None, key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Create a separable wrapper.</p> <p>Keyword arguments:</p> <ul> <li><code>in_size</code>: Input dimension \\(d\\) (or <code>\"scalar\"</code>).</li> <li><code>out_size</code>: Output size \\(m\\) (or <code>\"scalar\"</code>).</li> <li><code>latent_size</code>: Rank \\(L\\) in the separable expansion.</li> <li><code>models</code>: Sequence of scalar-input models, one per coordinate (and per   <code>split_input</code> clone), each returning <code>latent_size * out_size</code> features.</li> <li><code>output_activation</code>: Optional activation applied after the contraction (wrap   it yourself if you want adaptive behavior).</li> <li><code>split_input</code>: If provided and <code>in_size=\"scalar\"</code>, replicates the scalar   input across <code>split_input</code> coordinate models.</li> </ul>"},{"location":"api/nn/structured/#phydrax.nn.Separable.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0), **kwargs: typing.Any) -&gt; Array</code>","text":"<p>Evaluate the separable model.</p> <p>For vector inputs \\(x=(x_1,\\dots,x_d)\\) this computes</p> \\[ u_o(x)=\\sum_{\\ell=1}^{L}\\prod_{i=1}^{d} g_{i,\\ell,o}(x_i), \\] <p>where \\(g_i\\) are the per-coordinate scalar models (including any <code>split_input</code> replication).</p> <p>Inputs:</p> <ul> <li><code>x</code>: either a single point of shape <code>(d,)</code> (or scalar <code>()</code> in the   replicated scalar-input case), or a separable tuple <code>(x_1,...,x_d)</code> of   1D coordinate arrays.</li> </ul>"},{"location":"api/nn/structured/#phydrax.nn.SeparableMLP","title":"<code>phydrax.nn.SeparableMLP</code>","text":"<p>Separable MLP over coordinate-wise scalar submodels.</p> <p>This builds one scalar-input <code>MLP</code> per coordinate (and per <code>split_input</code> clone), then wraps them in <code>phydrax.nn.Separable</code> to form a low-rank separable approximation. With latent size \\(L\\) and output size \\(m\\), the resulting model has the form</p> \\[ u_o(x)=\\sum_{\\ell=1}^{L}\\prod_{i=1}^{d} g_{i,\\ell,o}(x_i), \\] <p>where each coordinate model \\(g_i\\) maps a scalar \\(x_i\\) to \\(L\\cdot m\\) features (reshaped to \\((L,m)\\)).</p>"},{"location":"api/nn/structured/#phydrax.nn.SeparableMLP.__init__","title":"<code>__init__(*, in_size: typing.Union[int, typing.Literal['scalar']], out_size: typing.Union[int, typing.Literal['scalar']], latent_size: int = 32, output_activation: collections.abc.Callable | None = None, keep_outputs_complex: bool = False, split_input: int | None = None, width_size: int | None = 20, depth: int | None = 6, hidden_sizes: collections.abc.Sequence[int] | None = None, activation: Callable = tanh, final_activation: collections.abc.Callable | None = None, skip_connection: bool = False, rwf: bool | tuple[float, float] = False, use_bias: bool = True, use_final_bias: bool = True, initializer: str = 'glorot_normal', key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Create a separable MLP.</p> <p><code>SeparableMLP</code> forwards MLP hyperparameters to each internal scalar coordinate model. The coordinate models output <code>latent_size * out_size</code> features so the wrapper can reshape them to \\((L,m)\\) and contract.</p>"},{"location":"api/nn/structured/#phydrax.nn.SeparableMLP.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Evaluate the separable MLP.</p> <p>Accepts either a vector input <code>(d,)</code> or a separable tuple <code>(x_1,...,x_d)</code> of 1D coordinate arrays (see <code>phydrax.nn.Separable</code>).</p>"},{"location":"api/nn/structured/#phydrax.nn.SeparableFeynmaNN","title":"<code>phydrax.nn.SeparableFeynmaNN</code>","text":"<p>Separable FeynmaNN over coordinate-wise scalar submodels.</p> <p>This builds one scalar-input <code>FeynmaNN</code> per coordinate (and per <code>split_input</code> clone), then wraps them in <code>phydrax.nn.Separable</code> to form a low-rank separable approximation. With latent size \\(L\\) and output size \\(m\\), the resulting model has the form</p> \\[ u_o(x)=\\sum_{\\ell=1}^{L}\\prod_{i=1}^{d} g_{i,\\ell,o}(x_i), \\] <p>where each coordinate model \\(g_i\\) maps a scalar \\(x_i\\) to \\(L\\cdot m\\) features (reshaped to \\((L,m)\\)).</p>"},{"location":"api/nn/structured/#phydrax.nn.SeparableFeynmaNN.__init__","title":"<code>__init__(*, in_size: typing.Union[int, typing.Literal['scalar']], out_size: typing.Union[int, typing.Literal['scalar']], latent_size: int = 32, output_activation: collections.abc.Callable | None = None, keep_outputs_complex: bool = False, split_input: int | None = None, width_size: int = 20, depth: int = 6, num_paths: int = 4, width_action: int = 32, phase_scale: float = 1.0, final_activation: collections.abc.Callable | None = None, modrelu_bias_init: float = 0.0, learn_gates: bool = True, rwf: bool | tuple[float, float] = False, keep_output_complex: bool = False, key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Create a separable FeynmaNN.</p> <p><code>SeparableFeynmaNN</code> forwards FeynmaNN hyperparameters to each internal scalar coordinate model. The coordinate models output <code>latent_size * out_size</code> features so the wrapper can reshape them to \\((L,m)\\) and contract.</p>"},{"location":"api/nn/structured/#phydrax.nn.SeparableFeynmaNN.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Evaluate the separable FeynmaNN.</p> <p>Accepts either a vector input <code>(d,)</code> or a separable tuple <code>(x_1,...,x_d)</code> of 1D coordinate arrays (see <code>phydrax.nn.Separable</code>).</p>"},{"location":"api/nn/structured/#phydrax.nn.LatentContractionModel","title":"<code>phydrax.nn.LatentContractionModel</code>","text":"<p>Latent contraction wrapper for product-domain factor models.</p> <p>This implements a low-rank (CP-style) factorization over a product input space. For factors \\(x=(x^{(1)},\\dots,x^{(d)})\\) and latent size \\(L\\), each factor model returns features that can be reshaped to \\(g_i(x^{(i)})\\in\\mathbb{R}^{L\\times m}\\) (with \\(m=\\texttt{out\\_size}\\)). The contraction returns</p> \\[ u_o(x)=\\sum_{\\ell=1}^{L}\\prod_{i=1}^{d} g_{i,\\ell,o}(x^{(i)}). \\] <p>Each factor model may return either: - \\(L\\cdot m\\) features (interpreted as \\((L,m)\\)), or - \\(L\\) features (broadcast across the \\(m\\) outputs).</p>"},{"location":"api/nn/structured/#phydrax.nn.LatentContractionModel.__init__","title":"<code>__init__(*, latent_size: int, out_size: typing.Union[int, typing.Literal['scalar']], factors: collections.abc.Mapping[str, phydrax.nn.models.core._base._AbstractBaseModel] | None = None, output_activation: collections.abc.Callable | None = None, keep_outputs_complex: bool = False, key: Key[Array, ''] = jr.key(0), **factor_models: _AbstractBaseModel)</code>","text":"<p>Create a latent contraction model.</p> <p>Keyword arguments:</p> <ul> <li><code>latent_size</code>: Rank \\(L\\) of the factorization.</li> <li><code>out_size</code>: Output size \\(m\\) (or <code>\"scalar\"</code>).</li> <li><code>factors</code> / <code>**factor_models</code>: Factor models \\(g_i\\) mapping factor inputs   to latent features.</li> <li><code>output_activation</code>: Optional activation applied after contraction (wrap it   yourself if you want adaptive behavior).</li> <li><code>keep_outputs_complex</code>: If <code>True</code>, keeps complex outputs when the   factors are complex-valued; otherwise returns the real part.</li> </ul> <p>Each factor model should return either \\(L\\) features or \\(L\\cdot m\\) features so the wrapper can reshape to \\((L,m)\\).</p>"},{"location":"api/nn/structured/#phydrax.nn.LatentContractionModel.__call__","title":"<code>__call__(x: Array | tuple[Array, ...] | collections.abc.Mapping[str, typing.Any], /, *, key: Key[Array, ''] = jr.key(0), **kwargs: typing.Any) -&gt; Array</code>","text":""},{"location":"api/nn/structured/#phydrax.nn.ConcatenatedModel","title":"<code>phydrax.nn.ConcatenatedModel</code>","text":"<p>Concatenate outputs from multiple models.</p> <p>Given models \\(\\{m_k\\}_{k=1}^K\\) with shared input space, this wrapper returns</p> \\[ y(x)=\\operatorname{concat}\\big(m_1(x),\\dots,m_K(x)\\big), \\] <p>where concatenation is performed along <code>axis</code> (by default the feature axis). Scalar outputs (<code>out_size=\"scalar\"</code>) are treated as length-1 feature vectors for concatenation.</p>"},{"location":"api/nn/structured/#phydrax.nn.ConcatenatedModel.__init__","title":"<code>__init__(models: collections.abc.Sequence[phydrax.nn.models.core._base._AbstractBaseModel], *, axis: int = -1)</code>","text":""},{"location":"api/nn/structured/#phydrax.nn.ConcatenatedModel.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Evaluate all child models at <code>x</code> and concatenate their outputs.</p> <p>If more than one model is present, the input <code>key</code> is split so each child receives its own subkey.</p>"},{"location":"api/nn/wrappers/","title":"Wrappers","text":"<p>Composable model transforms that add structure or change output interpretation.</p> <p>Note</p> <p>Key notes:</p> <ul> <li><code>EquinoxModel</code> / <code>EquinoxStructuredModel</code> adapt arbitrary Equinox/JAX callables into Phydrax models by attaching <code>in_size</code> / <code>out_size</code>.</li> <li><code>ComplexOutputModel</code> packs/unpacks real/imag parts into complex outputs.</li> </ul>"},{"location":"api/nn/wrappers/#equinox-adapters","title":"Equinox adapters","text":"<p>Use these wrappers when you already have an <code>equinox.Module</code> (or any JAX callable) and want it to participate in Phydrax's solver/training APIs.</p> <p><code>layout=\"value\"</code> (default for <code>EquinoxModel</code>) treats <code>in_size/out_size</code> as the value shape of a single (unbatched) sample. Inputs are flattened to a vector, the wrapped module is called, and outputs are reshaped back to the declared value shape.</p> <pre><code>import equinox as eqx\nimport jax\nimport jax.numpy as jnp\nimport jax.random as jr\nimport phydrax as phx\n\nkey = jr.key(0)\n\nmlp = eqx.nn.MLP(\n    in_size=4,\n    out_size=6,\n    width_size=64,\n    depth=2,\n    activation=jax.nn.tanh,\n    key=key,\n)\n\n# Declare value shapes: 2\u00d72 -&gt; 3\u00d72 (both flatten to lengths 4 and 6 internally).\nmodel = phx.nn.EquinoxModel(mlp, in_size=(2, 2), out_size=(3, 2))\n\nx = jnp.zeros((2, 2))\ny = model(x, key=key)\nassert y.shape == (3, 2)\n</code></pre> <p><code>layout=\"passthrough\"</code> forwards inputs/outputs unchanged (the wrapper only supplies metadata). This is useful if your wrapped module already owns its input/output layout.</p> <pre><code>import equinox as eqx\nimport jax.numpy as jnp\nimport jax.random as jr\nimport phydrax as phx\n\nkey = jr.key(0)\n\ndrop = eqx.nn.Dropout(p=0.1)\nmodel = phx.nn.EquinoxModel(drop, in_size=4, out_size=4, layout=\"passthrough\")\n\nx = jnp.zeros((4,))\ny = model(x, key=key, inference=True)\n</code></pre> <p>For structured inputs (e.g. product domains), use <code>EquinoxStructuredModel</code>. With <code>layout=\"passthrough\"</code> it forwards tuples unchanged:</p> <pre><code>import jax.numpy as jnp\nimport jax.random as jr\nimport phydrax as phx\n\nkey = jr.key(0)\n\ndef stack_pair(inp, *, key=None):\n    del key\n    a, b = inp\n    return jnp.stack([a, b])\n\nmodel = phx.nn.EquinoxStructuredModel(stack_pair, in_size=2, out_size=2, layout=\"passthrough\")\ny = model((1.0, 2.0), key=key)\nassert y.shape == (2,)\n</code></pre> <p>With <code>layout=\"value\"</code>, tuple parts are concatenated into a single vector before calling the wrapped module:</p> <pre><code>import equinox as eqx\nimport jax.numpy as jnp\nimport jax.random as jr\nimport phydrax as phx\n\nkey = jr.key(0)\n\nlin = eqx.nn.Linear(in_features=5, out_features=4, key=key)\nmodel = phx.nn.EquinoxStructuredModel(lin, in_size=5, out_size=4, layout=\"value\")\n\nx = (jnp.ones((2,)), jnp.ones((3,)))\ny = model(x, key=key)\nassert y.shape == (4,)\n</code></pre> <p>Note</p> <ul> <li>These wrappers are pointwise by default; use <code>jax.vmap</code> for batching.</li> <li><code>iter_=</code> is accepted for interface compatibility but is not forwarded to the wrapped callable.</li> </ul>"},{"location":"api/nn/wrappers/#phydrax.nn.EquinoxModel","title":"<code>phydrax.nn.EquinoxModel</code>","text":"<p>Adapter for arbitrary Equinox/JAX callables with Phydrax model metadata.</p> <p>Default <code>layout=\"value\"</code> treats <code>in_size/out_size</code> as value shapes and performs: (flatten value axes) -&gt; (call wrapped module) -&gt; (reshape back to value axes).</p> <p>Use <code>layout=\"passthrough\"</code> to forward inputs/outputs unchanged.</p>"},{"location":"api/nn/wrappers/#phydrax.nn.EquinoxModel.__init__","title":"<code>__init__(module: Any, /, *, in_size: SizeLike, out_size: SizeLike, layout: _Layout = 'value')</code>","text":""},{"location":"api/nn/wrappers/#phydrax.nn.EquinoxModel.__call__","title":"<code>__call__(x: Array, /, *, key: Key[Array, ''] = jr.key(0), iter_: Array | None = None, **kwargs: Any) -&gt; Array</code>","text":""},{"location":"api/nn/wrappers/#phydrax.nn.EquinoxStructuredModel","title":"<code>phydrax.nn.EquinoxStructuredModel</code>","text":"<p>Equinox/JAX callable adapter that supports structured (tuple) inputs.</p>"},{"location":"api/nn/wrappers/#phydrax.nn.EquinoxStructuredModel.__init__","title":"<code>__init__(module: Any, /, *, in_size: SizeLike, out_size: SizeLike, layout: _Layout = 'passthrough')</code>","text":""},{"location":"api/nn/wrappers/#phydrax.nn.EquinoxStructuredModel.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0), iter_: Array | None = None, **kwargs: Any) -&gt; Array</code>","text":""},{"location":"api/nn/wrappers/#model-transforms","title":"Model transforms","text":""},{"location":"api/nn/wrappers/#phydrax.nn.MagnitudeDirectionModel","title":"<code>phydrax.nn.MagnitudeDirectionModel</code>","text":"<p>Combine a magnitude model and a direction model.</p> <p>Given a scalar magnitude \\(m(x)\\) and a direction field \\(d(x)\\), returns</p> \\[ y(x)=m(x)\\,\\frac{d(x)}{\\|d(x)\\|}. \\] <p>If <code>direction_model.out_size == \"scalar\"</code>, no normalization is applied.</p>"},{"location":"api/nn/wrappers/#phydrax.nn.MagnitudeDirectionModel.__init__","title":"<code>__init__(magnitude_model: _AbstractBaseModel, direction_model: _AbstractBaseModel)</code>","text":""},{"location":"api/nn/wrappers/#phydrax.nn.MagnitudeDirectionModel.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Evaluate \\(y(x)=m(x)\\,\\frac{d(x)}{\\|d(x)\\|}\\).</p> <p>Uses a safe normalization \\(\\|d\\|_\\text{safe}=\\mathop{\\text{max}}(\\|d\\|,1)\\) to avoid division by zero. If <code>direction_model.out_size == \"scalar\"</code>, the normalization is skipped.</p>"},{"location":"api/nn/wrappers/#phydrax.nn.ComplexOutputModel","title":"<code>phydrax.nn.ComplexOutputModel</code>","text":"<p>Wrap model(s) and return complex outputs.</p> <p>Two modes: - Single model with real output size \\(2k\\): split the last axis into   \\((\\Re z,\\Im z)\\) and return \\(z=\\Re z + i\\,\\Im z\\). - Pair <code>(real_model, imag_model)</code> with real output size \\(k\\): return   \\(z=u_{\\text{re}}+i\\,u_{\\text{im}}\\).</p> <p>If \\(k=1\\) / <code>\"scalar\"</code>, returns complex scalars (squeezes a trailing unit feature axis).</p>"},{"location":"api/nn/wrappers/#phydrax.nn.ComplexOutputModel.__init__","title":"<code>__init__(model_or_models: phydrax.nn.models.core._base._AbstractBaseModel | tuple[phydrax.nn.models.core._base._AbstractBaseModel, phydrax.nn.models.core._base._AbstractBaseModel])</code>","text":""},{"location":"api/nn/wrappers/#phydrax.nn.ComplexOutputModel.__call__","title":"<code>__call__(x: Array | tuple[Array, ...], /, *, key: Key[Array, ''] = jr.key(0)) -&gt; Array</code>","text":"<p>Evaluate the wrapped model(s) and return complex outputs.</p> <ul> <li>Single-model mode: if the wrapped model returns \\([u_{\\text{re}},u_{\\text{im}}]\\)   (feature axis size \\(2k\\)), this returns \\(u_{\\text{re}}+i\\,u_{\\text{im}}\\).</li> <li>Two-model mode: returns \\(u_{\\text{re}}(x)+i\\,u_{\\text{im}}(x)\\).</li> </ul>"},{"location":"api/operators/","title":"Operators","text":"<p>Operators build PDE terms such as gradients, divergences, Laplacians, and integrals.</p>"},{"location":"api/operators/#families","title":"Families","text":"<ul> <li>Differential: \\(\\nabla u\\), \\(\\nabla\\cdot v\\), \\(\\Delta u\\), surface and fractional operators.</li> <li>Integral: \\(\\int_\\Omega u\\,d\\Omega\\), means, quadrature helpers, and convolution.</li> <li>Functional: norms, inner products, and averages.</li> <li>Linear algebra: determinants, traces, norms, and <code>einsum</code>-style contractions.</li> <li>Delay: delay operators for time-dependent fields.</li> </ul> <p>Note</p> <p>Rich mathematical guides:</p> <ul> <li>Differential operators</li> <li>Integrals and measures</li> </ul>"},{"location":"api/operators/delay/","title":"Delay operators","text":""},{"location":"api/operators/delay/#phydrax.operators.delay_operator","title":"<code>phydrax.operators.delay_operator(u: DomainFunction, /, tau: DomainFunction | ArrayLike, *, time_var: str = 't', clip_time_min: float | None = None) -&gt; DomainFunction</code>","text":"<p>Delay operator along a labeled time coordinate.</p> <p>Defines a new function \\(v\\) by shifting the time-like coordinate:</p> \\[ v(t) = (\\mathcal{D}_\\tau u)(t) = u(t-\\tau), \\] <p>where \\(\\tau\\) can be a constant or a <code>DomainFunction</code> (allowing spatially varying delays).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function \\(u\\).</li> <li><code>tau</code>: Delay \\(\\tau\\) (constant or <code>DomainFunction</code>).</li> <li><code>time_var</code>: Label of the time coordinate (default <code>\"t\"</code>).</li> <li><code>clip_time_min</code>: Optional lower bound for the delayed time; if set, uses   <code>t_delayed = max(t - tau, clip_time_min)</code> to avoid evaluating before a minimum   time (e.g. before the interval start).</li> </ul>"},{"location":"api/operators/differential/","title":"Differential operators","text":"<p>Note</p> <p>For a more detailed mathematical guide (notation, shapes, and backend behavior), see Guides \u2192 Differential operators.</p>"},{"location":"api/operators/differential/#backends-ad-jet-fd-basis","title":"Backends (AD / jet / FD / basis)","text":"<p>Many differential operators accept a <code>backend</code> keyword:</p> <ul> <li><code>backend=\"ad\"</code>: autodiff (works for point batches and coord-separable batches).</li> <li><code>backend=\"jet\"</code>: Taylor-mode AD (\"jets\") for higher-order derivatives with respect to a single variable.   See the guide for mathematical details (including Fa\u00e0 di Bruno / Bell polynomial structure).</li> <li><code>backend=\"fd\"</code>: finite differences on coord-separable grids (falls back to AD on point batches).   Use <code>periodic=True</code> for periodic stencils.</li> <li><code>backend=\"basis\"</code>: basis-aware methods on coord-separable grids (falls back to AD on point batches).   The <code>basis</code> keyword selects a 1D method per axis:</li> <li><code>basis=\"fourier\"</code>: FFT-based spectral derivatives on periodic grids,</li> <li><code>basis=\"sine\"</code> / <code>basis=\"cosine\"</code>: FFT-based spectral derivatives via odd/even extension     (sine \\(\\leftrightarrow\\) odd extension, cosine \\(\\leftrightarrow\\) even extension),</li> <li><code>basis=\"poly\"</code>: polynomial (barycentric) derivatives for generic 1D grids.</li> </ul> <p>Note</p> <p>FFT-based bases (<code>fourier</code>/<code>sine</code>/<code>cosine</code>) assume a uniformly-spaced coordinate axis. For non-uniform axes, prefer <code>basis=\"poly\"</code> or <code>backend=\"ad\"</code>.</p>"},{"location":"api/operators/differential/#common-keyword-arguments","title":"Common keyword arguments","text":"<p>Many operators share these keywords:</p> <ul> <li><code>var</code>: label to differentiate with respect to (e.g. <code>\"x\"</code> or <code>\"t\"</code>). If omitted, the variable   is inferred when possible.</li> <li><code>mode</code>: autodiff mode (<code>\"reverse\"</code> uses <code>jax.jacrev</code>, <code>\"forward\"</code> uses <code>jax.jacfwd</code>) for AD-based paths.</li> <li><code>backend</code>: <code>\"ad\"</code>, <code>\"jet\"</code>, <code>\"fd\"</code>, or <code>\"basis\"</code> (see above).</li> <li><code>basis</code>: basis method used when <code>backend=\"basis\"</code>.</li> <li><code>periodic</code>: periodic treatment for FD stencils (used when <code>backend=\"fd\"</code>).</li> </ul> <p>See the guide for operator shape conventions and for the math behind surface and fractional operators.</p>"},{"location":"api/operators/differential/#core-derivatives","title":"Core derivatives","text":""},{"location":"api/operators/differential/#phydrax.operators.grad","title":"<code>phydrax.operators.grad(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Gradient/Jacobian of <code>u</code> with respect to a labeled variable.</p> <p>For a geometry variable \\(x\\in\\mathbb{R}^d\\) this constructs \\(\\nabla_x u\\). Concretely:</p> <p>If \\(u:\\Omega\\to\\mathbb{R}\\) is scalar-valued, then <code>grad(u)</code> returns a vector field in \\(\\mathbb{R}^d\\):</p> \\[ \\nabla_x u = \\left(\\frac{\\partial u}{\\partial x_1},\\dots,\\frac{\\partial u}{\\partial x_d}\\right). \\] <p>If \\(u:\\Omega\\to\\mathbb{R}^m\\) is vector-valued, then <code>grad(u)</code> returns the Jacobian \\(J\\in\\mathbb{R}^{m\\times d}\\) with entries \\(J_{ij}=\\partial u_i/\\partial x_j\\).</p> <p>For a scalar domain variable (e.g. time \\(t\\)), this reduces to the partial derivative \\(\\partial u/\\partial t\\).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function.</li> <li><code>var</code>: Variable label to differentiate with respect to. If <code>None</code>, then the   domain must have exactly one differentiable variable.</li> <li><code>mode</code>: Autodiff mode: <code>\"reverse\"</code> uses <code>jax.jacrev</code>, <code>\"forward\"</code> uses <code>jax.jacfwd</code>.</li> <li><code>backend</code>: Differentiation backend.</li> <li><code>\"ad\"</code>: autodiff (works for point batches and coord-separable batches).</li> <li><code>\"fd\"</code>: finite differences on coord-separable grids (falls back to <code>\"ad\"</code>).</li> <li><code>\"basis\"</code>: spectral/barycentric methods on coord-separable grids (falls back to <code>\"ad\"</code>).</li> <li><code>basis</code>: Basis method used when <code>backend=\"basis\"</code>.</li> <li><code>periodic</code>: Whether to treat the differentiated axis as periodic (used by <code>backend=\"fd\"</code>).</li> </ul> <p>Notes:</p> <ul> <li>Coord-separable inputs (tuples of 1D coordinate arrays) are handled by taking JVPs   along each coordinate axis and stacking.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the gradient/Jacobian. For geometry variables,   the derivative axis is appended on the right:</li> <li>scalar \\(u\\): <code>grad(u)</code> has trailing shape <code>(..., d)</code>;</li> <li>vector-valued \\(u\\) with trailing size \\(m\\): trailing shape <code>(..., m, d)</code>.</li> </ul> <p>Example:</p> <pre><code>import phydrax as phx\n\ngeom = phx.domain.Interval1d(0.0, 1.0)\n\n@geom.Function(\"x\")\ndef u(x):\n    return x[0] ** 2\n\ndu = phx.operators.grad(u, var=\"x\")\n</code></pre>"},{"location":"api/operators/differential/#phydrax.operators.div","title":"<code>phydrax.operators.div(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Divergence of a vector field.</p> <p>For a vector field \\(u:\\Omega\\to\\mathbb{R}^d\\), returns</p> \\[ \\nabla\\cdot u = \\sum_{i=1}^{d}\\frac{\\partial u_i}{\\partial x_i}. \\] <p>The input is expected to be vector-valued with last axis size \\(d\\) (the geometry dimension for <code>var</code>). If the value has additional leading axes (e.g. multiple vector fields stacked), divergence is applied componentwise over those axes.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Vector field to differentiate.</li> <li><code>var</code>: Geometry variable label. If <code>None</code>, the domain must have exactly one   geometry variable.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>grad(u, ...)</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\nabla\\cdot u\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.curl","title":"<code>phydrax.operators.curl(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Curl of a 3D vector field.</p> <p>For \\(u:\\Omega\\to\\mathbb{R}^3\\), returns \\(\\nabla\\times u\\):</p> \\[ \\nabla\\times u = \\begin{pmatrix}   \\partial_y u_z - \\partial_z u_y \\\\   \\partial_z u_x - \\partial_x u_z \\\\   \\partial_x u_y - \\partial_y u_x \\end{pmatrix}. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Vector field (must be 3D-valued).</li> <li><code>var</code>: Geometry variable label. If <code>None</code>, the domain must have exactly one   geometry variable.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>grad(u, ...)</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\nabla\\times u\\) (vector-valued with trailing size 3).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.hessian","title":"<code>phydrax.operators.hessian(u: DomainFunction, /, *, var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Hessian of <code>u</code> with respect to a labeled variable.</p> <p>For a geometry variable \\(x\\in\\mathbb{R}^d\\) and scalar-valued \\(u\\), this returns the matrix of second derivatives</p> \\[ H_{ij}(x) = \\frac{\\partial^2 u}{\\partial x_i\\,\\partial x_j}. \\] <p>For vector-valued \\(u:\\Omega\\to\\mathbb{R}^m\\), the Hessian is taken componentwise, producing a trailing shape <code>(..., m, d, d)</code>.</p> <p>For a scalar variable (e.g. time \\(t\\)) this reduces to \\(\\partial^2 u/\\partial t^2\\).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function.</li> <li><code>var</code>: Variable label to differentiate with respect to. If <code>None</code>, the domain   must have exactly one differentiable variable.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the Hessian/second derivative.</li> </ul> <p>Example:</p> <pre><code>import phydrax as phx\n\ngeom = phx.domain.Square(center=(0.0, 0.0), side=2.0)\n\n@geom.Function(\"x\")\ndef u(x):\n    return x[0] ** 2 + x[1] ** 2\n\nH = phx.operators.hessian(u, var=\"x\")\n</code></pre>"},{"location":"api/operators/differential/#phydrax.operators.laplacian","title":"<code>phydrax.operators.laplacian(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'jet', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Laplacian of a scalar field with respect to a geometry variable.</p> <p>For \\(u:\\Omega\\to\\mathbb{R}\\) and \\(x\\in\\mathbb{R}^d\\), this returns</p> \\[ \\Delta u \\;=\\; \\nabla\\cdot\\nabla u \\;=\\; \\sum_{i=1}^{d}\\frac{\\partial^2 u}{\\partial x_i^2}. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Input function (typically scalar-valued).</li> <li><code>var</code>: Geometry label to differentiate with respect to. If <code>None</code>, the domain   must have exactly one geometry variable.</li> <li><code>mode</code>: Autodiff mode for Jacobian/Hessian construction when applicable.</li> <li><code>backend</code>: Differentiation backend:</li> <li><code>\"ad\"</code>: uses nested autodiff (<code>grad(grad(u))</code>).</li> <li><code>\"jet\"</code>: uses JAX Jet expansions for second directional derivatives.</li> <li><code>\"fd\"</code>: uses finite differences on coord-separable grids (falls back to <code>\"ad\"</code>).</li> <li><code>\"basis\"</code>: uses spectral/barycentric methods on coord-separable grids (falls back to <code>\"ad\"</code>).</li> <li><code>basis</code>: Basis method used when <code>backend=\"basis\"</code>.</li> <li><code>periodic</code>: Whether to treat differentiated axes as periodic (used by <code>backend=\"fd\"</code>).</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\Delta u\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.bilaplacian","title":"<code>phydrax.operators.bilaplacian(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'jet', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Bi-Laplacian of a scalar field with respect to a geometry variable.</p> <p>Returns the fourth-order operator</p> \\[ \\Delta^2 u = \\Delta(\\Delta u). \\] <p>The <code>backend</code> options match <code>laplacian</code>.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function (typically scalar-valued).</li> <li><code>var</code>: Geometry label to differentiate with respect to. If <code>None</code>, the domain   must have exactly one geometry variable.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: As in <code>laplacian</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\Delta^2 u\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.dt","title":"<code>phydrax.operators.dt(u: DomainFunction, /, *, var: str = 't', mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Alias for \\(\\partial u/\\partial t\\) (<code>partial_t</code>).</p>"},{"location":"api/operators/differential/#phydrax.operators.dt_n","title":"<code>phydrax.operators.dt_n(u: DomainFunction, /, *, var: str = 't', order: int, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'jet'] = 'ad') -&gt; DomainFunction</code>","text":"<p>Nth time derivative \\(\\partial^n u/\\partial t^n\\).</p> <p>This is a thin wrapper around <code>partial_n(u, var=time_var, axis=None, order=n, ...)</code>.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function.</li> <li><code>var</code>: Time label.</li> <li><code>order</code>: Derivative order \\(n\\ge 0\\).</li> <li><code>mode</code>: Autodiff mode used when <code>backend=\"ad\"</code>.</li> <li><code>backend</code>: <code>\"ad\"</code> (repeated application) or <code>\"jet\"</code> (Jet expansions for \\(n\\ge 2\\)).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.directional_derivative","title":"<code>phydrax.operators.directional_derivative(u: DomainFunction, v: DomainFunction, /, *, var: str = 'x', mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Directional derivative of <code>u</code> along a direction field <code>v</code>.</p> <p>For a geometry variable \\(x\\in\\mathbb{R}^d\\), this computes</p> \\[ D_v u \\;=\\; v\\cdot\\nabla_x u, \\] <p>where \\(v=v(x)\\) is a vector field and \\(\\nabla_x u\\) is computed by <code>grad</code>.</p> <p>If \\(u\\) is vector- or tensor-valued, the directional derivative is applied componentwise, i.e. \\(D_v u\\) has the same value shape as \\(u\\).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function.</li> <li><code>v</code>: Direction field (must be vector-valued with trailing size \\(d\\) for <code>var</code>).</li> <li><code>var</code>: Geometry label to differentiate with respect to (must be a geometry variable).</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>grad(u, ...)</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(D_v u\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.material_derivative","title":"<code>phydrax.operators.material_derivative(u: DomainFunction, v: DomainFunction, /, *, spatial_var: str = 'x', time_var: str = 't', mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Material derivative (advective derivative) of a field.</p> <p>Given a velocity field \\(v(x,t)\\), the material derivative is</p> \\[ \\frac{D u}{D t} = \\frac{\\partial u}{\\partial t} + v\\cdot\\nabla_x u. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Field to differentiate.</li> <li><code>v</code>: Velocity field (vector-valued over <code>spatial_var</code>).</li> <li><code>spatial_var</code>: Geometry label (default <code>\"x\"</code>).</li> <li><code>time_var</code>: Time label (default <code>\"t\"</code>).</li> <li><code>mode</code>: Autodiff mode used by <code>dt</code> and <code>directional_derivative</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.partial_t","title":"<code>phydrax.operators.partial_t(u: DomainFunction, /, *, var: str = 't', mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Convenience wrapper for \\(\\partial u/\\partial t\\) (scalar variable <code>var</code>).</p> <p>Equivalent to <code>partial(u, var=var, axis=None, mode=mode)</code>.</p>"},{"location":"api/operators/differential/#phydrax.operators.partial_x","title":"<code>phydrax.operators.partial_x(u: DomainFunction, /, *, var: str = 'x', mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Convenience wrapper for \\(\\partial u/\\partial x\\) (axis 0 of geometry variable <code>var</code>).</p> <p>Equivalent to <code>partial(u, var=var, axis=0, mode=mode)</code>.</p>"},{"location":"api/operators/differential/#phydrax.operators.partial_y","title":"<code>phydrax.operators.partial_y(u: DomainFunction, /, *, var: str = 'x', mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Convenience wrapper for \\(\\partial u/\\partial y\\) (axis 1 of geometry variable <code>var</code>).</p> <p>Equivalent to <code>partial(u, var=var, axis=1, mode=mode)</code>.</p>"},{"location":"api/operators/differential/#phydrax.operators.partial_z","title":"<code>phydrax.operators.partial_z(u: DomainFunction, /, *, var: str = 'x', mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Convenience wrapper for \\(\\partial u/\\partial z\\) (axis 2 of geometry variable <code>var</code>).</p> <p>Equivalent to <code>partial(u, var=var, axis=2, mode=mode)</code>.</p>"},{"location":"api/operators/differential/#phydrax.operators.partial_n","title":"<code>phydrax.operators.partial_n(u: DomainFunction, /, *, var: str, axis: int | None = None, order: int, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'jet', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Nth partial derivative with respect to a labeled variable.</p> <p>Computes \\(\\partial^n u / \\partial x_i^n\\) (for geometry variables with <code>axis=i</code>) or \\(\\partial^n u / \\partial t^n\\) (for scalar variables).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function.</li> <li><code>var</code>: Variable label to differentiate with respect to.</li> <li><code>axis</code>: For geometry variables, which coordinate axis \\(i\\) to differentiate along.   For scalar variables, must be <code>None</code>.</li> <li><code>order</code>: Derivative order \\(n\\ge 0\\).</li> <li><code>mode</code>: Autodiff mode used when <code>backend=\"ad\"</code>.</li> <li><code>backend</code>:</li> <li><code>\"ad\"</code>: repeated application of <code>partial</code>.</li> <li><code>\"jet\"</code>: uses Jet expansions for \\(n\\ge 2\\) (point inputs and coord-separable inputs).</li> <li><code>\"fd\"</code>: finite differences on coord-separable grids (falls back to <code>\"ad\"</code> for point inputs).</li> <li><code>\"basis\"</code>: spectral/barycentric methods on coord-separable grids (falls back to <code>\"ad\"</code> for point inputs).</li> <li><code>basis</code>: Basis method used when <code>backend=\"basis\"</code>.</li> <li><code>periodic</code>: Whether to treat the differentiated axis as periodic (used by <code>backend=\"fd\"</code>).</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the requested \\(n\\)th partial derivative.</li> </ul>"},{"location":"api/operators/differential/#surface-operators","title":"Surface operators","text":""},{"location":"api/operators/differential/#phydrax.operators.surface_grad","title":"<code>phydrax.operators.surface_grad(u: DomainFunction, component: DomainComponent, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Surface (tangential) gradient on a boundary component.</p> <p>Let \\(n\\) be the outward unit normal and \\(P = I - n\\otimes n\\) the tangential projector. For a scalar field \\(u\\), the surface gradient is</p> \\[ \\nabla_{\\Gamma} u = P\\,\\nabla u. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Field to differentiate (typically scalar-valued).</li> <li><code>component</code>: Boundary <code>DomainComponent</code> used to supply the unit normal field.</li> <li><code>var</code>: Geometry label for the boundary variable.</li> <li><code>mode</code>: Autodiff mode passed to <code>grad</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\nabla_\\Gamma u\\) (tangential vector field).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.surface_div","title":"<code>phydrax.operators.surface_div(v: DomainFunction, component: DomainComponent, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Surface (tangential) divergence on a boundary component.</p> <p>With tangential projector \\(P = I - n\\otimes n\\), this implements</p> \\[ \\nabla_{\\Gamma}\\cdot v = \\text{tr}(P\\,\\nabla v), \\] <p>where \\(\\nabla v\\) is the Jacobian of \\(v\\) with respect to the ambient coordinates.</p> <p>Arguments:</p> <ul> <li><code>v</code>: Tangential or ambient vector field.</li> <li><code>component</code>: Boundary <code>DomainComponent</code> used to supply the unit normal field.</li> <li><code>var</code>: Geometry label for the boundary variable.</li> <li><code>mode</code>: Autodiff mode passed to <code>grad</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\nabla_\\Gamma\\cdot v\\) (scalar field).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.surface_curl_scalar","title":"<code>phydrax.operators.surface_curl_scalar(u: DomainFunction, component: DomainComponent, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Surface curl of a scalar field on a 3D surface.</p> <p>For a scalar field \\(u\\) on a surface in \\(\\mathbb{R}^3\\), returns the tangential vector field</p> \\[ \\text{curl}_{\\Gamma} u = n \\times \\nabla_{\\Gamma} u. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Scalar field on the surface.</li> <li><code>component</code>: Boundary <code>DomainComponent</code> used to supply the unit normal field.</li> <li><code>var</code>: Geometry label (must be 3D).</li> <li><code>mode</code>: Autodiff mode used by <code>surface_grad</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the tangential vector field \\(\\text{curl}_\\Gamma u\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.surface_curl_vector","title":"<code>phydrax.operators.surface_curl_vector(v: DomainFunction, component: DomainComponent, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Surface curl of a vector field on a 3D surface.</p> <p>For a vector field \\(v\\) on a surface in \\(\\mathbb{R}^3\\), returns the scalar</p> \\[ \\text{curl}_{\\Gamma} v = n \\cdot (\\nabla \\times v). \\] <p>Arguments:</p> <ul> <li><code>v</code>: Vector field on the surface.</li> <li><code>component</code>: Boundary <code>DomainComponent</code> used to supply the unit normal field.</li> <li><code>var</code>: Geometry label (must be 3D).</li> <li><code>mode</code>: Autodiff mode used by <code>curl</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the scalar surface curl \\(\\text{curl}_\\Gamma v\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.tangential_component","title":"<code>phydrax.operators.tangential_component(w: DomainFunction, component: DomainComponent, /, *, var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Project a vector field onto the local tangent space.</p> <p>Given a unit normal field \\(n(x)\\) on a boundary component, the tangential projection of a vector field \\(w\\) is</p> \\[ w_{\\tau} = w - (w\\cdot n)\\,n. \\] <p>Arguments:</p> <ul> <li><code>w</code>: Vector field to project (trailing size = ambient dimension).</li> <li><code>component</code>: Boundary <code>DomainComponent</code> used to supply the unit normal field.</li> <li><code>var</code>: Geometry label for the boundary variable (defaults to inferred geometry label).</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the tangential projection \\(w_\\tau\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.laplace_beltrami","title":"<code>phydrax.operators.laplace_beltrami(u: DomainFunction, component: DomainComponent, /, *, var: str | None = None, curvature_aware: bool = False, variant: Literal['contraction', 'divgrad'] | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Laplace\u2013Beltrami operator on a boundary component.</p> <p>The Laplace\u2013Beltrami operator \\(\\Delta_{\\Gamma}\\) is the surface analogue of the Laplacian. Two common realizations are supported:</p> <ul> <li>projection\u2013contraction form (default): \\(\\Delta_{\\Gamma} u \\approx \\text{tr}(P\\,\\nabla^2 u\\,P)\\);</li> <li>divergence-of-surface-gradient (via <code>variant=\"divgrad\"</code>): \\(\\Delta_{\\Gamma} u =   \\nabla_{\\Gamma}\\cdot\\nabla_{\\Gamma}u\\).</li> </ul> <p>The <code>curvature_aware=True</code> option selects the <code>divgrad</code> variant by default.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Field to differentiate.</li> <li><code>component</code>: Boundary <code>DomainComponent</code> used to supply the unit normal field.</li> <li><code>var</code>: Geometry label.</li> <li><code>curvature_aware</code>: If <code>True</code>, defaults to <code>variant=\"divgrad\"</code>.</li> <li><code>variant</code>: <code>\"contraction\"</code> (projection\u2013contraction) or <code>\"divgrad\"</code>.</li> <li><code>mode</code>: Autodiff mode used by the underlying <code>grad</code>/<code>surface_grad</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\Delta_\\Gamma u\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.laplace_beltrami_divgrad","title":"<code>phydrax.operators.laplace_beltrami_divgrad(u: DomainFunction, component: DomainComponent, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Laplace\u2013Beltrami operator via surface divergence of the surface gradient.</p> <p>Implements</p> \\[ \\Delta_{\\Gamma} u = \\nabla_{\\Gamma}\\cdot(\\nabla_{\\Gamma}u). \\] <p>Arguments:</p> <ul> <li><code>u</code>: Field to differentiate.</li> <li><code>component</code>: Boundary <code>DomainComponent</code>.</li> <li><code>var</code>: Geometry label.</li> <li><code>mode</code>: Autodiff mode used by <code>surface_grad</code>/<code>surface_div</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\Delta_\\Gamma u\\).</li> </ul>"},{"location":"api/operators/differential/#fractional-derivatives","title":"Fractional derivatives","text":""},{"location":"api/operators/differential/#phydrax.operators.fractional_laplacian","title":"<code>phydrax.operators.fractional_laplacian(u: DomainFunction, /, *, alpha: float, var: str | None = None, radius: float | None = None, num_points: int = 4096, eps: float = 1e-06, desingularize: bool = False, angular_points: int | None = None) -&gt; DomainFunction</code>","text":"<p>Fractional Laplacian via a truncated ball quadrature estimator.</p> <p>The (spectral/integral) fractional Laplacian in \\(\\mathbb{R}^d\\) admits an integral representation (up to a normalization constant \\(C_{d,\\alpha}\\)):</p> \\[ (-\\Delta)^{\\alpha/2}u(x) \\propto \\int_{\\mathbb{R}^d}\\frac{u(x)-u(y)}{\\|x-y\\|^{d+\\alpha}}\\,dy, \\qquad 0&lt;\\alpha&lt;2. \\] <p>This implementation uses a truncated ball integral with radius <code>radius</code> and a Monte Carlo-style quadrature rule on offsets \\(y=x+\\xi\\):</p> \\[ \\int_{B_R(0)} \\frac{u(x)-u(x+\\xi)}{\\|\\xi\\|^{d+\\alpha}}\\,d\\xi. \\] <p>This routine returns a quantity proportional to \\((-\\Delta)^{\\alpha/2}u\\); it does not apply the normalization constant \\(C_{d,\\alpha}\\) and truncates the integral to a finite ball.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function \\(u\\).</li> <li><code>alpha</code>: Fractional order \\(\\alpha\\in(0,2)\\).</li> <li><code>var</code>: Geometry label to apply the operator to. If <code>None</code>, Phydrax infers a   differentiable geometry label when possible.</li> <li><code>radius</code>: Truncation radius \\(R\\) (defaults to an AABB-derived scale).</li> <li><code>num_points</code>: Number of ball quadrature offsets.</li> <li><code>eps</code>: Excludes offsets with \\(\\|\\xi\\|\\le \\varepsilon\\) to avoid the singularity.</li> <li><code>desingularize</code>: If <code>True</code> and \\(\\alpha&gt;1\\), subtracts a first-order correction   term involving \\(\\nabla u\\) to reduce variance.</li> <li><code>angular_points</code>: Reserved for future deterministic angular quadrature; currently unused.</li> </ul> <p>Returns:</p> <p>A <code>DomainFunction</code> representing the (truncated, unnormalized) fractional Laplacian.</p>"},{"location":"api/operators/differential/#phydrax.operators.fractional_derivative_gl_mc","title":"<code>phydrax.operators.fractional_derivative_gl_mc(u: DomainFunction, /, *, alpha: float, side: Literal['left', 'right'] = 'right', axis: int = 0, N: int = 100, K: int = 1, x_lb: float | None = None, x_ub: float | None = None, sampler: str = 'sobol_scrambled', caputo: bool = False, var: str | None = None, time_var: str | None = 't') -&gt; DomainFunction</code>","text":"<p>Gr\u00fcnwald\u2013Letnikov fractional derivative (Monte Carlo / GMC estimator).</p> <p>For \\(\\alpha\\in(1,2)\\), the Gr\u00fcnwald\u2013Letnikov derivative can be viewed as a limit of weighted finite differences. This routine implements a Monte Carlo / generalized Monte Carlo (GMC) estimator for left- or right-sided fractional derivatives along a chosen spatial axis.</p> <p>The derivative is taken with respect to a geometry variable <code>var</code> along coordinate axis <code>axis</code>, using bounds <code>x_lb</code>/<code>x_ub</code> to define the one-sided interval.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input <code>DomainFunction</code> \\(u\\).</li> <li><code>alpha</code>: Order \\(\\alpha\\in(1,2)\\).</li> <li><code>side</code>: <code>\"left\"</code> or <code>\"right\"</code>.</li> <li><code>axis</code>: Spatial axis within <code>var</code> used for the one-sided derivative.</li> <li><code>N</code>: Number of sub-intervals used to define the step size \\(h\\).</li> <li><code>K</code>: Sample multiplier; total Monte Carlo samples is <code>N * K</code>.</li> <li><code>x_lb</code>: Left bound (required when <code>side=\"left\"</code>).</li> <li><code>x_ub</code>: Right bound (required when <code>side=\"right\"</code>).</li> <li><code>sampler</code>: Sampler name for drawing the GMC random variates.</li> <li><code>caputo</code>: If <code>True</code>, uses a Caputo-style correction.</li> <li><code>var</code>: Geometry label to differentiate with respect to (defaults to an inferred geometry label).</li> <li><code>time_var</code>: Optional time label; when present in <code>u.deps</code>, the derivative is   conditioned on the current time coordinate.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.riesz_fractional_derivative_gl_mc","title":"<code>phydrax.operators.riesz_fractional_derivative_gl_mc(u: DomainFunction, /, *, beta: float, bounds: Sequence[tuple[float, float]], N: int = 100, K: int = 1, sampler: str = 'sobol_scrambled', var: str | None = None, time_var: str | None = 't') -&gt; DomainFunction</code>","text":"<p>Riesz fractional derivative assembled from one-sided GL derivatives.</p> <p>For \\(\\beta\\in(1,2)\\), this constructs a Riesz-type fractional derivative by summing left and right Gr\u00fcnwald\u2013Letnikov derivatives along each spatial axis and applying the standard normalization factor:</p> \\[ \\mathcal{D}^{\\beta}u \\propto \\frac{1}{2\\cos(\\pi\\beta/2)}\\sum_{i=1}^{d} \\left(D_{+,i}^{\\beta}u + D_{-,i}^{\\beta}u\\right). \\] <p>The per-axis bounds are provided via <code>bounds</code>.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input <code>DomainFunction</code> \\(u\\).</li> <li><code>beta</code>: Order \\(\\beta\\in(1,2)\\).</li> <li><code>bounds</code>: Sequence of per-axis bounds <code>[(x_lb_0, x_ub_0), ..., (x_lb_{d-1}, x_ub_{d-1})]</code>.</li> <li><code>N</code>: Number of sub-intervals used to define step sizes \\(h\\) per axis.</li> <li><code>K</code>: Sample multiplier; total Monte Carlo samples per one-sided derivative is <code>N * K</code>.</li> <li><code>sampler</code>: Sampler name for drawing the GMC random variates.</li> <li><code>var</code>: Geometry label to differentiate with respect to (defaults to an inferred geometry label).</li> <li><code>time_var</code>: Optional time label; when present in <code>u.deps</code>, the derivative is conditioned on time.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.caputo_time_fractional","title":"<code>phydrax.operators.caputo_time_fractional(u: DomainFunction, /, *, alpha: float, time_var: str = 't', mode: str = 'auto', sampler: str = 'sobol_scrambled', order: int = 64, tau_epsilon: float | str = 'auto', cluster_exponent: float | None = None) -&gt; DomainFunction</code>","text":"<p>Caputo fractional derivative in time.</p> <p>For a time interval starting at \\(t_0\\), the Caputo derivative of order \\(\\alpha\\in(0,2)\\) is defined (for sufficiently smooth \\(u\\)) by</p> <p>For \\(0&lt;\\alpha&lt;1\\):</p> \\[ {}^C D_t^{\\alpha}u(t)=\\frac{1}{\\Gamma(1-\\alpha)}\\int_{t_0}^{t}\\frac{u'(s)}{(t-s)^{\\alpha}}\\,ds; \\] <p>For \\(1&lt;\\alpha&lt;2\\):</p> \\[ {}^C D_t^{\\alpha}u(t)=\\frac{1}{\\Gamma(2-\\alpha)}\\int_{t_0}^{t}\\frac{u''(s)}{(t-s)^{\\alpha-1}}\\,ds. \\] <p>This implementation uses quadrature/Monte Carlo estimators depending on <code>alpha</code> and <code>mode</code>.</p> <p>Arguments:</p> <ul> <li><code>alpha</code>: Fractional order \\(\\alpha\\in(0,2)\\).</li> <li><code>time_var</code>: Time label (must correspond to a scalar domain factor).</li> <li><code>mode</code>: <code>\"auto\"</code> selects a reasonable default; <code>\"gj\"</code> uses Gauss\u2013Jacobi nodes;   <code>\"gl\"</code> uses Gauss\u2013Legendre; other values fall back to sampling.</li> <li><code>order</code>: Number of quadrature/sampling points.</li> <li><code>tau_epsilon</code>: Regularization for the kernel singularity near \\(t=s\\).</li> <li><code>cluster_exponent</code>: Optional clustering of Gauss\u2013Legendre nodes toward \\(t_0\\)   for the \\(0&lt;\\alpha&lt;1\\) branch.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.caputo_time_fractional_dw","title":"<code>phydrax.operators.caputo_time_fractional_dw(u: DomainFunction, /, *, alpha: float, time_var: str = 't', M: int = 128, sampler: str = 'sobol_scrambled', tau_epsilon: float | str = 'auto', mode: str = 'gj') -&gt; DomainFunction</code>","text":"<p>Convenience wrapper for <code>caputo_time_fractional</code> using <code>order=M</code>.</p> <p>Named for a common discretization setting in physics-informed fractional models.</p>"},{"location":"api/operators/differential/#continuum-mechanics","title":"Continuum mechanics","text":""},{"location":"api/operators/differential/#phydrax.operators.deformation_gradient","title":"<code>phydrax.operators.deformation_gradient(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Deformation gradient for a displacement field.</p> <p>For a displacement field \\(u:\\Omega\\to\\mathbb{R}^d\\), the deformation gradient is</p> \\[ F = I + \\nabla u. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field (vector-valued).</li> <li><code>var</code>: Geometry label to differentiate with respect to.</li> <li><code>mode</code>: Autodiff mode passed to <code>grad</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(F\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.green_lagrange_strain","title":"<code>phydrax.operators.green_lagrange_strain(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Green\u2013Lagrange strain tensor.</p> <p>With deformation gradient \\(F=I+\\nabla u\\), the Green\u2013Lagrange strain is</p> \\[ E = \\tfrac12\\left(F^\\top F - I\\right). \\] <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field.</li> <li><code>var</code>: Geometry label to differentiate with respect to.</li> <li><code>mode</code>: Autodiff mode used by <code>deformation_gradient</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(E\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.cauchy_strain","title":"<code>phydrax.operators.cauchy_strain(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Cauchy (small) strain tensor for a displacement/velocity field.</p> <p>For a vector field \\(u:\\Omega\\to\\mathbb{R}^d\\), the small-strain tensor is</p> \\[ \\varepsilon(u) = \\tfrac12\\left(\\nabla u + (\\nabla u)^\\top\\right). \\] <p>Arguments:</p> <ul> <li><code>u</code>: Displacement/velocity field (vector-valued with trailing size \\(d\\)).</li> <li><code>var</code>: Geometry label to differentiate with respect to.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>grad(u, ...)</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\varepsilon(u)\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.strain_rate","title":"<code>phydrax.operators.strain_rate(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Alias for <code>cauchy_strain</code> (common notation \\(D(u)\\) for velocity fields).</p>"},{"location":"api/operators/differential/#phydrax.operators.strain_rate_magnitude","title":"<code>phydrax.operators.strain_rate_magnitude(u: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Magnitude of the strain-rate tensor.</p> <p>With \\(D(u)=\\tfrac12(\\nabla u+(\\nabla u)^\\top)\\), this returns the scalar field</p> \\[ \\|D\\| = \\sqrt{2\\,D{:}D} = \\sqrt{2\\sum_{i,j} D_{ij}^2}. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Velocity field.</li> <li><code>var</code>: Geometry label to differentiate with respect to.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>strain_rate(u, ...)</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\|D(u)\\|\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.pk1_from_pk2","title":"<code>phydrax.operators.pk1_from_pk2(u: DomainFunction, S: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Convert 2nd PK stress to 1st PK stress.</p> <p>With deformation gradient \\(F\\), the first Piola\u2013Kirchhoff stress is</p> \\[ P = F S. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field (used to compute \\(F\\)).</li> <li><code>S</code>: Second PK stress field.</li> <li><code>var</code>: Geometry label.</li> <li><code>mode</code>: Autodiff mode used by <code>deformation_gradient</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(P\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.cauchy_from_pk2","title":"<code>phydrax.operators.cauchy_from_pk2(u: DomainFunction, S: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Convert 2nd PK stress to Cauchy stress.</p> <p>With deformation gradient \\(F\\) and \\(J=\\det F\\), the Cauchy stress is</p> \\[ \\sigma = \\frac{1}{J} F S F^\\top. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field (used to compute \\(F\\)).</li> <li><code>S</code>: Second PK stress field.</li> <li><code>var</code>: Geometry label.</li> <li><code>mode</code>: Autodiff mode used by <code>deformation_gradient</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\sigma\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.cauchy_stress","title":"<code>phydrax.operators.cauchy_stress(u: DomainFunction, /, *, lambda_: DomainFunction | ArrayLike, mu: DomainFunction | ArrayLike, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Linear-elastic Cauchy stress (Hooke's law).</p> \\[ \\sigma(u) = 2\\mu\\,\\varepsilon(u) + \\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\,I. \\] <p>Here \\(\\varepsilon(u)=\\tfrac12(\\nabla u + (\\nabla u)^\\top)\\) is the small-strain tensor, and \\(\\lambda,\\mu\\) are Lam\u00e9 parameters (which may be constants or <code>DomainFunction</code>s).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field (vector-valued).</li> <li><code>lambda_</code>: First Lam\u00e9 parameter \\(\\lambda\\).</li> <li><code>mu</code>: Shear modulus \\(\\mu\\).</li> <li><code>var</code>: Geometry label to differentiate with respect to.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>cauchy_strain(u, ...)</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\sigma(u)\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.viscous_stress","title":"<code>phydrax.operators.viscous_stress(u: DomainFunction, /, *, mu: DomainFunction | ArrayLike, lambda_: DomainFunction | ArrayLike | None = None, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Newtonian viscous stress tensor for a velocity field.</p> <p>Uses the symmetric strain-rate tensor</p> \\[ D(u) = \\tfrac12(\\nabla u + \\nabla u^\\top), \\] <p>and returns</p> \\[ \\tau(u) = 2\\mu\\,D(u) + \\lambda\\,\\text{tr}(D(u))\\,I. \\] <p>If <code>lambda_</code> is not provided, uses Stokes' hypothesis \\(\\lambda=-\\tfrac{2}{3}\\mu\\).</p>"},{"location":"api/operators/differential/#phydrax.operators.von_mises_stress","title":"<code>phydrax.operators.von_mises_stress(sigma: DomainFunction, /, *, var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Von Mises equivalent stress.</p> <p>For deviatoric stress \\(s = \\sigma - \\tfrac{1}{d}\\text{tr}(\\sigma)\\,I\\), returns</p> \\[ \\sigma_{\\text{vm}} = \\sqrt{\\frac{3}{2}\\,s:s}, \\] <p>with a specialized closed form used in 2D.</p> <p>Arguments:</p> <ul> <li><code>sigma</code>: Stress tensor field.</li> <li><code>var</code>: Geometry label used to infer dimension and select the 2D/3D formula.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the scalar von Mises equivalent stress.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.hydrostatic_stress","title":"<code>phydrax.operators.hydrostatic_stress(sigma: DomainFunction, /, *, var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Hydrostatic (spherical) part of a stress tensor.</p> <p>Returns</p> \\[ \\sigma_{\\text{hyd}} = \\frac{\\text{tr}(\\sigma)}{d}\\,I. \\] <p>Arguments:</p> <ul> <li><code>sigma</code>: Stress tensor field.</li> <li><code>var</code>: Geometry label used to infer \\(d\\).</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the hydrostatic stress tensor.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.hydrostatic_pressure","title":"<code>phydrax.operators.hydrostatic_pressure(sigma: DomainFunction, /, *, var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Hydrostatic pressure from a stress tensor.</p> <p>Uses the sign convention</p> \\[ p = -\\frac{1}{d}\\text{tr}(\\sigma). \\] <p>Arguments:</p> <ul> <li><code>sigma</code>: Stress tensor field.</li> <li><code>var</code>: Geometry label used to infer \\(d\\).</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the scalar pressure field \\(p\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.deviatoric_stress","title":"<code>phydrax.operators.deviatoric_stress(sigma: DomainFunction, /, *, var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Deviatoric part of a stress tensor.</p> <p>For a stress tensor \\(\\sigma\\), the deviatoric part is</p> \\[ \\sigma_{\\text{dev}} = \\sigma - \\frac{\\text{tr}(\\sigma)}{d}\\,I. \\] <p>Arguments:</p> <ul> <li><code>sigma</code>: Stress tensor field (trailing shape <code>(d, d)</code>).</li> <li><code>var</code>: Geometry label used to infer \\(d\\).</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\sigma_{\\text{dev}}\\).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.maxwell_stress","title":"<code>phydrax.operators.maxwell_stress(*, E: DomainFunction | None = None, H: DomainFunction | None = None, epsilon: DomainFunction | ArrayLike | None = None, mu: DomainFunction | ArrayLike | None = None) -&gt; DomainFunction</code>","text":"<p>Maxwell stress tensor from electric and/or magnetic fields.</p> <p>For electric field \\(E\\) and magnetic field \\(H\\), the (vacuum-style) Maxwell stress tensor is</p> \\[ T = \\epsilon\\left(E\\otimes E - \\tfrac12\\|E\\|_2^2 I\\right)   + \\mu\\left(H\\otimes H - \\tfrac12\\|H\\|_2^2 I\\right), \\] <p>where \\(\\epsilon\\) and \\(\\mu\\) can be scalars or fields.</p> <p>At least one of <code>E</code> or <code>H</code> must be provided.</p> <p>Arguments:</p> <ul> <li><code>E</code>: Electric field (vector-valued) or <code>None</code>.</li> <li><code>H</code>: Magnetic field (vector-valued) or <code>None</code>.</li> <li><code>epsilon</code>: Permittivity \\(\\epsilon\\) (scalar/field); defaults to 1.</li> <li><code>mu</code>: Permeability \\(\\mu\\) (scalar/field); defaults to 1.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the Maxwell stress tensor \\(T\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.neo_hookean_pk1","title":"<code>phydrax.operators.neo_hookean_pk1(u: DomainFunction, /, *, mu: DomainFunction | ArrayLike, kappa: DomainFunction | ArrayLike, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Compressible neo-Hookean first Piola\u2013Kirchhoff stress.</p> <p>With deformation gradient \\(F = I + \\nabla u\\) and \\(J=\\det F\\), this returns</p> \\[ P = \\mu\\,(F - F^{-T}) + \\kappa\\,\\ln(J)\\,F^{-T}, \\] <p>where \\(\\mu\\) is the shear modulus and \\(\\kappa\\) is the bulk modulus.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field.</li> <li><code>mu</code>: Shear modulus \\(\\mu\\) (constant or <code>DomainFunction</code>).</li> <li><code>kappa</code>: Bulk modulus \\(\\kappa\\) (constant or <code>DomainFunction</code>).</li> <li><code>var</code>: Geometry label.</li> <li><code>mode</code>: Autodiff mode used by <code>deformation_gradient</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the PK1 stress \\(P\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.neo_hookean_cauchy","title":"<code>phydrax.operators.neo_hookean_cauchy(u: DomainFunction, /, *, mu: DomainFunction | ArrayLike, kappa: DomainFunction | ArrayLike, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>Compressible neo-Hookean Cauchy stress.</p> <p>With \\(F = I + \\nabla u\\), \\(J=\\det F\\), and left Cauchy\u2013Green tensor \\(B=FF^\\top\\), this returns</p> \\[ \\sigma = \\frac{\\mu}{J}(B - I) + \\frac{\\kappa\\ln(J)}{J}\\,I. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field.</li> <li><code>mu</code>: Shear modulus \\(\\mu\\).</li> <li><code>kappa</code>: Bulk modulus \\(\\kappa\\).</li> <li><code>var</code>: Geometry label.</li> <li><code>mode</code>: Autodiff mode used by <code>deformation_gradient</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the Cauchy stress \\(\\sigma\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.svk_pk2_stress","title":"<code>phydrax.operators.svk_pk2_stress(u: DomainFunction, /, *, lambda_: DomainFunction | ArrayLike, mu: DomainFunction | ArrayLike, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>St. Venant\u2013Kirchhoff 2nd Piola\u2013Kirchhoff stress.</p> <p>With Green\u2013Lagrange strain \\(E\\), the StVK constitutive law is</p> \\[ S(E) = 2\\mu\\,E + \\lambda\\,\\text{tr}(E)\\,I. \\] <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field.</li> <li><code>lambda_</code>, <code>mu</code>: Lam\u00e9 parameters (constants or <code>DomainFunction</code>s).</li> <li><code>var</code>: Geometry label.</li> <li><code>mode</code>: Autodiff mode used by <code>green_lagrange_strain</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the PK2 stress \\(S\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.linear_elastic_cauchy_stress_2d","title":"<code>phydrax.operators.linear_elastic_cauchy_stress_2d(u: DomainFunction, /, *, E: DomainFunction | ArrayLike, nu: DomainFunction | ArrayLike, mode2d: Literal['plane_stress', 'plane_strain'] = 'plane_stress', var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>2D isotropic linear-elastic Cauchy stress (plane stress/strain).</p> <p>Given Young's modulus \\(E\\) and Poisson ratio \\(\\nu\\), returns the stress tensor \\(\\sigma\\) computed from the small strain tensor \\(\\varepsilon(u)\\) using either:</p> <ul> <li>plane stress, or</li> <li>plane strain,</li> </ul> <p>controlled by <code>mode2d</code>.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field.</li> <li><code>E</code>: Young's modulus \\(E\\) (constant or field).</li> <li><code>nu</code>: Poisson ratio \\(\\nu\\) (constant or field).</li> <li><code>mode2d</code>: <code>\"plane_stress\"</code> or <code>\"plane_strain\"</code>.</li> <li><code>var</code>: Geometry label (must be 2D).</li> <li><code>mode</code>: Autodiff mode used by <code>cauchy_strain</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the 2D Cauchy stress tensor with trailing shape <code>(2, 2)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.linear_elastic_orthotropic_stress_2d","title":"<code>phydrax.operators.linear_elastic_orthotropic_stress_2d(u: DomainFunction, /, *, E1: DomainFunction | ArrayLike, E2: DomainFunction | ArrayLike, nu12: DomainFunction | ArrayLike, G12: DomainFunction | ArrayLike, mode2d: Literal['plane_stress', 'plane_strain'] = 'plane_stress', var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse') -&gt; DomainFunction</code>","text":"<p>2D orthotropic linear-elastic Cauchy stress (plane stress/strain).</p> <p>Uses orthotropic material parameters \\((E_1, E_2, \\nu_{12}, G_{12})\\) and computes the 2D stress response under either plane stress or plane strain assumptions.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Displacement field.</li> <li><code>E1</code>, <code>E2</code>: Orthotropic Young's moduli.</li> <li><code>nu12</code>: Major Poisson ratio.</li> <li><code>G12</code>: In-plane shear modulus.</li> <li><code>mode2d</code>: <code>\"plane_stress\"</code> or <code>\"plane_strain\"</code>.</li> <li><code>var</code>: Geometry label (must be 2D).</li> <li><code>mode</code>: Autodiff mode used by <code>cauchy_strain</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the 2D orthotropic stress tensor with trailing shape <code>(2, 2)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.div_tensor","title":"<code>phydrax.operators.div_tensor(T: DomainFunction, /, *, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Divergence of a second-order tensor field.</p> <p>For a tensor field \\(T:\\Omega\\to\\mathbb{R}^{d\\times d}\\), returns the vector field</p> \\[ (\\nabla\\cdot T)_j = \\sum_{i=1}^{d}\\frac{\\partial T_{ij}}{\\partial x_i}. \\] <p>Arguments:</p> <ul> <li><code>T</code>: Tensor field with trailing shape <code>(d, d)</code> (optionally with extra leading value axes).</li> <li><code>var</code>: Geometry variable label. If <code>None</code>, the domain must have exactly one   geometry variable.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>grad(T, ...)</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\nabla\\cdot T\\) (vector-valued with trailing size <code>d</code>).</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.div_cauchy_stress","title":"<code>phydrax.operators.div_cauchy_stress(u: DomainFunction, /, *, lambda_: DomainFunction | ArrayLike, mu: DomainFunction | ArrayLike, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Divergence of the linear-elastic Cauchy stress.</p> <p>Computes the vector field</p> \\[ \\nabla\\cdot\\sigma(u), \\] <p>where \\(\\sigma(u)\\) is given by <code>cauchy_stress</code>.</p> <p>Arguments:</p> <ul> <li><code>u</code>, <code>lambda_</code>, <code>mu</code>: As in <code>cauchy_stress</code>.</li> <li><code>var</code>: Geometry label to differentiate with respect to.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>cauchy_stress</code> and <code>div_tensor</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\nabla\\cdot\\sigma(u)\\) (vector-valued).</li> </ul>"},{"location":"api/operators/differential/#navierstokes-helpers","title":"Navier\u2013Stokes helpers","text":""},{"location":"api/operators/differential/#phydrax.operators.navier_stokes_stress","title":"<code>phydrax.operators.navier_stokes_stress(u: DomainFunction, p: DomainFunction | ArrayLike, /, *, mu: DomainFunction | ArrayLike, lambda_: DomainFunction | ArrayLike | None = None, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Cauchy stress for incompressible/compressible Navier\u2013Stokes.</p> <p>Given a velocity field \\(u\\) and pressure \\(p\\), this returns</p> \\[ \\sigma(u,p) = \\tau(u) - p\\,I, \\] <p>where \\(\\tau(u)\\) is the (Newtonian) viscous stress returned by <code>viscous_stress</code>.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Velocity field.</li> <li><code>p</code>: Pressure (scalar field or constant).</li> <li><code>mu</code>, <code>lambda_</code>: Viscosity parameters for <code>viscous_stress</code> (with Stokes'   hypothesis used when <code>lambda_</code> is omitted).</li> <li><code>var</code>: Geometry label to differentiate with respect to.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>viscous_stress</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\sigma(u,p)\\) with trailing shape <code>(..., d, d)</code>.</li> </ul>"},{"location":"api/operators/differential/#phydrax.operators.navier_stokes_divergence","title":"<code>phydrax.operators.navier_stokes_divergence(u: DomainFunction, p: DomainFunction | ArrayLike, /, *, mu: DomainFunction | ArrayLike, lambda_: DomainFunction | ArrayLike | None = None, var: str | None = None, mode: Literal['reverse', 'forward'] = 'reverse', backend: Literal['ad', 'fd', 'basis'] = 'ad', basis: Literal['poly', 'fourier', 'sine', 'cosine'] = 'poly', periodic: bool = False) -&gt; DomainFunction</code>","text":"<p>Divergence of the Navier\u2013Stokes stress.</p> <p>Computes</p> \\[ \\nabla\\cdot(\\tau(u) - p I), \\] <p>where <code>navier_stokes_stress(u, p, ...)</code> returns the stress tensor.</p> <p>Arguments:</p> <ul> <li><code>u</code>, <code>p</code>, <code>mu</code>, <code>lambda_</code>: As in <code>navier_stokes_stress</code>.</li> <li><code>var</code>: Geometry label to differentiate with respect to.</li> <li><code>mode</code>, <code>backend</code>, <code>basis</code>, <code>periodic</code>: Passed through to <code>navier_stokes_stress</code> and <code>div_tensor</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing \\(\\nabla\\cdot(\\tau(u) - p I)\\) (vector-valued).</li> </ul>"},{"location":"api/operators/functional/","title":"Functional operators","text":""},{"location":"api/operators/functional/#phydrax.operators.spatial_inner_product","title":"<code>phydrax.operators.spatial_inner_product(u: DomainFunction, v: DomainFunction, batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...], /, *, component: DomainComponent | DomainComponentUnion, quadrature: QuadratureBatch | tuple[QuadratureBatch | None, ...] | None = None, over: str | tuple[str, ...] | None = 'x', key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; cx.Field</code>","text":"<p>Estimate an \\(L^2\\)-type inner product.</p> <p>Forms the pointwise Euclidean/Frobenius product and integrates:</p> \\[ \\langle u, v \\rangle = \\int_{\\Omega} u(x)\\cdot v(x)\\,d\\mu(x), \\] <p>where <code>u(x)\u00b7v(x)</code> is implemented as <code>sum(u * v)</code> over the value dimensions. Domains are joined before evaluation.</p> <p>Arguments:</p> <ul> <li><code>u</code>, <code>v</code>: Input <code>DomainFunction</code>s.</li> <li><code>batch</code>, <code>component</code>, <code>quadrature</code>, <code>over</code>, <code>key</code>, <code>kwargs</code>: As in <code>spatial_mean</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>coordax.Field</code> containing the scalar inner product value.</li> </ul>"},{"location":"api/operators/functional/#phydrax.operators.spatial_l2_norm","title":"<code>phydrax.operators.spatial_l2_norm(u: DomainFunction, batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...], /, *, component: DomainComponent | DomainComponentUnion, quadrature: QuadratureBatch | tuple[QuadratureBatch | None, ...] | None = None, over: str | tuple[str, ...] | None = 'x', key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; cx.Field</code>","text":"<p>Estimate the \\(L^2\\) norm over space.</p> <p>Equivalent to <code>spatial_lp_norm(..., p=2)</code>.</p>"},{"location":"api/operators/functional/#phydrax.operators.spatial_lp_norm","title":"<code>phydrax.operators.spatial_lp_norm(u: DomainFunction, batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...], /, *, p: float = 2.0, component: DomainComponent | DomainComponentUnion, quadrature: QuadratureBatch | tuple[QuadratureBatch | None, ...] | None = None, over: str | tuple[str, ...] | None = 'x', key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; cx.Field</code>","text":"<p>Estimate an \\(L^p\\) norm over space.</p> <p>Computes</p> \\[ \\|u\\|_{L^p(\\Omega)} = \\left(\\int_{\\Omega} \\|u(x)\\|_2^p\\,d\\mu(x)\\right)^{1/p}, \\] <p>where \\(\\|u(x)\\|_2\\) is the Euclidean norm of the (possibly vector/tensor) value at \\(x\\), flattened.</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input <code>DomainFunction</code>.</li> <li><code>batch</code>, <code>component</code>, <code>quadrature</code>, <code>over</code>, <code>key</code>, <code>kwargs</code>: As in <code>spatial_mean</code>.</li> <li><code>p</code>: Norm exponent \\(p&gt;0\\).</li> </ul> <p>Returns:</p> <ul> <li>A <code>coordax.Field</code> containing the scalar \\(L^p\\) norm value.</li> </ul>"},{"location":"api/operators/functional/#phydrax.operators.spatial_mean","title":"<code>phydrax.operators.spatial_mean(u: DomainFunction, batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...], /, *, component: DomainComponent | DomainComponentUnion, quadrature: QuadratureBatch | tuple[QuadratureBatch | None, ...] | None = None, over: str | tuple[str, ...] | None = 'x', key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; cx.Field</code>","text":"<p>Estimate the spatial mean of a field.</p> <p>Computes the Monte Carlo / quadrature estimate of</p> \\[ \\langle u \\rangle = \\frac{1}{\\mu(\\Omega)}\\int_{\\Omega} u(x)\\,d\\mu(x), \\] <p>where \\(\\Omega\\) is the subset described by <code>component</code> and the integration axes are selected by <code>over</code> (default <code>\"x\"</code>).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Integrand <code>DomainFunction</code>.</li> <li><code>batch</code>: <code>PointsBatch</code>/<code>CoordSeparableBatch</code> used for sampling (or a tuple for unions).</li> <li><code>component</code>: <code>DomainComponent</code> or <code>DomainComponentUnion</code> defining the integration region.</li> <li><code>quadrature</code>: Optional <code>QuadratureBatch</code> for paired sampling.</li> <li><code>over</code>: Which axes/labels to reduce over (defaults to <code>\"x\"</code>).</li> <li><code>key</code>: PRNG key forwarded to callables.</li> <li><code>kwargs</code>: Extra keyword arguments forwarded to <code>u</code> and component callables.</li> </ul> <p>Returns:</p> <ul> <li>A <code>coordax.Field</code> containing the mean value (with remaining named axes, if any).</li> </ul>"},{"location":"api/operators/integral/","title":"Integral operators","text":"<p>Note</p> <p>For a more detailed mathematical guide (measures, sampling, quadrature), see Guides \u2192 Integrals and measures.</p> <p>Note</p> <p>When integrating over a <code>CoordSeparableBatch</code>, Phydrax uses per-axis quadrature weights from <code>batch.axis_discretization_by_axis</code> when available (e.g. Gauss\u2013Legendre weights from <code>LegendreAxisSpec</code>). Otherwise it falls back to uniform per-axis weights based on the factor's axis-aligned bounding box.</p>"},{"location":"api/operators/integral/#phydrax.operators.build_quadrature","title":"<code>phydrax.operators.build_quadrature(component: DomainComponent, batch: PointsBatch) -&gt; QuadratureBatch</code>","text":"<p>Build a uniform tensor-product quadrature for a <code>PointsBatch</code>.</p> <p>For each sampling axis \\(a\\) with \\(n_a\\) points, this constructs weights</p> \\[ w_a = \\frac{\\mu_a}{n_a}, \\] <p>where \\(\\mu_a\\) is the measure associated with the labels in the corresponding sampling block (as determined by <code>component</code>). The full weight is the product \\(w=\\prod_a w_a\\).</p> <p>Arguments:</p> <ul> <li><code>component</code>: The <code>DomainComponent</code> whose measure is being integrated.</li> <li><code>batch</code>: A <code>PointsBatch</code> sampled with a canonicalized <code>ProductStructure</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>QuadratureBatch</code> with per-axis weights compatible with <code>batch</code>.</li> </ul>"},{"location":"api/operators/integral/#phydrax.operators.build_ball_quadrature","title":"<code>phydrax.operators.build_ball_quadrature(*, radius: float, dim: int, num_points: int = 2048, seed: int = 0, method: typing.Literal['fibonacci', 'grid'] = 'fibonacci', angular_design: str | None = None, radial_strata: int | list[float] | None = None) -&gt; dict</code>","text":"<p>Precompute isotropic quadrature offsets for a ball.</p> <p>Constructs a rule on the Euclidean ball</p> \\[ B_r(0) = \\{\\xi\\in\\mathbb{R}^d : \\|\\xi\\|_2 \\le r\\}, \\] <p>returning a dict with: - <code>\"offsets\"</code>: array of shape <code>(N, dim)</code> containing offsets \\(\\xi_i\\); - <code>\"weights\"</code>: array of shape <code>(N,)</code> with equal weights   \\(w_i = |B_r(0)|/N\\).</p> <p>This is intended for local/nonlocal operators of the form:</p> \\[ \\int_{B_r(0)} \\mathcal{I}(x, x+\\xi, \\ldots)\\,\\mathrm{d}\\xi \\approx \\sum_{i=1}^{N} w_i\\,\\mathcal{I}(x, x+\\xi_i, \\ldots). \\]"},{"location":"api/operators/integral/#phydrax.operators.integral._batch_ops.integral","title":"<code>phydrax.operators.integral._batch_ops.integral(f: DomainFunction | ArrayLike | None, batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...], /, *, component: DomainComponent | DomainComponentUnion, quadrature: QuadratureBatch | tuple[QuadratureBatch | None, ...] | None = None, over: str | tuple[str, ...] | None = None, key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; cx.Field</code>","text":"<p>Estimate an integral over a <code>DomainComponent</code>.</p> <p>Given an integrand \\(f\\) and a component \\(\\Omega_{\\text{comp}}\\) with measure \\(\\mu\\), this computes a Monte Carlo / quadrature estimate of</p> \\[ \\int_{\\Omega_{\\text{comp}}} f(z)\\,d\\mu(z). \\] <p>Sampling structure is provided by <code>batch</code>: - <code>PointsBatch</code>: paired sampling according to a <code>ProductStructure</code>; - <code>CoordSeparableBatch</code>: coordinate-separable sampling for some geometry labels.</p> <p>Filtering and weighting: - <code>component.where</code> / <code>component.where_all</code> act as indicator functions; - <code>component.weight_all</code> multiplies the integrand.</p> <p>Arguments:</p> <ul> <li><code>f</code>: Integrand as a <code>DomainFunction</code> or array-like constant.</li> <li><code>batch</code>: Sampled points (or a tuple of batches for <code>DomainComponentUnion</code>).</li> <li><code>component</code>: Component (or union of components) to integrate over.</li> <li><code>quadrature</code>: Optional explicit per-axis weights (<code>QuadratureBatch</code> for <code>PointsBatch</code> only).</li> <li><code>over</code>: Which label/block to integrate over; <code>None</code> integrates over all axes implied by <code>batch</code>.</li> <li><code>key</code>: PRNG key forwarded to <code>where</code>/<code>weight</code> callables and <code>f</code> (when needed).</li> <li><code>kwargs</code>: Extra keyword arguments forwarded to <code>f</code> and component callables.</li> </ul> <p>Returns:</p> <ul> <li>A <code>coordax.Field</code> containing the reduced integral value, with remaining named axes   corresponding to any non-integrated sampling axes.</li> </ul>"},{"location":"api/operators/integral/#phydrax.operators.mean","title":"<code>phydrax.operators.mean(f: DomainFunction | ArrayLike | None, batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...], /, *, component: DomainComponent | DomainComponentUnion, quadrature: QuadratureBatch | tuple[QuadratureBatch | None, ...] | None = None, over: str | tuple[str, ...] | None = None, key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; cx.Field</code>","text":"<p>Estimate the mean value of an integrand over a component.</p> <p>Computes</p> \\[ \\frac{\\int_{\\Omega_{\\text{comp}}} f(z)\\,d\\mu(z)}      {\\int_{\\Omega_{\\text{comp}}} 1\\,d\\mu(z)}. \\] <p>Arguments:</p> <ul> <li><code>f</code>, <code>batch</code>, <code>component</code>, <code>quadrature</code>, <code>over</code>, <code>key</code>, <code>kwargs</code>: As in <code>integral</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>coordax.Field</code> containing the mean value.</li> </ul>"},{"location":"api/operators/integral/#phydrax.operators.integrate_interior","title":"<code>phydrax.operators.integrate_interior(f: DomainFunction | ArrayLike | None, batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...], /, *, component: DomainComponent | DomainComponentUnion, quadrature: QuadratureBatch | tuple[QuadratureBatch | None, ...] | None = None, over: str | tuple[str, ...] | None = None, key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; cx.Field</code>","text":"<p>Alias for <code>integral</code>.</p> <p>Interior/boundary semantics are encoded by <code>component</code> (e.g. its <code>ComponentSpec</code>).</p>"},{"location":"api/operators/integral/#phydrax.operators.integrate_boundary","title":"<code>phydrax.operators.integrate_boundary(f: DomainFunction | ArrayLike | None, batch: PointsBatch | CoordSeparableBatch | tuple[PointsBatch, ...], /, *, component: DomainComponent | DomainComponentUnion, quadrature: QuadratureBatch | tuple[QuadratureBatch | None, ...] | None = None, over: str | tuple[str, ...] | None = None, key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; cx.Field</code>","text":"<p>Alias for <code>integral</code>.</p> <p>Interior/boundary semantics are encoded by <code>component</code> (e.g. its <code>ComponentSpec</code>).</p>"},{"location":"api/operators/integral/#phydrax.operators.spatial_integral","title":"<code>phydrax.operators.spatial_integral(u: DomainFunction, /, *, quad: dict, kernel: Callable | None = None, nonlinearity: Callable | None = None, importance_weight: Callable[[jax.Array, jax.Array], jax.Array] | None = None, var: str = 'x', time_var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Spatial integral operator with a fixed quadrature rule.</p> <p>Constructs a new function \\(v\\) defined by</p> \\[ v(x) = \\int_{\\Omega} K(x,y)\\,g(u(y))\\,dy, \\] <p>approximated using the provided quadrature nodes/weights <code>quad = {\"points\": y_j, \"weights\": w_j}</code>:</p> \\[ v(x) \\approx \\sum_{j=1}^{N_y} w_j\\,K(x,y_j)\\,g(u(y_j)). \\] <p>Arguments:</p> <ul> <li><code>u</code>: Input field \\(u\\).</li> <li><code>quad</code>: A dict with keys <code>\"points\"</code> (shape <code>(N_y, d)</code>) and <code>\"weights\"</code> (shape <code>(N_y,)</code>).</li> <li><code>kernel</code>: Optional kernel \\(K\\). If provided, it is evaluated as   <code>kernel(concat([x, y]))</code> with input in \\(\\mathbb{R}^{2d}\\).</li> <li><code>nonlinearity</code>: Optional nonlinearity \\(g\\) applied to \\(u(y)\\) before integration.</li> <li><code>importance_weight</code>: Optional extra factor \\(M(x,y)\\) multiplied into the quadrature weights.</li> <li><code>var</code>: Label of the spatial variable (default <code>\"x\"</code>).</li> <li><code>time_var</code>: Optional time label to include as an additional dependency.</li> </ul> <p>Notes:</p> <ul> <li>This operator does not support coord-separable inputs for <code>var</code>.</li> </ul>"},{"location":"api/operators/integral/#phydrax.operators.local_integral","title":"<code>phydrax.operators.local_integral(u: DomainFunction, /, *, integrand: Callable, ball_quad: dict, var: str = 'x', time_var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Local (ball) integral operator around each query point.</p> <p>Constructs a function of the form</p> \\[ v(x) = \\int_{B_\\delta(0)} \\mathcal{I}(x, x+\\xi, u(x), u(x+\\xi), \\xi, \\dots)\\,d\\xi, \\] <p>approximated using a fixed quadrature rule on offsets \\(\\xi_j\\):</p> \\[ v(x) \\approx \\sum_{j=1}^{N_\\xi} w_j\\,\\mathcal{I}(x, x+\\xi_j, u(x), u(x+\\xi_j), \\xi_j, \\dots). \\] <p>The integrand is provided as <code>integrand(ctx)</code> and receives a context dictionary similar to <code>nonlocal_integral</code>, including keys <code>\"x\"</code>, <code>\"y\"</code>, <code>\"ux\"</code>, <code>\"uy\"</code>, <code>\"du\"</code>, and <code>\"xi\"</code>.</p> <p>Notes:</p> <ul> <li>This operator does not support coord-separable inputs for <code>var</code>.</li> </ul>"},{"location":"api/operators/integral/#phydrax.operators.local_integral_ball","title":"<code>phydrax.operators.local_integral_ball(u: DomainFunction, f_bond: Callable, *, ball_quad: dict, var: str = 'x', time_var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Convenience wrapper for a bond-based local integral.</p> <p>Uses an integrand of the form \\(\\mathcal{I} = f(\\Delta u, \\xi)\\) with \\(\\Delta u = u(y)-u(x)\\) and \\(\\xi=y-x\\).</p>"},{"location":"api/operators/integral/#phydrax.operators.nonlocal_integral","title":"<code>phydrax.operators.nonlocal_integral(u: DomainFunction, /, *, integrand: Callable, quad: dict, importance_weight: Callable[[jax.Array, jax.Array], jax.Array] | None = None, var: str = 'x', time_var: str | None = None) -&gt; DomainFunction</code>","text":"<p>Nonlocal integral operator with a context-aware integrand.</p> <p>Constructs a function</p> \\[ v(x) = \\int_{\\Omega} \\mathcal{I}(x,y,u(x),u(y),\\dots)\\,dy \\approx \\sum_{j=1}^{N_y} w_j\\,\\mathcal{I}(\\cdot), \\] <p>where the integrand is provided as <code>integrand(ctx)</code> and is evaluated on a context dictionary containing (at least) the keys:</p> <ul> <li><code>\"x\"</code>: Full coordinate (including time if <code>time_var</code> is provided).</li> <li><code>\"y\"</code>: Full coordinate (including time if <code>time_var</code> is provided).</li> <li><code>\"x_space\"</code>: Spatial part of <code>x</code>.</li> <li><code>\"y_space\"</code>: Spatial part of <code>y</code>.</li> <li><code>\"t\"</code>: Scalar time or <code>None</code>.</li> <li><code>\"ux\"</code>: Value \\(u(x)\\).</li> <li><code>\"uy\"</code>: Value \\(u(y)\\).</li> <li><code>\"du\"</code>: \\(u(y)-u(x)\\).</li> <li><code>\"xi\"</code>: displacement \\(y-x\\) in space.</li> </ul> <p>Arguments:</p> <ul> <li><code>u</code>: Input function \\(u\\).</li> <li><code>integrand</code>: A callable returning the integrand value given a <code>ctx</code> dict.</li> <li><code>quad</code>: A dict with <code>\"points\"</code> and <code>\"weights\"</code> as in <code>spatial_integral</code>.</li> <li><code>importance_weight</code>: Optional extra factor \\(M(x,y)\\) multiplied into weights.</li> <li><code>var</code>: Spatial domain label used for the integral variable.</li> <li><code>time_var</code>: Optional time label included in <code>\"x\"</code>/<code>\"y\"</code> when present.</li> </ul>"},{"location":"api/operators/integral/#phydrax.operators.time_convolution","title":"<code>phydrax.operators.time_convolution(k: Callable[[Array], ArrayLike], u: DomainFunction, /, *, time_var: str = 't', order: int = 48, cluster_exponent: float = 1.0, mode: Literal['gl', 'qmc', 'gmc_1d'] = 'gl', sampler: str = 'sobol_scrambled', kernel_exponent: float | None = None) -&gt; DomainFunction</code>","text":"<p>Time convolution operator on a labeled time coordinate.</p> <p>Constructs the causal convolution</p> \\[ (k * u)(t) = \\int_{t_0}^{t} k(t-s)\\,u(s)\\,ds, \\] <p>where \\(t_0\\) is the start of the time interval when <code>time_var</code> is a <code>TimeInterval</code> factor (otherwise \\(t_0=0\\)).</p> <p>The integral is approximated using one of: - <code>mode=\"gl\"</code>: Gauss\u2013Legendre quadrature on \\([t_0,t]\\) (optionally clustered near \\(t_0\\)); - <code>mode=\"qmc\"</code>: quasi Monte Carlo on \\([t_0,t]\\); - <code>mode=\"gmc_1d\"</code>: importance sampling for weakly singular kernels   (requires <code>kernel_exponent</code> \\(\\gamma\\)).</p> <p>Arguments:</p> <ul> <li><code>k</code>: Kernel \\(k(\\tau)\\) evaluated at \\(\\tau=t-s\\).</li> <li><code>u</code>: Input function \\(u(s)\\).</li> <li><code>time_var</code>: Label for the time coordinate (default <code>\"t\"</code>).</li> <li><code>order</code>: Number of quadrature/MC samples.</li> <li><code>cluster_exponent</code>: When using Gauss\u2013Legendre, applies a power-law transform to   cluster nodes toward the start of the interval.</li> <li><code>sampler</code>: QMC sampler name used for <code>mode=\"qmc\"</code> / <code>mode=\"gmc_1d\"</code>.</li> <li><code>kernel_exponent</code>: Exponent \\(\\gamma\\) used in <code>mode=\"gmc_1d\"</code> for sampling   \\(\\tau^{-\\gamma}\\)-type singularities.</li> </ul>"},{"location":"api/operators/linalg/","title":"Linear algebra","text":""},{"location":"api/operators/linalg/#phydrax.operators.einsum","title":"<code>phydrax.operators.einsum(subscript: str, /, *operands: DomainFunction) -&gt; DomainFunction</code>","text":"<p>Einstein summation of one or more <code>DomainFunction</code> operands.</p> <p>Given operands \\(u^{(1)}(z),\\dots,u^{(k)}(z)\\), returns the pointwise contraction specified by <code>subscript</code>, i.e.</p> \\[ w(z) = \\texttt{einsum}(\\texttt{subscript}, u^{(1)}(z), \\dots, u^{(k)}(z)). \\] <p>Domains are joined across operands before evaluation.</p> <p>Arguments:</p> <ul> <li><code>subscript</code>: Einsum subscript string (as in <code>opt_einsum.contract</code>).</li> <li><code>operands</code>: One or more <code>DomainFunction</code> operands.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the contracted result.</li> </ul>"},{"location":"api/operators/linalg/#phydrax.operators.norm","title":"<code>phydrax.operators.norm(u: DomainFunction, /, *, order: int = 2) -&gt; DomainFunction</code>","text":"<p>Pointwise vector norm of a <code>DomainFunction</code>.</p> <p>Interprets the last axis of \\(u(z)\\) as a vector and returns</p> \\[ \\|u(z)\\|_p, \\] <p>where <code>order=p</code>. If \\(u(z)\\) is scalar, this returns \\(|u(z)|\\).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input function.</li> <li><code>order</code>: Norm order \\(p\\) passed to <code>jax.numpy.linalg.norm</code> (<code>ord=p</code>).</li> </ul>"},{"location":"api/operators/linalg/#phydrax.operators.trace","title":"<code>phydrax.operators.trace(u: DomainFunction) -&gt; DomainFunction</code>","text":"<p>Pointwise matrix trace.</p> <p>Interprets the last two axes of \\(u(z)\\) as a matrix and returns \\(\\text{tr}(u(z))\\).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input <code>DomainFunction</code> whose values have at least two trailing axes.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the scalar trace field.</li> </ul>"},{"location":"api/operators/linalg/#phydrax.operators.det","title":"<code>phydrax.operators.det(u: DomainFunction) -&gt; DomainFunction</code>","text":"<p>Pointwise matrix determinant.</p> <p>Interprets the last two axes of \\(u(z)\\) as a square matrix and returns \\(\\det(u(z))\\).</p> <p>Arguments:</p> <ul> <li><code>u</code>: Input <code>DomainFunction</code> whose values have trailing shape <code>(n, n)</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>DomainFunction</code> representing the scalar determinant field.</li> </ul>"},{"location":"api/solver/","title":"Solver","text":"<p>Solvers assemble fields, constraints, and optional enforced-constraint pipelines into a scalar loss suitable for optimization.</p> <p>For a conceptual overview (loss evaluation, enforced pipelines, training loop behavior), see Guides \u2192 Solvers and training.</p> <p>Note</p> <p>Key notes:</p> <ul> <li>Use <code>FunctionalSolver</code> to sum constraint losses into \\(L=\\sum_i \\ell_i\\).</li> <li>Use enforced constraint pipelines to enforce conditions by construction (no penalty term).</li> </ul>"},{"location":"api/solver/enforced_constraints/","title":"Enforced constraint pipelines","text":"<p>Pipelines compose and apply enforced-constraint ans\u00e4tze.</p> <p>For the underlying ansatz constructors (<code>enforce_dirichlet</code>, <code>enforce_neumann</code>, etc.), see Enforced constraint ans\u00e4tze.</p> <p>Note</p> <p>Key notes:</p> <ul> <li>An <code>EnforcedConstraintPipeline</code> stages overlays in the order boundary \u2192 initial \u2192 interior data.</li> <li><code>EnforcedConstraintPipelines</code> topologically orders multi-field dependencies (<code>co_vars</code>).</li> <li>For a detailed mathematical treatment of the PCI pipeline (including BVH-weighted boundary blending, boundary\u2013initial gating, and the interior anchor/data stage), see Appendix \u2192 Physics-Constrained Interpolation.</li> </ul>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.SingleFieldEnforcedConstraint","title":"<code>phydrax.solver.SingleFieldEnforcedConstraint</code>","text":"<p>Enforced constraint term acting on a single field.</p> <p>An enforced constraint is a transformation that builds an ansatz \\(\\tilde u\\) from a base field \\(u\\) such that some condition is satisfied by construction. Conceptually this is a map</p> \\[ \\mathcal{H}: u \\mapsto \\tilde u \\] <p>where \\(\\tilde u\\) is intended to satisfy, e.g., Dirichlet boundary conditions \\(\\tilde u|_{\\partial\\Omega}=g\\), initial conditions \\(\\tilde u(\\cdot,t_0)=u_0\\), or similar constraints.</p> <p><code>SingleFieldEnforcedConstraint</code> stores the metadata needed to stage and compose these transformations inside <code>EnforcedConstraintPipeline</code>.</p>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.SingleFieldEnforcedConstraint.co_vars","title":"<code>co_vars</code>  <code>property</code>","text":"<p>Names of co-dependent fields (always empty for single-field terms).</p>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.SingleFieldEnforcedConstraint.__init__","title":"<code>__init__(field: str, component: DomainComponent, apply: Callable[[DomainFunction], DomainFunction], /, *, max_derivative_order: int = 0, time_derivative_order: int = 0, initial_target: DomainFunction | ArrayLike | None = None)</code>","text":"<p>Create a single-field enforced constraint.</p> <p>Arguments:</p> <ul> <li><code>field</code>: Name of the field being modified (e.g. <code>\"u\"</code>).</li> <li><code>component</code>: The domain subset where the constraint is defined (boundary,   initial, etc.).</li> <li><code>apply</code>: The enforcement map \\(\\mathcal{H}\\) implemented as a callable that   returns a new <code>DomainFunction</code>.</li> </ul> <p>Keyword arguments:</p> <ul> <li><code>max_derivative_order</code>: Maximum spatial derivative order that the   constraint construction expects to be well-defined (used for staging   and gating in composite pipelines).</li> <li><code>time_derivative_order</code>: When the constraint represents an initial   derivative target, this is the derivative order \\(k\\) for   \\(\\partial_t^k u(\\cdot,t_0)\\).</li> <li><code>initial_target</code>: Optional target for the initial derivative order:   provide \\(g_k\\) for \\(\\partial_t^k u(\\cdot,t_0)=g_k\\).</li> </ul> <p>Notes:</p> <ul> <li>If <code>initial_target</code> is provided, <code>EnforcedConstraintPipeline</code> will group   targets for orders \\(k=0,\\dots,K\\) and build a single initial overlay.</li> </ul>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.MultiFieldEnforcedConstraint","title":"<code>phydrax.solver.MultiFieldEnforcedConstraint</code>","text":"<p>Enforced constraint term that depends on other fields.</p> <p>Some enforced constraint constructions require access to co-variables (other fields) when enforcing a given field. For example, a boundary condition for a stress-like quantity might depend on both displacement and material parameters.</p> <p>This stores an <code>apply</code> function of the form</p> \\[ \\tilde u = \\mathcal{H}\\big(u,\\ \\{v\\}_{v\\in\\texttt{co\\_vars}}\\big), \\] <p>where <code>get_field(name)</code> supplies the current (possibly already enforced) <code>DomainFunction</code> for each co-variable.</p>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.MultiFieldEnforcedConstraint.__init__","title":"<code>__init__(field: str, component: DomainComponent, co_vars: Sequence[str], apply: Callable[[DomainFunction, Callable[[str], DomainFunction]], DomainFunction], /, *, max_derivative_order: int = 0, time_derivative_order: int = 0)</code>","text":"<p>Create a multi-field enforced constraint.</p> <p>Arguments:</p> <ul> <li><code>field</code>: Name of the field being modified.</li> <li><code>component</code>: The domain subset where the constraint is defined.</li> <li><code>co_vars</code>: Names of fields that <code>apply</code> depends on.</li> <li><code>apply</code>: An enforcement map \\(\\mathcal{H}\\) implemented as   <code>apply(u, get_field) -&gt; DomainFunction</code>.</li> </ul> <p>Keyword arguments:</p> <ul> <li><code>max_derivative_order</code>: Maximum spatial derivative order expected by the   constraint.</li> <li><code>time_derivative_order</code>: Optional initial-derivative order metadata.</li> </ul>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedInteriorData","title":"<code>phydrax.solver.EnforcedInteriorData</code>","text":"<p>Interior data source for enforced data overlays.</p> <p><code>EnforcedInteriorData</code> represents measurements (or anchor constraints) that you want to enforce by construction in the interior of a domain, without competing with boundary/initial enforced constraints.</p> <p>Two input modes are supported:</p> <p>1) Anchor points: a set of points \\(z_j\\) with values \\(y_j\\).</p> <ul> <li><code>points</code>: mapping from domain label to coordinate arrays.</li> <li><code>values</code>: an array of values with leading dimension \\(N\\).</li> </ul> <p>2) Sensor tracks: a set of fixed sensors \\(x_m\\) observed over times \\(t_n\\).</p> <ul> <li><code>sensors</code>: array with shape \\((M,d)\\) (or \\((d,)\\) for a single sensor).</li> <li><code>times</code>: array with shape \\((N,)\\).</li> <li><code>sensor_values</code>: array with shape \\((M,N)\\) or \\((M,N,C)\\).</li> </ul> <p>The enforced overlay built from this data uses inverse-distance weights (IDW) to compute a correction term \\(\\Delta u(z)\\) from residuals \\(r_j = y_j - u(z_j)\\), while multiplying by a gate \\(M(z)\\) that vanishes on constrained sets (boundary / initial time) so the overlay does not destroy those conditions.</p> <p>See <code>EnforcedConstraintPipeline</code> for how this integrates with other enforced stages.</p>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedInteriorData.__init__","title":"<code>__init__(field: str, /, *, points: Mapping[str, ArrayLike] | None = None, values: ArrayLike | None = None, sensors: ArrayLike | None = None, times: ArrayLike | None = None, sensor_values: ArrayLike | None = None, idw_exponent: float = 2.0, eps_snap: float = 1e-12, lengthscales: Mapping[str, float] | None = None, use_envelope: bool = False, envelope_scale: float = 1.0, space_label: str = 'x', time_label: str = 't', time_interp: Literal[idw, hermite] = 'idw')</code>","text":"<p>Create an enforced interior data source.</p> <p>Arguments:</p> <ul> <li><code>field</code>: Name of the field that this data applies to.</li> </ul> <p>Anchor mode:</p> <ul> <li><code>points</code>: Mapping <code>{label: coords}</code> giving anchor coordinates per domain   label. Geometry labels should use shape <code>(N,d)</code> and scalar labels shape   <code>(N,)</code>.</li> <li><code>values</code>: Anchor values with shape <code>(N,)</code> or <code>(N,C)</code>.</li> </ul> <p>Sensor-track mode:</p> <ul> <li><code>sensors</code>: Sensor locations, shape <code>(M,d)</code> (or <code>(d,)</code>).</li> <li><code>times</code>: Observation times, shape <code>(N,)</code>.</li> <li><code>sensor_values</code>: Observations, shape <code>(M,N)</code> or <code>(M,N,C)</code>.</li> <li><code>space_label</code>: Domain label corresponding to space.</li> <li><code>time_label</code>: Domain label corresponding to time.</li> <li><code>time_interp</code>:<ul> <li><code>\"idw\"</code> flattens the \\((x_m,t_n)\\) grid into anchors in \\((x,t)\\) and uses   IDW in the full domain.</li> <li><code>\"hermite\"</code> uses a cubic Hermite spline in time and IDW only in space   (requires a 2-factor domain with <code>(space_label, time_label)</code>).</li> </ul> </li> </ul> <p>IDW details:</p> <ul> <li><code>idw_exponent</code>: Power \\(p\\) in weights   \\(w_j(z)\\propto (\\|z-z_j\\|^2+\\varepsilon)^{-p/2}\\).</li> <li><code>lengthscales</code>: Optional per-label lengthscales \\(\\ell_\\alpha\\) used inside   the distance metric:   \\(\\|z-z_j\\|^2=\\sum_\\alpha \\|(z_\\alpha-z_{j,\\alpha})/\\ell_\\alpha\\|^2\\).</li> <li><code>eps_snap</code>: Snap threshold: when \\(z\\) is closer than <code>eps_snap</code> to an   anchor, the overlay uses a one-hot weight so that \\(u(z)\\) matches the   anchor exactly.</li> </ul> <p>Envelope (optional):</p> <ul> <li><code>use_envelope</code>: If enabled, multiplies IDW weights by a source-local envelope.</li> <li><code>envelope_scale</code>: Envelope scale \\(s\\) in \\(\\psi(z)=\\exp(-d(z)^2/s^2)\\).</li> </ul>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedConstraintPipeline","title":"<code>phydrax.solver.EnforcedConstraintPipeline</code>","text":"<p>Compose enforced overlays for a single field.</p> <p>A pipeline takes a base field \\(u\\) and returns an enforced field \\(\\tilde u\\) after applying a sequence of enforced transformations:</p> <ol> <li>Boundary overlays (if any), typically enforcing conditions on    \\(\\partial\\Omega\\) using smooth blend weights.</li> <li>Initial overlays (if any), enforcing values and/or time-derivative    targets at \\(t=t_0\\).</li> <li>Interior data overlays (optional), enforcing interior anchors/tracks    while preserving the boundary/initial conditions via a multiplicative    gate that vanishes on the constrained sets.</li> </ol> <p>Boundary/initial stages are blended using a boundary gate \\(\\gamma(z)\\), where \\(\\gamma=0\\) on the constrained boundary and \\(\\gamma\\approx 1\\) away from it:</p> \\[ u \\leftarrow u + \\gamma\\,(u_{\\text{next}}-u). \\] <p>This ensures that later stages do not re-violate boundary enforced constraints.</p>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedConstraintPipeline.__init__","title":"<code>__init__(u_base: DomainFunction, /, *, field: str, constraints: Sequence[SingleFieldEnforcedConstraint | MultiFieldEnforcedConstraint] = (), interior_data: Sequence[EnforcedInteriorData] = (), evolution_var: str = 't', include_identity_remainder: bool = True, num_reference: int = 3000000, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Build a pipeline for one field.</p> <p>Arguments:</p> <ul> <li><code>u_base</code>: Base <code>DomainFunction</code> for the field.</li> </ul> <p>Keyword arguments:</p> <ul> <li><code>field</code>: Field name (used to match constraints/data to the field).</li> <li><code>constraints</code>: Enforced constraint terms (single-field or multi-field).</li> <li><code>interior_data</code>: Interior data sources used to build an IDW-based enforced   overlay.</li> <li><code>evolution_var</code>: Name of the time-like label used to detect initial   constraints (default <code>\"t\"</code>).</li> <li><code>include_identity_remainder</code>: When blending multiple boundary pieces,   include a remainder weight for the identity map (keeps \\(u\\) unchanged   away from all pieces).</li> <li><code>num_reference</code>: Reference sample count used to normalize boundary blend weights.</li> <li><code>sampler</code>: Sampler used to draw reference points.</li> <li><code>key</code>: PRNG key used to draw reference points.</li> </ul> <p>Notes:</p> <ul> <li>Boundary staging currently requires boundary constraints to specify   exactly one geometry boundary label, shared across all boundary pieces.</li> </ul>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedConstraintPipeline.apply","title":"<code>apply(u_base: DomainFunction, /, *, get_field: Callable[[str], DomainFunction]) -&gt; DomainFunction</code>","text":""},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedConstraintPipelines","title":"<code>phydrax.solver.EnforcedConstraintPipelines</code>","text":"<p>Enforced constraint pipelines for multiple fields.</p> <p>When enforcing multiple fields \\(\\{u^{(k)}\\}\\), some enforced constraints may require access to co-variables (other fields). This object builds a directed acyclic graph (DAG) from <code>MultiFieldEnforcedConstraint.co_vars</code> and applies per-field <code>EnforcedConstraintPipeline</code>s in a topological order so that dependencies are available when needed.</p>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedConstraintPipelines.__init__","title":"<code>__init__(pipelines: Mapping[str, EnforcedConstraintPipeline], /, *, field_order: Sequence[str])</code>","text":"<p>Create a multi-field pipeline orchestrator.</p> <p>Arguments:</p> <ul> <li><code>pipelines</code>: Mapping <code>{field: EnforcedConstraintPipeline}</code>.</li> </ul> <p>Keyword arguments:</p> <ul> <li><code>field_order</code>: Preferred ordering for tie-breaking in the toposort   (typically <code>tuple(functions.keys())</code>).</li> </ul>"},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedConstraintPipelines.build","title":"<code>build(*, functions: Mapping[str, DomainFunction], constraints: Sequence[SingleFieldEnforcedConstraint | MultiFieldEnforcedConstraint] = (), interior_data: Sequence[EnforcedInteriorData] = (), evolution_var: str = 't', include_identity_remainder: bool = True, num_reference: int = 3000000, sampler: str = 'latin_hypercube', key: Key[Array, ''] = jr.key(0)) -&gt; EnforcedConstraintPipelines</code>  <code>classmethod</code>","text":""},{"location":"api/solver/enforced_constraints/#phydrax.solver.EnforcedConstraintPipelines.apply","title":"<code>apply(functions: Mapping[str, DomainFunction]) -&gt; frozendict[str, DomainFunction]</code>","text":"<p>Apply all pipelines and return an enforced field mapping.</p> <p>Pipelines are applied in a dependency-respecting order. If a pipeline for field \\(u\\) requires co-variables \\(\\{v\\}\\), then those \\(v\\) are taken from the current enforced mapping as the iteration proceeds.</p>"},{"location":"api/solver/functional_solver/","title":"Functional solver","text":"<p><code>FunctionalSolver</code> is the main entry point for turning a set of fields and constraints into a differentiable objective.</p> <p>For a conceptual overview (loss evaluation, enforced pipelines, training loop behavior), see Guides \u2192 Solvers and training.</p> <p>Note</p> <p>Key notes:</p> <ul> <li><code>loss(...)</code> evaluates the total objective at the current parameters.</li> <li><code>ansatz_functions()</code> returns fields after applying enforced pipelines (if configured).</li> <li><code>solve(...)</code> updates parameters inside <code>functions</code> using Optax or evosax optimizers.</li> </ul>"},{"location":"api/solver/functional_solver/#typical-usage","title":"Typical usage","text":"<pre><code>import jax.random as jr\nimport optax\nimport phydrax as phx\n\ngeom = phx.domain.Interval1d(0.0, 1.0)\n\nmodel = phx.nn.MLP(in_size=1, out_size=\"scalar\", width_size=16, depth=2, key=jr.key(0))\nu = geom.Model(\"x\")(model)\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\nconstraint = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    geom,\n    operator=lambda f: f,\n    num_points=128,\n    structure=structure,\n    reduction=\"mean\",\n)\n\nsolver = phx.solver.FunctionalSolver(functions={\"u\": u}, constraints=[constraint])\nloss0 = solver.loss(key=jr.key(0))\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\nloss1 = solver.loss(key=jr.key(1))\n</code></pre>"},{"location":"api/solver/functional_solver/#phydrax.solver.FunctionalSolver","title":"<code>phydrax.solver.FunctionalSolver</code>","text":"<p>Assemble constraints into a differentiable scalar loss.</p> <p>A <code>FunctionalSolver</code> holds:</p> <ul> <li>a mapping of named fields (as <code>DomainFunction</code>s), e.g. \\(u_\\theta\\);</li> <li>a collection of constraints \\(\\ell_i\\) producing scalar penalties.</li> </ul> <p>The solver loss is the (weighted) sum</p> \\[ L = \\sum_i \\ell_i. \\] <p>Optionally, enforced constraint pipelines can be applied to replace the raw fields with ansatz functions that satisfy selected boundary/initial conditions exactly.</p> <p>Evaluation</p> <ul> <li><code>ansatz_functions()</code> applies any enforced pipelines and returns the effective field   mapping used by constraints.</li> <li><code>loss(key=...)</code> splits the provided PRNG key into one subkey per constraint and   sums the resulting scalar losses.</li> </ul> <p>Training</p> <p><code>solve(...)</code> optimizes the inexact-array leaves inside <code>functions</code> (via Equinox partitioning), and passes an <code>iter_</code> counter through to constraint losses so that constraints can implement schedules.</p>"},{"location":"api/solver/functional_solver/#phydrax.solver.FunctionalSolver.__init__","title":"<code>__init__(*, functions: Mapping[str, DomainFunction], constraints: AbstractConstraint | Sequence[AbstractConstraint], constraint_pipelines: EnforcedConstraintPipelines | None = None, constraint_terms: Sequence[SingleFieldEnforcedConstraint | MultiFieldEnforcedConstraint] = (), interior_data_terms: Sequence[EnforcedInteriorData] = (), evolution_var: str = 't', include_identity_remainder: bool = True, boundary_weight_num_reference: int = 500000, boundary_weight_sampler: str = 'latin_hypercube', boundary_weight_key: Key[Array, ''] = jr.key(0))</code>","text":"<p>Create a functional solver.</p> <p>Arguments:</p> <ul> <li><code>functions</code>: Mapping <code>{name: DomainFunction}</code> defining the fields.</li> <li><code>constraints</code>: One or more <code>AbstractConstraint</code> instances.</li> <li><code>constraint_pipelines</code>: Optional pre-built enforced constraint pipelines. If provided,   do not also pass <code>constraint_terms</code>/<code>interior_data_terms</code>.</li> <li><code>constraint_terms</code>: Enforced constraint terms used to build <code>EnforcedConstraintPipelines</code>   (boundary/initial ans\u00e4tze).</li> <li><code>interior_data_terms</code>: Enforced interior data sources used to build <code>EnforcedConstraintPipelines</code>.</li> <li><code>evolution_var</code>: Name of the time-like label used for initial staging (default <code>\"t\"</code>).</li> <li><code>include_identity_remainder</code>: Boundary blending option for enforced pipelines.</li> <li><code>boundary_weight_num_reference</code>: Number of reference samples used for boundary blending weights.</li> <li><code>boundary_weight_sampler</code>: Sampler used to draw boundary blending references.</li> <li><code>boundary_weight_key</code>: PRNG key used to draw boundary blending references.</li> </ul>"},{"location":"api/solver/functional_solver/#phydrax.solver.FunctionalSolver.ansatz_functions","title":"<code>ansatz_functions() -&gt; frozendict[str, DomainFunction]</code>","text":"<p>Return the current field mapping after applying enforced pipelines (if configured).</p>"},{"location":"api/solver/functional_solver/#phydrax.solver.FunctionalSolver.__getitem__","title":"<code>__getitem__(var: str) -&gt; DomainFunction</code>","text":"<p>Convenience accessor: return the (ansatz) field named <code>var</code>.</p>"},{"location":"api/solver/functional_solver/#phydrax.solver.FunctionalSolver.loss","title":"<code>loss(*, key: Key[Array, ''] = jr.key(0), **kwargs: Any) -&gt; Array</code>","text":"<p>Evaluate the total loss \\(L=\\sum_i \\ell_i\\) over all configured constraints.</p> <p>This:</p> <p>1) applies enforced pipelines (if configured), 2) splits <code>key</code> into one subkey per constraint, 3) sums <code>constraint.loss(...)</code> over all constraints.</p> <p>Any additional keyword arguments are forwarded to each constraint.</p>"},{"location":"api/solver/functional_solver/#phydrax.solver.FunctionalSolver.solve","title":"<code>solve(*, num_iter: int, optim: optax.GradientTransformation | optax.GradientTransformationExtraArgs | Any | None = None, seed: int = 0, jit: bool = True, keep_best: bool = True, log_every: int = 1, log_constraints: bool = True, log_path: str | Path | None = None) -&gt; FunctionalSolver</code>","text":"<p>Run the training loop and return an updated solver.</p> <p>The optimization updates the inexact-array leaves of <code>self.functions</code>.</p> <ul> <li>If <code>optim</code> is an Optax <code>GradientTransformation</code>, a standard gradient step is used.</li> <li>If <code>optim</code> is an Optax <code>GradientTransformationExtraArgs</code>, a line-search style update is used.</li> <li>Otherwise, <code>optim</code> is treated as an evosax algorithm instance.</li> </ul> <p>During training, each constraint loss receives an <code>iter_</code> keyword argument (the 1-based iteration index as a JAX scalar) to enable schedules.</p> <p>Logging:</p> <ul> <li>If <code>log_every &gt; 0</code>, prints a progress line every <code>log_every</code> iterations.</li> <li>If <code>log_constraints=True</code>, also prints the per-constraint loss breakdown.</li> <li>If <code>log_path</code> is provided, logs are written to that file instead of stdout.</li> </ul>"},{"location":"appendix/","title":"Appendix","text":"<p>This section collects longer, more technical notes and mathematical details that support the main guides and API pages.</p> <ul> <li>Physics-Constrained Interpolation (PCI) pipeline</li> <li>Differentiation modes</li> <li>Surely You're Joking!</li> </ul>"},{"location":"appendix/differentiation_modes/","title":"Differentiation modes","text":"<p>This appendix gives a deeper mathematical explanation of the differentiation modes available in Phydrax\u2019s differential operators. Here \u201cdifferentiation\u201d refers to derivatives with respect to labeled domain variables (e.g. space <code>\"x\"</code> or time <code>\"t\"</code>), as used by operators like <code>grad</code>, <code>partial_n</code>, <code>laplacian</code>, etc.</p> <p>For the definitions and tensor shape conventions of the operators themselves, see Guides \u2192 Differential operators.</p>"},{"location":"appendix/differentiation_modes/#0-summary-of-user-facing-knobs","title":"0. Summary of user-facing knobs","text":"<p>Many differential operators share two primary keywords:</p> <ul> <li><code>backend</code>: selects how the derivative is computed:</li> <li><code>\"ad\"</code>: automatic differentiation,</li> <li><code>\"jet\"</code>: Taylor-mode AD (derivative jets) for higher-order pure derivatives,</li> <li><code>\"fd\"</code>: finite differences on coord-separable grids (with AD fallback),</li> <li><code>\"basis\"</code>: basis-aware (spectral / interpolation) derivatives on coord-separable grids (with AD fallback).</li> <li><code>mode</code>: selects the autodiff direction when <code>backend=\"ad\"</code>:</li> <li><code>\"reverse\"</code>: reverse-mode (<code>jax.jacrev</code>),</li> <li><code>\"forward\"</code>: forward-mode (<code>jax.jacfwd</code>).</li> </ul> <p>Some operators additionally accept:</p> <ul> <li><code>basis \u2208 {\"poly\",\"fourier\",\"sine\",\"cosine\"}</code> when <code>backend=\"basis\"</code>;</li> <li><code>periodic \u2208 {False,True}</code> when <code>backend=\"fd\"</code>.</li> </ul> <p>Note</p> <p><code>backend=\"fd\"</code> and <code>backend=\"basis\"</code> require coord-separable (structured-grid) evaluation for the variable being differentiated. When given point batches, these backends fall back to <code>\"ad\"</code>.</p>"},{"location":"appendix/differentiation_modes/#1-notation","title":"1. Notation","text":"<p>Fix a labeled product domain \\(\\Omega=\\Omega_x\\times\\Omega_t\\times\\cdots\\). For a geometry label \\(x\\in\\mathbb{R}^d\\), write \\(x=(x_1,\\dots,x_d)\\). For a scalar label \\(t\\in\\mathbb{R}\\), write \\(t\\).</p> <p>Locally, a <code>DomainFunction</code> can be viewed as a map</p> \\[ u:\\Omega\\to \\mathbb{R}^m, \\] <p>where \\(m\\) may itself represent a multi-axis tensor value; derivatives are taken componentwise with respect to the domain variable(s).</p> <p>For a smooth map \\(f:\\mathbb{R}^d\\to\\mathbb{R}^m\\), let \\(J_f(x)\\in\\mathbb{R}^{m\\times d}\\) denote the Jacobian, and for a direction \\(v\\in\\mathbb{R}^d\\) define the \\(k\\)-th directional derivative along \\(v\\) by</p> \\[ \\partial_v^k f(x) \\;:=\\; \\left.\\frac{d^k}{d\\epsilon^k} f(x+\\epsilon v)\\right|_{\\epsilon=0}. \\] <p>For \\(k=1\\), \\(\\partial_v f(x)=J_f(x)\\,v\\). For \\(v=e_i\\) (a coordinate axis), \\(\\partial_{e_i}^k f\\) reduces to the pure partial derivative \\(\\partial^k f/\\partial x_i^k\\) (componentwise).</p>"},{"location":"appendix/differentiation_modes/#2-backendad-automatic-differentiation","title":"2. <code>backend=\"ad\"</code>: automatic differentiation","text":"<p>The AD backend computes derivatives by applying the chain rule through the program that evaluates \\(u\\). It is the default and works for both point sampling and coord-separable sampling.</p>"},{"location":"appendix/differentiation_modes/#21-forward-vs-reverse-mode-ad-modeforward-reverse","title":"2.1 Forward- vs reverse-mode AD (<code>mode=\"forward\"</code> / <code>\"reverse\"</code>)","text":"<p>The core linear maps behind AD are:</p> <p>JVP (Jacobian\u2013vector product). For a tangent direction \\(v\\),</p> \\[ \\mathrm{JVP}_f(x; v) = J_f(x)\\,v. \\] <p>VJP (vector\u2013Jacobian product). For a cotangent \\(w\\),</p> \\[ \\mathrm{VJP}_f(x; w) = w^\\top J_f(x)\\quad(\\text{equivalently }J_f(x)^\\top w). \\] <p>Forward-mode AD is efficient when you need many JVPs (few input dimensions), while reverse-mode AD is efficient when you need many VJPs (few output dimensions). When constructing full Jacobians, Phydrax exposes this choice as:</p> <ul> <li><code>mode=\"forward\"</code>: <code>jax.jacfwd</code> (conceptually \u201ccolumns\u201d via JVPs),</li> <li><code>mode=\"reverse\"</code>: <code>jax.jacrev</code> (conceptually \u201crows\u201d via VJPs).</li> </ul> <p>Rule of thumb for pointwise Jacobians \\(J_f\\in\\mathbb{R}^{m\\times d}\\):</p> <ul> <li>prefer reverse-mode when \\(m\\ll d\\) (e.g. scalar outputs),</li> <li>prefer forward-mode when \\(d\\ll m\\).</li> </ul>"},{"location":"appendix/differentiation_modes/#22-higher-derivatives-via-nested-transforms","title":"2.2 Higher derivatives via nested transforms","text":"<p>Second derivatives can be formed by nesting Jacobian transforms. For example, for scalar-valued \\(u\\) and geometry variable \\(x\\in\\mathbb{R}^d\\),</p> \\[ \\nabla^2 u(x) \\;=\\; \\nabla_x(\\nabla_x u(x)), \\] <p>and the Laplacian is the trace</p> \\[ \\Delta u(x)\\;=\\;\\mathrm{tr}\\bigl(\\nabla^2 u(x)\\bigr)=\\sum_{i=1}^d \\frac{\\partial^2 u}{\\partial x_i^2}(x). \\] <p>Nesting AD is exact up to floating-point and provides mixed partials \\(\\partial_{x_i x_j}u\\) as well, but it can become expensive when building large Hessians or higher-order derivatives.</p>"},{"location":"appendix/differentiation_modes/#23-complex-valued-outputs","title":"2.3 Complex-valued outputs","text":"<p>For complex-valued outputs, Phydrax treats differentiation as real differentiation of the pair \\((\\operatorname{Re}u,\\operatorname{Im}u)\\), i.e. it computes Jacobians for real and imaginary parts separately and recombines them. This avoids relying on holomorphic assumptions and matches the \u201cdifferentiate \\(\\mathbb{R}^2\\)\u201d interpretation of complex numbers.</p>"},{"location":"appendix/differentiation_modes/#3-backendjet-taylor-mode-ad-derivative-jets","title":"3. <code>backend=\"jet\"</code>: Taylor-mode AD (derivative jets)","text":"<p>The jet backend computes higher-order directional derivatives by propagating a truncated Taylor series through the computation.</p> <p>Fix a smooth map \\(f\\) and a direction \\(v\\). Consider the 1D curve \\(y(\\epsilon)=f(x+\\epsilon v)\\). Its Taylor expansion is</p> \\[ f(x+\\epsilon v) = f(x) + \\sum_{k=1}^{K}\\frac{\\epsilon^k}{k!}\\,\\partial_v^k f(x) + O(\\epsilon^{K+1}). \\] <p>The jet backend returns the coefficients (directional derivatives) \\(\\bigl(\\partial_v^k f(x)\\bigr)_{k=1}^K\\) directly, using JAX\u2019s jet machinery (whose internal chain rules are governed by Fa\u00e0 di Bruno / Bell polynomial combinatorics).</p>"},{"location":"appendix/differentiation_modes/#31-pure-partial-derivatives-as-directional-derivatives","title":"3.1 Pure partial derivatives as directional derivatives","text":"<p>Pure \\(n\\)-th partial derivatives along a coordinate axis are directional derivatives with \\(v=e_i\\). For a geometry variable \\(x\\in\\mathbb{R}^d\\),</p> \\[ \\frac{\\partial^n f}{\\partial x_i^n}(x) \\;=\\; \\partial_{e_i}^n f(x). \\] <p>Similarly, for a scalar variable \\(t\\),</p> \\[ \\frac{d^n}{dt^n} f(t)\\;=\\;\\left.\\frac{d^n}{d\\epsilon^n} f(t+\\epsilon)\\right|_{\\epsilon=0}. \\] <p>This is exactly the situation targeted by <code>partial_n(..., backend=\"jet\")</code>, which is why jets are a natural fit for high-order derivatives with respect to a single labeled variable and a single axis.</p>"},{"location":"appendix/differentiation_modes/#32-what-jets-do-and-do-not-give-you-cheaply","title":"3.2 What jets do (and do not) give you cheaply","text":"<p>Jets provide efficient access to pure derivatives like \\(\\partial_{x_i}^n u\\). Mixed partials like \\(\\partial_{x_i}\\partial_{x_j}u\\) with \\(i\\neq j\\) are not directly obtained from a single 1D directional expansion; they require genuinely multi-directional information (and are typically constructed via nested AD / Hessians).</p>"},{"location":"appendix/differentiation_modes/#4-backendfd-finite-differences-on-coord-separable-grids","title":"4. <code>backend=\"fd\"</code>: finite differences on coord-separable grids","text":"<p>The finite-difference backend treats the field as sampled on a structured grid and replaces derivatives by local stencils. It is only used when the differentiated variable is provided as a tuple of 1D coordinate axes (coord-separable evaluation).</p>"},{"location":"appendix/differentiation_modes/#41-first-derivative-uniform-grid","title":"4.1 First derivative (uniform grid)","text":"<p>Let \\(x_i=x_0+i h\\) for \\(i=0,\\dots,N-1\\), and let \\(u_i\\approx u(x_i)\\). A common second-order central difference is</p> \\[ u'(x_i)\\approx \\frac{u_{i+1}-u_{i-1}}{2h}. \\] <p>For non-periodic boundaries, one-sided differences are used at endpoints, e.g.</p> \\[ u'(x_0)\\approx \\frac{u_1-u_0}{h},\\qquad u'(x_{N-1})\\approx \\frac{u_{N-1}-u_{N-2}}{h}. \\] <p>With <code>periodic=True</code>, the stencil wraps around and the central formula applies at all indices (circular shifts).</p>"},{"location":"appendix/differentiation_modes/#42-higher-derivatives-and-multi-d-tensor-grids","title":"4.2 Higher derivatives and multi-D tensor grids","text":"<p>Higher derivatives are obtained by repeated application of the 1D difference operator along the chosen axis. On a tensor-product grid in \\(d\\) dimensions, \u201cdifferentiate w.r.t. \\(x_i\\)\u201d means \u201capply the 1D stencil along the corresponding tensor axis while holding the other indices fixed\u201d, i.e. a Kronecker-structured operator of the form</p> \\[ D_{x_i}\\;\\approx\\; I\\otimes\\cdots\\otimes D \\otimes\\cdots\\otimes I. \\] <p>The Laplacian is then approximated by the sum of second derivatives along each axis:</p> \\[ \\Delta u \\;\\approx\\; \\sum_{i=1}^{d} \\frac{\\partial^2 u}{\\partial x_i^2}. \\] <p>Note</p> <p>The FD backend in Phydrax assumes uniform spacing along the differentiated axis and uses \\(h=x_1-x_0\\) from the provided coordinate array.</p>"},{"location":"appendix/differentiation_modes/#5-backendbasis-basis-aware-derivatives-on-structured-grids","title":"5. <code>backend=\"basis\"</code>: basis-aware derivatives on structured grids","text":"<p>The basis backend differentiates an implicit reconstruction of the function along each coord-separable axis:</p> <ul> <li>spectral derivatives (Fourier / sine / cosine) via FFT on uniform grids, or</li> <li>polynomial interpolation derivatives via barycentric differentiation on generic 1D grids.</li> </ul> <p>In all cases, the derivative along a chosen axis is a linear map applied to the sampled values along that axis.</p>"},{"location":"appendix/differentiation_modes/#51-fourier-spectral-derivatives-basisfourier","title":"5.1 Fourier spectral derivatives (<code>basis=\"fourier\"</code>)","text":"<p>Assume a periodic interval of length \\(L\\) and expand</p> \\[ u(x) = \\sum_{k\\in\\mathbb{Z}} \\hat u_k\\,e^{i 2\\pi k x/L}. \\] <p>Then</p> \\[ u^{(n)}(x) = \\sum_{k\\in\\mathbb{Z}} \\left(i\\frac{2\\pi k}{L}\\right)^n \\hat u_k\\,e^{i 2\\pi k x/L}. \\] <p>On a uniform grid, the coefficients \\(\\hat u_k\\) are approximated by the FFT, and differentiation becomes elementwise multiplication by \\(\\left(i k\\right)^n\\) in frequency space (up to the scaling that depends on the physical grid spacing).</p>"},{"location":"appendix/differentiation_modes/#52-sinecosine-bases-basissine-cosine","title":"5.2 Sine/cosine bases (<code>basis=\"sine\"</code> / <code>\"cosine\"</code>)","text":"<p>Sine and cosine bases can be understood as Fourier methods applied after symmetry extension:</p> <ul> <li>cosine: even extension (cosine series),</li> <li>sine: odd extension (sine series).</li> </ul> <p>The implementation performs the extension to a periodic array, differentiates via FFT in the extended domain, and then restricts back to the original grid.</p>"},{"location":"appendix/differentiation_modes/#53-polynomial-barycentric-differentiation-basispoly","title":"5.3 Polynomial / barycentric differentiation (<code>basis=\"poly\"</code>)","text":"<p>Let nodes \\(x_0,\\dots,x_{N-1}\\) be distinct (not necessarily uniform), with values \\(u_i=u(x_i)\\). The barycentric weights are</p> \\[ w_i = \\left(\\prod_{j\\ne i}(x_i-x_j)\\right)^{-1}. \\] <p>Define the first-derivative differentiation matrix \\(D\\in\\mathbb{R}^{N\\times N}\\) by</p> \\[ D_{ij} = \\begin{cases} \\dfrac{w_j}{w_i(x_i-x_j)} &amp; i\\ne j,\\\\ -\\sum\\limits_{j\\ne i} D_{ij} &amp; i=j. \\end{cases} \\] <p>Then the interpolant derivative at nodes satisfies</p> \\[ \\bigl(p'(x_0),\\dots,p'(x_{N-1})\\bigr)^\\top = D\\,(u_0,\\dots,u_{N-1})^\\top, \\] <p>where \\(p\\) is the unique polynomial interpolant with \\(p(x_i)=u_i\\). Higher derivatives can be obtained by repeated application of such differentiation matrices.</p> <p>Note</p> <p>Polynomial differentiation can be sensitive to node placement for large \\(N\\). For non-periodic smooth problems on \\([-1,1]\\), Chebyshev-like nodes typically behave far better than uniform nodes.</p>"},{"location":"appendix/differentiation_modes/#6-practical-guidance-what-to-use-when","title":"6. Practical guidance (what to use when)","text":"<p>Common choices:</p> <ul> <li>Point collocation (PINN-style): <code>backend=\"ad\"</code> (often with <code>mode=\"reverse\"</code> for scalar-valued PDE residuals).</li> <li>Structured grids / neural operators:</li> <li>use <code>backend=\"basis\"</code> for smooth fields matching the basis assumptions (especially periodic Fourier grids),</li> <li>use <code>backend=\"fd\"</code> for local, stencil-based discretizations or less-smooth signals.</li> <li>High-order derivatives in one variable (especially time derivatives of order \\(n\\ge 2\\)): <code>backend=\"jet\"</code> often   avoids the overhead of deeply nested Jacobian constructions.</li> </ul>"},{"location":"appendix/physics_constrained_interpolation/","title":"Physics-Constrained Interpolation (overlay pipeline)","text":"<p>This appendix formalizes the mathematics behind Phydrax\u2019s Physics-Constrained Interpolation (PCI) enforced overlay pipeline:</p> <ol> <li>boundary enforced constraints (possibly piecewise, via blending),</li> <li>initial constraints (possibly higher order in the evolution variable, and gated to preserve boundary constraints),</li> <li>interior exact data satisfaction via an anchor/data overlay stage while preserving boundary and initial constraints.</li> </ol> <p>Here \u201cPCI\u201d refers to the entire staged enforcement map \\(u\\mapsto \\tilde u\\); the final stage is the interior anchor/data overlay.</p> <p>The implementation corresponds to the staging performed by <code>EnforcedConstraintPipeline</code> / <code>EnforcedConstraintPipelines</code>, the enforced ans\u00e4tze in <code>phydrax.constraints</code> (e.g. Dirichlet/Neumann/Robin), the BVH-accelerated weight construction used for boundary blending, and the IDW-based interior anchor overlay.</p>"},{"location":"appendix/physics_constrained_interpolation/#a0-setting-and-notation","title":"A.0. Setting and notation","text":"<p>Let the computational domain be a product:</p> \\[ \\mathcal D \\;=\\; \\prod_{\\ell\\in\\mathcal L}\\mathcal D_\\ell, \\] <p>where \\(\\mathcal L\\) is a finite set of labels (e.g. \\(\\mathcal L=\\lbrace x,t\\rbrace\\) for space\u2013time). We write a point as \\(z=(z_\\ell)_{\\ell\\in\\mathcal L}\\).</p> <p>A field is a map \\(u:\\mathcal D\\to \\mathbb R^C\\). Phydrax represents a parameterized base field \\(u_\\theta\\) (a <code>DomainFunction</code>) and produces an enforced field \\(\\tilde u_\\theta\\) by applying a staged transformation:</p> \\[ \\mathcal P:\\ u \\mapsto \\tilde u. \\] <p>We consider three classes of enforced requirements:</p> <ul> <li>Boundary constraints: conditions on a boundary subset \\(S_B\\subset \\mathcal D\\), typically   \\(S_B=\\partial\\Omega\\times \\prod_{\\ell\\neq x}\\mathcal D_\\ell\\) for a geometry factor \\(\\Omega\\).</li> <li>Initial constraints: conditions on a fixed slice \\(S_I=\\lbrace t=t_0\\rbrace\\times \\prod_{\\ell\\neq t}\\mathcal D_\\ell\\).   Higher-order initial constraints fix \\(\\partial_t^k u(\\cdot,t_0)\\) for \\(k\\le K\\).</li> <li>Interior data: anchor requirements \\(\\tilde u(z_i)=y_i\\) for prescribed interior points \\(z_i\\in\\mathcal D\\),   optionally including time-dependent tracks \\(\\tilde u(x_m,t)=y_m(t)\\) for sensors \\(x_m\\).</li> </ul> <p>The central design goal is constraint preservation by construction: later stages must not re-violate earlier enforced constraints.</p>"},{"location":"appendix/physics_constrained_interpolation/#a1-enforced-constraints-as-constraint-preserving-operators","title":"A.1. Enforced constraints as constraint-preserving operators","text":"<p>Let \\(\\mathcal F\\) be a function space over \\(\\mathcal D\\). An enforced constraint defines a subset \\(\\mathcal C\\subset\\mathcal F\\) (e.g. functions satisfying Dirichlet boundary conditions).</p> <p>An operator \\(\\mathcal T:\\mathcal F\\to\\mathcal F\\) is \\(\\mathcal C\\)-preserving if:</p> \\[ u\\in\\mathcal C\\quad\\Rightarrow\\quad \\mathcal T(u)\\in\\mathcal C. \\] <p>The overlay pipeline is a composition:</p> \\[ \\tilde u \\;=\\; \\mathcal T_3\\bigl(\\mathcal T_2(\\mathcal T_1(u))\\bigr) \\] <p>where:</p> <ul> <li>\\(\\mathcal T_1\\) enforces boundary constraints (possibly piecewise-blended),</li> <li>\\(\\mathcal T_2\\) enforces initial constraints but is designed to be boundary-preserving,</li> <li>\\(\\mathcal T_3\\) enforces interior data while preserving boundary and initial constraints   (including derivative constraints up to specified orders).</li> </ul> <p>The remaining sections specify concrete constructions and the invariance proofs.</p>"},{"location":"appendix/physics_constrained_interpolation/#a2-boundary-enforced-ansatze","title":"A.2. Boundary enforced ans\u00e4tze","text":"<p>Let \\(\\Omega\\subset\\mathbb R^d\\) be a geometry factor with boundary \\(\\partial\\Omega\\). Assume a signed distance\u2013like function \\(\\phi:\\Omega\\to\\mathbb R\\) satisfying \\(\\phi=0\\) on \\(\\partial\\Omega\\), and an outward unit normal \\(n\\) on \\(\\partial\\Omega\\).</p> <p>The statements below are written in an ideal smooth setting; in practice Phydrax uses an approximate distance function and numerically defined boundary normals. Exactness claims should be interpreted as exact for the idealized \\(\\phi,n\\), and \u201cup to numerical tolerance\u201d in typical discretized settings.</p>"},{"location":"appendix/physics_constrained_interpolation/#a21-dirichlet-value-constraints","title":"A.2.1. Dirichlet (value) constraints","text":"<p>Given a target \\(g:\\partial\\Omega\\to\\mathbb R^C\\), define:</p> \\[ u^\\star(x)\\;=\\; g(x) + \\phi(x)\\,\\bigl(u(x)-g(x)\\bigr). \\] <p>Proposition A.1 (Dirichlet exactness). If \\(\\phi=0\\) on \\(\\partial\\Omega\\), then \\(u^\\star=g\\) on \\(\\partial\\Omega\\).</p> <p>Proof. For \\(x\\in\\partial\\Omega\\), \\(\\phi(x)=0\\) implies \\(u^\\star(x)=g(x)\\). \\(\\square\\)</p>"},{"location":"appendix/physics_constrained_interpolation/#a22-neumann-normal-derivative-constraints","title":"A.2.2. Neumann (normal derivative) constraints","text":"<p>Given a target \\(g:\\partial\\Omega\\to\\mathbb R^C\\) for \\(\\partial_n u=g\\), define:</p> \\[ u^\\star \\;=\\; u + \\frac{\\phi}{\\partial_n\\phi}\\,\\bigl(g-\\partial_n u\\bigr). \\] <p>Proposition A.2 (Neumann exactness). Assume \\(u,\\phi\\) are differentiable and \\(\\partial_n\\phi\\neq 0\\) on \\(\\partial\\Omega\\). Then \\(\\partial_n u^\\star=g\\) on \\(\\partial\\Omega\\).</p> <p>Proof. Differentiate along \\(n\\):</p> \\[ \\partial_n u^\\star =\\partial_n u + \\partial_n\\left(\\frac{\\phi}{\\partial_n\\phi}\\right)\\bigl(g-\\partial_n u\\bigr) + \\frac{\\phi}{\\partial_n\\phi}\\bigl(\\partial_n g - \\partial_n\\partial_n u\\bigr). \\] <p>On \\(\\partial\\Omega\\), \\(\\phi=0\\) annihilates the last term. Moreover,</p> \\[ \\partial_n\\left(\\frac{\\phi}{\\partial_n\\phi}\\right) =\\frac{\\partial_n\\phi}{\\partial_n\\phi}+\\phi\\cdot(\\cdots)=1 \\quad\\text{on }\\partial\\Omega. \\] <p>Hence \\(\\partial_n u^\\star=\\partial_n u + (g-\\partial_n u)=g\\) on \\(\\partial\\Omega\\). \\(\\square\\)</p>"},{"location":"appendix/physics_constrained_interpolation/#a23-robin-mixed-constraints","title":"A.2.3. Robin (mixed) constraints","text":"<p>For \\(a\\,u + b\\,\\partial_n u = g\\) on \\(\\partial\\Omega\\), one may use the analogous correction:</p> \\[ u^\\star \\;=\\; u + \\frac{\\phi}{b\\,\\partial_n\\phi}\\,\\bigl(g-a\\,u-b\\,\\partial_n u\\bigr), \\] <p>under the nondegeneracy assumption \\(b\\,\\partial_n\\phi\\neq 0\\) on \\(\\partial\\Omega\\). The proof is the same as Proposition A.2: the correction term vanishes on the boundary but has the correct first normal derivative to cancel the residual of the Robin operator.</p>"},{"location":"appendix/physics_constrained_interpolation/#a24-approximate-distance-field-adf-and-blur","title":"A.2.4. Approximate distance field (ADF) and blur","text":"<p>PCI relies on a signed distance\u2013like function \\(\\phi\\) to build boundary factors and normals. Phydrax constructs a smooth approximate distance field (ADF) from a mesh and, by default, applies a local Gaussian blur to improve stability of downstream derivatives.</p>"},{"location":"appendix/physics_constrained_interpolation/#a241-base-smooth-distance-mesh-adf","title":"A.2.4.1. Base smooth distance (mesh ADF)","text":"<p>Let \\(\\mathcal M\\) be a triangulated surface defining \\(\\partial\\Omega\\). For each query point \\(x\\), Phydrax computes a smooth proxy distance by combining candidate triangle distances with a soft-min:</p> \\[ d(x)\\;\\approx\\;\\operatorname{softmin}_\\beta\\{\\,d_T(x)\\,\\}_{T\\in\\mathcal C(x)}, \\] <p>where \\(d_T(x)\\) is the point-to-triangle distance and \\(\\mathcal C(x)\\) is a BVH-selected candidate set (beam traversal of a packed AABB tree). The softness parameter \\(\\beta&gt;0\\) controls the sharpness of the soft-min; smaller \\(\\beta\\) yields a smoother blend of nearby triangle distances.</p> <p>For 2D geometries built from CAD, Phydrax extrudes the mesh to 3D and evaluates the 3D ADF away from end caps so that the resulting distance coincides with the 2D boundary distance on the side walls.</p> <p>An optional squash transform can be applied:</p> \\[ \\rho(s)=\\delta\\,\\operatorname{tanh}\\!\\left(\\frac{s}{\\delta}\\right), \\] <p>which is linear near \\(s=0\\) but saturates in the interior to limit curvature. The unsquashed field (pre-\\(\\operatorname{tanh}\\)) is exposed as <code>adf_orig</code>.</p>"},{"location":"appendix/physics_constrained_interpolation/#a242-local-adf-blur","title":"A.2.4.2. Local ADF blur","text":"<p>Given a base field \\(\\phi_{\\text{orig}}\\) (typically <code>adf_orig</code>), the blurred ADF is defined by sampling in a local neighborhood:</p> \\[ \\phi_{\\text{blur}}(x) = \\frac{\\phi_{\\text{orig}}(x)+\\sum_{i=1}^m w_i(x)\\,\\phi_{\\text{orig}}(x+r(x)u_i)} {1+\\sum_{i=1}^m w_i(x)}. \\] <p>Here \\((u_i)\\) are deterministic offsets on the unit disk (2D Fibonacci disk) or unit ball (3D Fibonacci sphere with radial stratification). The radius is adaptive:</p> \\[ r(x)=\\max\\!\\bigl(\\sqrt{\\phi_{\\text{orig}}(x)^2+\\varepsilon^2}-\\varepsilon,\\ r_{\\min}\\bigr), \\] <p>and the Gaussian weights are</p> \\[ w_i(x)=\\exp\\!\\left(-\\frac{\\|r(x)\\,u_i\\|^2}{2(\\sigma\\,r(x))^2+\\varepsilon}\\right), \\] <p>with \\(\\sigma=\\texttt{sigma_scale}\\). The parameters \\((\\varepsilon,r_{\\min})\\) prevent numerical instabilities and collapse of the kernel near the boundary.</p> <p>Implementation note. By default, <code>geom.adf</code> is set to the blurred field \\(\\phi_{\\text{blur}}=\\texttt{adf_blur}(\\texttt{adf_orig})\\), while <code>adf_orig</code> provides the unsquashed base field. Thus enforced boundary ans\u00e4tze use the blurred ADF by default.</p>"},{"location":"appendix/physics_constrained_interpolation/#a3-piecewise-boundary-constraints-and-blending","title":"A.3. Piecewise boundary constraints and blending","text":"<p>Boundary conditions are commonly specified piecewise on disjoint boundary subsets \\(\\Gamma_1,\\dots,\\Gamma_m\\subset\\partial\\Omega\\). For each \\(\\Gamma_i\\) one can build an ansatz \\(u_i^\\star=\\mathcal H_i(u)\\) that satisfies the desired condition on \\(\\Gamma_i\\). The pipeline then combines them into a single enforced field by weighted blending:</p> \\[ u_B(x) = \\frac{\\sum_{i=1}^m w_i(x)\\,u_i^\\star(x)\\;+\\;w_{\\text{rem}}(x)\\,u(x)} {\\sum_{i=1}^m w_i(x)\\;+\\;w_{\\text{rem}}(x)}. \\] <p>The optional remainder weight \\(w_{\\text{rem}}\\) is supported on the complement of the union of the boundary subsets and prevents subset constraints from \u201cleaking\u201d to other segments.</p>"},{"location":"appendix/physics_constrained_interpolation/#a31-exactness-under-weight-dominance","title":"A.3.1. Exactness under weight dominance","text":"<p>To make the blend exact on each piece, it suffices that the weights dominate near the corresponding subset.</p> <p>Assumption A.1 (dominant weights). For each \\(k\\), \\(w_k(x)\\to +\\infty\\) as \\(x\\to\\Gamma_k\\), while every \\(w_j\\) with \\(j\\neq k\\) and \\(w_{\\text{rem}}\\) remain bounded in a neighborhood of \\(\\Gamma_k\\).</p> <p>Proposition A.3 (piecewise exactness). Under Assumption A.1 and continuity of \\(u_i^\\star\\), the blended field has the same boundary trace as the dominant piece on \\(\\Gamma_k\\) (i.e. \\(u_B\\to u_k^\\star\\) as \\(x\\to\\Gamma_k\\) away from junction sets where multiple pieces meet):</p> \\[ u_B|_{\\Gamma_k} = u_k^\\star|_{\\Gamma_k}. \\] <p>Consequently, if \\(u_k^\\star\\) satisfies the desired enforced boundary condition on \\(\\Gamma_k\\), so does \\(u_B\\).</p> <p>Proof. Write \\(u_B=(w_k u_k^\\star + R)/(w_k+r)\\) where \\(R=\\sum_{j\\neq k}w_j u_j^\\star+w_{\\text{rem}}u\\) and \\(r=\\sum_{j\\neq k}w_j+w_{\\text{rem}}\\). By Assumption A.1, \\(R/w_k\\to 0\\) and \\(r/w_k\\to 0\\) as \\(x\\to\\Gamma_k\\). Thus \\(u_B\\to u_k^\\star\\) as \\(x\\to\\Gamma_k\\) (and hence their boundary traces agree). \\(\\square\\)</p>"},{"location":"appendix/physics_constrained_interpolation/#a32-how-the-weights-are-constructed-mls-bvh","title":"A.3.2. How the weights are constructed (MLS + BVH)","text":"<p>In Phydrax, each \\(w_i\\) is derived from a distance-to-subset proxy \\(\\rho_i(x)\\ge 0\\) with \\(\\rho_i=0\\) on \\(\\Gamma_i\\), typically via an inverse-square law \\(w_i(x)\\propto (\\rho_i(x)+\\varepsilon)^{-2}\\).</p> <p>The proxy \\(\\rho_i\\) is computed from a dense reference sample \\(P=\\lbrace p_j\\rbrace\\subset\\Gamma_i\\) and associated outward normals \\(\\lbrace n_j\\rbrace\\). For a query point \\(x\\), the implementation computes an oriented MLS projection distance</p> \\[ f(x)=\\sum_{j\\in\\mathcal N(x)} \\alpha_j(x)\\,\\langle n_j,\\,x-p_j\\rangle, \\] <p>where \\(\\alpha_j(x)\\) are nonnegative weights concentrating on nearby points and penalizing normal mismatch. Then \\(\\rho(x)\\) is obtained from \\(f(x)\\) by a smooth nonnegative transformation (a softplus-based absolute distance).</p> <p>A naive MLS evaluation would require scanning all reference points. Instead, neighbor candidates \\(\\mathcal N(x)\\) are chosen using a static AABB BVH (bounding volume hierarchy) built over \\(P\\). The BVH provides a fast approximate nearest-neighbor primitive: it restricts the MLS sum to a candidate set. If that candidate set contains all points with non-negligible kernel weight (in a chosen tolerance sense), the BVH-accelerated estimate approximates the full MLS distance; in the limit of exhaustive search (beam width \\(\\to\\infty\\)), it matches the full neighborhood evaluation.</p>"},{"location":"appendix/physics_constrained_interpolation/#a33-junction-sets-and-compatibility","title":"A.3.3. Junction sets and compatibility","text":"<p>The \u201cdominant weight\u201d argument above is valid away from points where multiple pieces touch. Define the junction set:</p> \\[ J \\;=\\; \\bigcup_{i\\neq j}\\left(\\overline{\\Gamma_i}\\cap\\overline{\\Gamma_j}\\right). \\] <p>At points of \\(J\\), distances (and thus weights) for two or more pieces may vanish simultaneously, so no single piece need dominate. Rigorous everywhere exactness therefore requires additional compatibility or a priority rule:</p> <ul> <li>If the boundary data are compatible on \\(J\\) (e.g. Dirichlet targets agree on overlaps), then any limiting blend yields   the same boundary trace there.</li> <li>If the data are incompatible on \\(J\\), then no single-valued field can satisfy all piecewise constraints simultaneously   on \\(J\\); any construction must either (i) define a priority convention on \\(J\\), or (ii) accept that exactness is claimed   only on each \\(\\Gamma_k\\setminus J\\) (a standard relaxation since \\(J\\) is lower-dimensional).</li> </ul>"},{"location":"appendix/physics_constrained_interpolation/#a4-the-bvh-structure-and-beam-traversal-packed-aabb-tree","title":"A.4. The BVH structure and beam traversal (packed AABB tree)","text":"<p>Phydrax\u2019s BVH is a packed binary AABB tree with:</p> <ul> <li>node arrays storing bounding boxes and child links,</li> <li>fixed-size leaf payload arrays storing item indices (with padding),</li> <li>a beam traversal that keeps the best \\(B\\) nodes according to AABB lower bounds.</li> </ul> <p>Mathematically, for a node with AABB \\([b_{\\text{min}},b_{\\text{max}}]\\subset\\mathbb R^d\\), the squared distance lower bound from a query \\(x\\) is:</p> \\[ d^2_{\\text{AABB}}(x,[b_{\\text{min}},b_{\\text{max}}]) = \\sum_{k=1}^d \\bigl(\\mathop{\\text{max}}\\left\\lbrace 0,\\,b_{\\text{min},k}-x_k,\\,x_k-b_{\\text{max},k}\\right\\rbrace\\bigr)^2. \\] <p>This is a lower bound on the squared distance to any point inside the node\u2019s subtree.</p> <p>Beam traversal uses this bound to choose a small set of candidate leaves, then returns their payload items. In the limit of infinite beam width (or in settings where the relevant neighbors always lie within the selected leaves), the BVH-accelerated method is identical to an exact neighborhood search. For finite beam width it is an approximation, and its accuracy depends on whether the candidate set captures the effective support of the MLS kernel.</p>"},{"location":"appendix/physics_constrained_interpolation/#a5-higher-order-initial-constraints-via-a-hermitetaylor-ansatz","title":"A.5. Higher-order initial constraints via a Hermite/Taylor ansatz","text":"<p>Let \\(t\\) be the evolution variable with an initial slice \\(t=t_0\\). Suppose we want to enforce, for a given integer \\(K\\ge 0\\):</p> \\[ \\partial_t^k u(\\cdot,t_0)=g_k(\\cdot),\\qquad k=0,1,\\dots,K. \\] <p>Define the truncated Taylor polynomial:</p> \\[ P_K(t)=\\sum_{k=0}^{K}\\frac{(t-t_0)^k}{k!}\\,g_k, \\] <p>and define the enforced initial ansatz:</p> \\[ u_I(t)=P_K(t) + (t-t_0)^{K+1}\\bigl(u(t)-P_K(t)\\bigr). \\] <p>Proposition A.4 (exact initial derivatives). Assume \\(u\\) is \\(K+1\\) times differentiable in \\(t\\). Then \\(\\partial_t^k u_I(\\cdot,t_0)=g_k(\\cdot)\\) for \\(k=0,\\dots,K\\).</p> <p>Proof. The correction term \\((t-t_0)^{K+1}(u-P_K)\\) has a factor \\((t-t_0)^{K+1}\\), so all of its derivatives up to order \\(K\\) vanish at \\(t=t_0\\). Therefore \\(\\partial_t^k u_I(t_0)=\\partial_t^k P_K(t_0)=g_k\\). \\(\\square\\)</p> <p>This construction is used as the \u201cinitial target overlay\u201d when multiple initial derivative targets are specified.</p>"},{"location":"appendix/physics_constrained_interpolation/#a6-mixed-boundaryinitial-constraints-and-the-boundary-gate","title":"A.6. Mixed boundary/initial constraints and the boundary gate","text":"<p>Boundary and initial sets intersect (e.g. \\(\\partial\\Omega\\times\\lbrace t_0\\rbrace\\)). In PDE theory, exact satisfaction of both requires compatibility conditions on the intersection; incompatible data cannot be enforced simultaneously.</p> <p>The pipeline resolves the interaction by a staged priority:</p> <ol> <li>Enforce boundary constraints first to obtain \\(u_B\\).</li> <li>Compute an initial-enforced candidate \\(u_{\\text{init}}\\) from \\(u_B\\).</li> <li>Blend the update through a boundary gate \\(\\gamma\\) that vanishes on the constrained boundary.</li> </ol> \\[ u_{BI} \\;=\\; u_B + \\gamma\\,(u_{\\text{init}}-u_B). \\] <p>This guarantees boundary constraints remain satisfied by construction because the update is identically zero on the boundary. The gate is chosen to vanish to sufficiently high order to preserve boundary constraints involving spatial derivatives up to a prescribed order.</p> <p>Remark (initial exactness tradeoff). If the initial-enforcement map produces a candidate with \\(u_{\\text{init}}(\\cdot,t_0)=g_0(\\cdot)\\), then on the initial slice:</p> \\[ u_{BI}(\\cdot,t_0)=u_B(\\cdot,t_0) + \\gamma(\\cdot)\\,\\bigl(g_0-u_B(\\cdot,t_0)\\bigr). \\] <p>Unless \\(\\gamma\\equiv 1\\) away from the boundary (or \\(u_B(\\cdot,t_0)=g_0\\) already), this blend relaxes exact initial enforcement near the boundary in order to preserve boundary constraints. In Phydrax\u2019s implementation, \\(\\gamma\\) is smooth, vanishes to high order on the boundary, and tends to \\(1\\) with increasing distance, so initial constraints are typically satisfied approximately away from the boundary (subject to compatibility at \\(\\partial\\Omega\\times\\lbrace t_0\\rbrace\\)).</p>"},{"location":"appendix/physics_constrained_interpolation/#a61-vanishing-order-lemma-derivative-preservation","title":"A.6.1. Vanishing-order lemma (derivative preservation)","text":"<p>Let \\(s\\) be a local normal coordinate to \\(\\partial\\Omega\\) (e.g. \\(s=\\phi(x)\\)). Consider an update:</p> \\[ u_{\\text{new}} = u + \\gamma(s)\\,(v-u), \\] <p>where \\(\\gamma(0)=0\\).</p> <p>Lemma A.5 (preservation by high-order vanishing). If \\(\\gamma(s)=\\mathcal O(|s|^{m})\\) as \\(s\\to 0\\), then for every integer \\(0\\le k\\le m-1\\):</p> \\[ \\partial_s^k u_{\\text{new}}(0) = \\partial_s^k u(0), \\] <p>provided the derivatives exist.</p> <p>Proof. Write \\(u_{\\text{new}}-u=\\gamma(s)\\,w(s)\\) with \\(w=v-u\\). By Leibniz\u2019 rule, each \\(\\partial_s^k\\bigl(\\gamma w\\bigr)\\) is a sum of terms \\((\\partial_s^j\\gamma)(\\partial_s^{k-j}w)\\). If \\(\\gamma=\\mathcal O(|s|^m)\\), then \\(\\partial_s^j\\gamma(0)=0\\) for all \\(j\\le m-1\\), implying all such terms vanish at \\(s=0\\) when \\(k\\le m-1\\). \\(\\square\\)</p> <p>Thus, by choosing \\(\\gamma\\) to vanish to order \\(m\\ge K+1\\), the blend preserves boundary operators involving derivatives up to order \\(K\\) in the boundary-normal direction.</p>"},{"location":"appendix/physics_constrained_interpolation/#a7-interior-exact-data-satisfaction-anchordata-overlay-stage","title":"A.7. Interior exact data satisfaction (anchor/data overlay stage)","text":"<p>After boundary and initial staging in the PCI pipeline, the interior anchor/data overlay enforces interior data exactly at specified anchors/tracks while preserving boundary and initial constraints (including derivative constraints up to specified orders).</p>"},{"location":"appendix/physics_constrained_interpolation/#a71-interior-anchors-and-optional-tracks","title":"A.7.1. Interior anchors and (optional) tracks","text":"<p>Anchor mode. Given points \\(z_i\\in\\mathcal D\\) and targets \\(y_i\\in\\mathbb R^C\\), we require:</p> \\[ \\tilde u(z_i)=y_i. \\] <p>Sensor-track mode. Given fixed sensors \\(x_m\\) and time-dependent observations \\(y_m(t)\\), we require:</p> \\[ \\tilde u(x_m,t)=y_m(t). \\] <p>where \\(y_m\\) is represented by an interpolant (e.g. a cubic Hermite spline in time).</p>"},{"location":"appendix/physics_constrained_interpolation/#a72-the-protecting-gate-mz","title":"A.7.2. The protecting gate M(z)","text":"<p>Let boundary constraints for a geometry label \\(\\ell=x\\) involve derivatives up to order \\(K_x\\) (e.g. Dirichlet: \\(K_x=0\\), Neumann/Robin: \\(K_x=1\\)). Let initial constraints fix time derivatives up to order \\(K_t\\).</p> <p>Define a gate:</p> \\[ M(z) = \\Bigl(\\prod_{\\ell\\in\\mathcal B} |\\phi_\\ell(z_\\ell)|^{K_\\ell+1}\\Bigr) \\cdot (\\mathop{\\text{max}}(t-t_0,0))^{K_t+1}, \\] <p>with \\(\\mathcal B\\subseteq \\mathcal L\\) the set of geometry labels with boundary constraints and \\(\\phi_\\ell\\) a signed distance\u2013like function for that geometry factor.</p> <p>On domains where \\(t\\ge t_0\\) identically, \\(\\mathop{\\text{max}}(t-t_0,0)=t-t_0\\), so this reduces to \\((t-t_0)^{K_t+1}\\). The \\(\\text{max}\\) form is convenient to keep \\(M\\) nonnegative and real-valued.</p> <p>Key properties:</p> <ul> <li>\\(M(z)=0\\) on constrained boundary sets (where \\(\\phi_\\ell=0\\)),</li> <li>\\(M(z)=0\\) on the initial slice \\(t=t_0\\),</li> <li>\\(M\\) vanishes to high enough order so that derivatives of \\(M(\\cdot)h(\\cdot)\\) up to the constrained orders also vanish   on those sets (formalized below).</li> </ul> <p>Anchors/tracks are required to satisfy \\(M(z_i)&gt;0\\); placing an interior anchor on a constrained set is incompatible with the goal of preserving those enforced constraints.</p>"},{"location":"appendix/physics_constrained_interpolation/#a73-idw-interpolation-of-the-scaled-residual","title":"A.7.3. IDW interpolation of the scaled residual","text":"<p>Let \\(u\\) be the field after boundary/initial stages. For anchors \\(z_i\\) with targets \\(y_i\\), define scaled residuals:</p> \\[ r_i = \\frac{y_i - u(z_i)}{M(z_i)}. \\] <p>Define a (possibly anisotropic) squared distance on \\(\\mathcal D\\) with per-label lengthscales \\(\\ell_\\alpha&gt;0\\):</p> \\[ d(z,z_i)^2=\\sum_{\\alpha\\in\\mathcal L}\\left\\lVert\\frac{z_\\alpha-z_{i,\\alpha}}{\\ell_\\alpha}\\right\\rVert^2. \\] <p>For an IDW exponent \\(p&gt;0\\), define weights:</p> \\[ w_i(z)\\propto \\bigl(d(z,z_i)^2+\\varepsilon\\bigr)^{-p/2}, \\qquad \\sum_i w_i(z)=1. \\] <p>The interior overlay defines:</p> \\[ \\tilde u(z) = u(z) + M(z)\\sum_i w_i(z)\\,r_i. \\] <p>This is an interpolation of the scaled residual field \\(r\\), multiplied by the protecting gate \\(M\\).</p>"},{"location":"appendix/physics_constrained_interpolation/#a74-exact-anchor-satisfaction-snap-rule","title":"A.7.4. Exact anchor satisfaction (snap rule)","text":"<p>In exact arithmetic, the IDW interpolant need not satisfy \\(w_i(z_i)=1\\) (it typically satisfies this only in the limit \\(\\varepsilon\\to 0\\) with exact evaluation). The implementation therefore uses a snap rule: if a query is closer than a prescribed threshold \\(\\varepsilon_{\\text{snap}}\\) to an anchor, the weight becomes one-hot.</p> <p>Proposition A.6 (exactness at anchors under snapping). Suppose \\(M(z_k)&gt;0\\) and \\(w_k(z_k)=1\\). Then \\(\\tilde u(z_k)=y_k\\).</p> <p>Proof. Evaluate the overlay at \\(z=z_k\\):</p> <p>[ \\begin{aligned} \\tilde u(z_k) &amp;= u(z_k) + M(z_k)\\,r_k \\ &amp;= u(z_k) + M(z_k)\\frac{y_k-u(z_k)}{M(z_k)} \\ &amp;= y_k. \\end{aligned} ] \\(\\square\\)</p>"},{"location":"appendix/physics_constrained_interpolation/#a75-preservation-of-boundary-and-initial-constraints","title":"A.7.5. Preservation of boundary and initial constraints","text":"<p>The interior correction has the form \\(\\Delta u(z)=M(z)\\,h(z)\\) where \\(h(z)=\\sum_i w_i(z)r_i\\).</p> <p>Lemma A.7 (vanishing factor kills derivatives). Let \\(s\\mapsto \\eta(s)=|s|^{m}\\) for an integer \\(m\\ge 1\\). If \\(h\\) is \\(C^{m-1}\\) near \\(s=0\\), then for every integer \\(0\\le k\\le m-1\\),</p> \\[ \\frac{d^k}{ds^k}\\bigl[\\eta(s)\\,h(s)\\bigr]\\Big|_{s=0}=0. \\] <p>Proof. By Leibniz\u2019 rule, every term in the \\(k\\)-th derivative contains a factor \\(|s|^{m-j}\\) with \\(m-j\\ge 1\\) when \\(k\\le m-1\\), and therefore vanishes at \\(s=0\\). \\(\\square\\)</p> <p>Remark (regularity of the gate). For integer \\(m\\ge 1\\), \\(\\eta(s)=|s|^m\\) is \\(C^{m-1}\\) at \\(s=0\\) (and smooth if \\(m\\) is even), which is exactly the regularity needed to conclude preservation of derivatives through order \\(m-1\\).</p> <p>Remark (mixed derivatives). In local coordinates \\((s,y)\\) near the boundary (normal \\(s\\) and tangential \\(y\\)), any differential operator involving at most \\(m-1\\) derivatives in \\(s\\) annihilates \\(\\eta(s)\\,h(s,y)\\) at \\(s=0\\); tangential derivatives act on \\(h\\) and do not reduce the vanishing order in \\(s\\). The product structure of \\(M(z)\\) yields the analogous preservation on boundary\u2013initial intersections for mixed normal/time derivatives up to the prescribed orders, assuming the corresponding derivatives exist.</p> <p>Applying this lemma with \\(m=K_\\ell+1\\) for each boundary label \\(\\ell\\) and \\(m=K_t+1\\) for time implies:</p> <ul> <li>the interior overlay does not change the value of \\(u\\) on boundary/initial sets where \\(M=0\\),</li> <li>it also does not change derivatives up to order \\(K_\\ell\\) (resp. \\(K_t\\)) on those sets, provided the relevant derivatives exist.</li> </ul> <p>Consequently, if the boundary and initial stages have produced \\(u\\) satisfying the enforced constraints up to those orders, then \\(\\tilde u=u+\\Delta u\\) satisfies them as well.</p>"},{"location":"appendix/physics_constrained_interpolation/#a76-multiple-sources-envelopes-and-coincidence-handling","title":"A.7.6. Multiple sources, envelopes, and coincidence handling","text":"<p>When multiple data sources are present, Phydrax optionally multiplies IDW weights by a source-local envelope \\(\\psi_s(z)=\\exp(-d_s(z)^2/s^2)\\), where \\(d_s(z)\\) is the distance to the nearest anchor from source \\(s\\). This allows localized influence while preserving exactness at snapped anchors.</p> <p>If anchors from different sources are coincident (according to the same snap metric used at runtime), they are deduplicated. Conflicting coincident targets are rejected: exact enforcement of incompatible pointwise data is not possible.</p>"},{"location":"appendix/physics_constrained_interpolation/#a8-multi-field-pipelines-co-variables-and-topological-ordering","title":"A.8. Multi-field pipelines, co-variables, and topological ordering","text":"<p>For a vector of fields \\((u^{(1)},\\dots,u^{(M)})\\), an enforced constraint for one field may require access to other fields (co-variables). This defines a directed dependency graph on field names. If the graph is acyclic, there exists a topological order \\(u^{(i_1)},\\dots,u^{(i_M)}\\) such that every co-variable needed for enforcing \\(u^{(i_k)}\\) has been enforced earlier in the order.</p> <p>Applying per-field pipelines in this order yields a well-defined global enforcement map:</p> \\[ \\mathcal P:\\ (u^{(1)},\\dots,u^{(M)})\\mapsto (\\tilde u^{(1)},\\dots,\\tilde u^{(M)}). \\] <p>If the dependency graph contains a cycle, a global deterministic enforcement map cannot be defined without additional fixed-point structure; the implementation rejects such cycles.</p>"},{"location":"appendix/physics_constrained_interpolation/#a9-compatibility-and-scope-conditions","title":"A.9. Compatibility and scope conditions","text":"<p>For the strongest \u201cexactness\u201d statements, the following conditions are essential:</p> <ol> <li>Compatibility on junctions and intersections. Piecewise boundary data must be compatible on junction sets    \\(J=\\bigcup_{i\\neq j}(\\overline{\\Gamma_i}\\cap\\overline{\\Gamma_j})\\) if exact satisfaction is desired there, and boundary    and initial data must be compatible on their intersection (e.g. \\(\\partial\\Omega\\times\\lbrace t_0\\rbrace\\)); otherwise,    no construction can satisfy all requirements simultaneously. The staging priority enforces boundary constraints exactly    and uses gates to avoid re-violating them.</li> <li>Nondegeneracy. Neumann/Robin constructions require \\(\\partial_n\\phi\\neq 0\\) on \\(\\partial\\Omega\\).</li> <li>Anchor placement. Interior anchors/tracks must lie strictly away from constrained sets so that \\(M(z_i)&gt;0\\).</li> <li>Regularity. To preserve derivative constraints through order \\(K\\), the gate factors and the field must admit    the corresponding derivatives (at least \\(C^K\\) in the relevant coordinates).</li> <li>Gating tradeoff. If the boundary gate \\(\\gamma\\) is not identically \\(1\\) away from the boundary, then the gated blend    cannot preserve boundary constraints and enforce initial constraints exactly everywhere simultaneously; instead, initial    constraints are typically satisfied approximately away from the boundary.</li> <li>Approximation layers. BVH selection, MLS distance proxies, and approximate distance fields introduce numerical    approximation. The mathematical statements above should be interpreted either in the idealized continuous limit or as    \u201cup to numerical tolerance\u201d for practical computations.</li> </ol>"},{"location":"appendix/physics_constrained_interpolation/#a10-correspondence-to-the-implementation-terminology","title":"A.10. Correspondence to the implementation (terminology)","text":"<p>The following implementation concepts align with the mathematics above:</p> <ul> <li>Boundary stage: piecewise constraints combined via weighted blending \\(u_B\\).</li> <li>Initial stage: higher-order <code>enforce_initial</code> overlay and/or other initial enforced constraints, blended via a boundary gate \\(\\gamma\\).</li> <li>Interior stage: anchor/data correction \\(u\\mapsto u + M\\cdot(\\text{IDW interpolant of scaled residuals})\\) (with snapping for exact anchors).</li> <li>BVH: packed AABB tree used to accelerate boundary-subset weight evaluation for blending.</li> </ul>"},{"location":"appendix/surely_youre_joking/","title":"Surely You're Joking!","text":"<p>This appendix gives intuition and background for Phydrax\u2019s FeynmaNN architecture (<code>phydrax/nn/models/architectures/_feynmann.py</code>). The name is a nod to Feynman\u2019s \u201csum over histories\u201d viewpoint: many contributions, each carrying a phase, combine by interference.</p> <p>This is architectural inspiration, not a claim that the model is literally implementing quantum mechanics.</p>"},{"location":"appendix/surely_youre_joking/#1-the-path-integral-intuition-in-one-minute","title":"1) The path-integral intuition (in one minute)","text":"<p>In Feynman\u2019s path-integral picture, a quantity is written schematically as</p> \\[ \\text{(quantity)} \\approx \\int \\exp(i\\,\\text{action}) \\;(\\text{contribution})\\; d(\\text{paths}), \\] <p>and the key phenomenon is interference: phases can make contributions add constructively or cancel.</p> <p>Another useful picture is phasors: each \u201cpath\u201d contributes a little arrow in the complex plane. The factor \\(\\exp(i\\,\\text{action})\\) is a unit-length rotation of that arrow. The integral (or sum) adds all these arrows. If the phase varies wildly across paths, the arrows point in many directions and mostly cancel; if the phase is locally coherent, contributions align and survive. This \u201crapidly varying phase cancels out\u201d intuition is the heart of why path integrals produce sharp, structured behavior without needing any single contribution to be huge.</p> <p>FeynmaNN borrows exactly this motif: it replaces the continuum of paths by a small set of learnable contributions, and learns phase modulation so the model can switch between reinforcement and cancellation depending on the current state.</p> <p>In numerics, integrals are often approximated by finite sums. FeynmaNN takes the same \u201csum of phase-modulated contributions\u201d motif and turns it into a learnable neural building block.</p>"},{"location":"appendix/surely_youre_joking/#2-feynmann-in-one-equation","title":"2) FeynmaNN in one equation","text":"<p>FeynmaNN builds and updates a complex latent state \\(z \\in \\mathbb{C}^n\\) using a repeated \u201csum-over-paths\u201d block:</p> \\[ z \\;\\mapsto\\; \\sum_{k=1}^{K} g_k \\, e^{i\\,\\alpha_k(z)} \\, (W_k z + b_k), \\] <p>where:</p> <ul> <li>\\(K\\) is the number of \u201cpaths\u201d (think: experts / branches / histories).</li> <li>Each path has its own complex affine transform \\(W_k z + b_k\\).</li> <li>\\(g_k \\ge 0\\) are mixing weights with \\(\\sum_k g_k = 1\\).</li> <li>\\(\\alpha_k(z)\\in\\mathbb{R}\\) are learned phases (an \u201caction-like\u201d quantity), typically produced by a small real network that   looks at \\((\\Re z, \\Im z)\\).</li> <li>\\(e^{i\\alpha_k(z)}\\) is what makes the sum behave differently from an ordinary mixture: it enables cancellation, not just blending.</li> </ul> <p>After each block, FeynmaNN applies a complex nonlinearity (ModReLU) and repeats for <code>depth</code> layers, then maps the final complex latent to the requested output.</p>"},{"location":"appendix/surely_youre_joking/#3-what-phases-buy-you-learned-interference","title":"3) What phases buy you: learned interference","text":"<p>Most mixture mechanisms are magnitude-only: they blend contributions. Phases add a second control axis:</p> <ul> <li>Constructive interference: phases align and contributions reinforce.</li> <li>Destructive interference: phases oppose and contributions cancel.</li> <li>State-dependent combination: because \\(\\alpha(z)\\) depends on the current latent, which paths reinforce/cancel can change   across the input domain.</li> </ul> <p>This is a natural inductive bias for targets with oscillatory or interference-like structure (even when the final output is real): waves, resonances, dispersive responses, multi-scale signals, and fields with sharp phase changes.</p>"},{"location":"appendix/surely_youre_joking/#4-action-vs-amplitude-two-distinct-levers","title":"4) \u201cAction\u201d vs \u201camplitude\u201d: two distinct levers","text":"<p>A useful mental model is that the block separates two roles:</p> <ul> <li>Amplitude / contribution: what each path proposes, via \\(W_k z + b_k\\).</li> <li>Phase (action-like): how proposals should interfere, via \\(e^{i\\alpha_k(z)}\\).</li> </ul> <p>The gates \\(g_k\\) act like a stable, normalized weighting (a measure-like control), while phases handle reinforcement/cancellation.</p> <p>The <code>phase_scale</code> hyperparameter is the cleanest \u201chow oscillatory are we allowed to be?\u201d dial: larger values create faster phase variation (more cancellation potential), smaller values make the block behave closer to a conventional gated mixture.</p>"},{"location":"appendix/surely_youre_joking/#5-real-targets-vs-complex-targets","title":"5) Real targets vs complex targets","text":"<p>Many PDE/physics problems have real-valued targets even when oscillations matter internally. FeynmaNN supports both:</p> <ul> <li>Real output (default): use the complex latent as internal representation and read out real features.</li> <li>Complex output (optional): keep the model complex through the final projection when the target is genuinely complex.</li> </ul> <p>Either way, the complex latent acts as a compact carrier of phase information that a purely real latent would need to encode indirectly.</p>"},{"location":"appendix/surely_youre_joking/#6-hyperparameters-how-to-reason-about-them","title":"6) Hyperparameters: how to reason about them","text":"<p>A few parameters have especially clear roles:</p> <ul> <li><code>num_paths</code> (\\(K\\)):</li> <li>Expressivity of the superposition. Larger \\(K\\) increases the number of simultaneously-available contributions.</li> <li> <p>Too small: behaves closer to a standard complex network. Too large: more compute/params and potentially harder optimization.</p> </li> <li> <p><code>phase_scale</code>:</p> </li> <li> <p>Interference strength. Higher means more oscillatory phase modulation; lower means smoother, more mixture-like behavior.</p> </li> <li> <p><code>width_action</code>:</p> </li> <li> <p>Capacity of the phase generator \\(\\alpha(z)\\). If too small, phases are blunt; if too large, phases can become overly chaotic early in training.</p> </li> <li> <p><code>depth</code>, <code>width_size</code>:</p> </li> <li> <p>Standard capacity knobs, with the twist that depth composes multiple interference steps.</p> </li> <li> <p><code>learn_gates</code>:</p> </li> <li>If enabled, the model learns stable mixture weights \\(g\\). If disabled, it behaves more like a uniform sum-over-paths and relies more on phases.</li> </ul>"},{"location":"appendix/surely_youre_joking/#7-beyond-physics","title":"7) Beyond Physics","text":"<p>Beyond the physics, the FeynmaNN (FeyNN for short) can also be used as a drop-in new base architecture alongside MLP and KAN regardless of application, and can offer substantial improvements.</p> <p>Try it out!</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>This section contains end-to-end \u201crecipes\u201d that all follow the same core pattern:</p> <p>1) choose a labeled domain \\(\\Omega\\) and one or more components \\(\\Omega_i\\subseteq\\Omega\\), 2) define fields as <code>DomainFunction</code>s on \\(\\Omega\\), 3) build residual operators \\(r=\\mathcal{N}(u,\\dots)\\), 4) turn residuals into constraint terms by sampling + reduction, 5) assemble a <code>FunctionalSolver</code> and optimize.</p> <p>The goal is to show how Phydrax unifies \u201cSciML modes\u201d (PINNs, inverse problems, hybrid physics\u2013data, operator learning) via the same mathematical contract: minimize functionals over domains.</p> <p>Info</p> <p>The cookbook examples are meant to demonstrate basic workflows/recipes structurally. Real workloads typically need larger numbers of collocation points and iterations, and often benefit from architecture and hyperparameter tuning for optimal accuracy and stability.</p>"},{"location":"cookbook/#how-to-choose-a-workflow","title":"How to choose a workflow","text":""},{"location":"cookbook/#point-batches-vs-coord-separable-grids","title":"Point batches vs coord-separable grids","text":"<ul> <li>Use paired point sampling (<code>PointsBatch</code>) for most PINN-style collocation and scattered data.</li> <li>Use coord-separable sampling (<code>CoordSeparableBatch</code>) for spectral/basis operators and neural operators   (DeepONet/FNO-style), where you want explicit axis semantics and grid evaluation.</li> </ul> <p>See Guides \u2192 Domains and sampling.</p>"},{"location":"cookbook/#soft-constraints-vs-enforced-constraints","title":"Soft constraints vs enforced constraints","text":"<p>For boundary/initial conditions you can either:</p> <ul> <li>add penalty terms (soft constraints), or</li> <li>build an enforced ansatz \\(\\tilde u=\\mathcal{H}(u)\\) and train only on the remaining terms.</li> </ul> <p>See API \u2192 Constraints \u2192 Enforced constraint ans\u00e4tze and API \u2192 Solver \u2192 Enforced constraint pipelines.</p>"},{"location":"cookbook/#differentiation-backends","title":"Differentiation backends","text":"<p>Differential operators support multiple backends (<code>backend=\"ad\"|\"jet\"|\"fd\"|\"basis\"</code>) and autodiff modes (<code>mode=\"reverse\"|\"forward\"</code>). For deep math notes, see Appendix \u2192 Differentiation modes.</p>"},{"location":"cookbook/#recipes","title":"Recipes","text":"<ul> <li>Poisson (field learning, soft vs enforced BC)</li> <li>Heat equation (space\u2013time, initial conditions, optional sensors)</li> <li>Inverse problems + hybrid physics\u2013data</li> <li>Operator learning (DatasetDomain \u00d7 coordinates)</li> </ul>"},{"location":"cookbook/heat/","title":"Heat equation (space\u2013time)","text":"<p>This recipe shows a simple parabolic PDE on a space\u2013time product domain, including an initial condition term and an optional sensor/anchor data term.</p>"},{"location":"cookbook/heat/#problem","title":"Problem","text":"<p>On \\(\\Omega=[0,1]\\times[0,T]\\), solve</p> \\[ \\partial_t u - \\alpha\\,\\partial_{xx}u = 0, \\] <p>with boundary/initial conditions</p> \\[ u(0,t)=u(1,t)=0,\\qquad u(x,0)=u_0(x)=\\sin(\\pi x). \\]"},{"location":"cookbook/heat/#domain-and-fields","title":"Domain and fields","text":"<p>Let \\(x\\in[0,1]\\), \\(t\\in[0,T]\\). In Phydrax:</p> <ul> <li><code>Interval1d(0,1)</code> is a 1D geometry (label <code>\"x\"</code>).</li> <li><code>TimeInterval(0,T)</code> is a scalar domain (label <code>\"t\"</code>).</li> <li><code>domain = geom @ time</code> is the product.</li> </ul>"},{"location":"cookbook/heat/#a-basic-training-setup-soft-bc-initial-term","title":"A basic training setup (soft BC + initial term)","text":"<p>Example</p> <pre><code>import jax.numpy as jnp\nimport jax.random as jr\nimport optax\nimport phydrax as phx\n\nalpha = 0.1\nT = 1.0\n\ngeom = phx.domain.Interval1d(0.0, 1.0)\ntime = phx.domain.TimeInterval(0.0, T)\ndomain = geom @ time\n\ndef u0(x):\n    return jnp.sin(jnp.pi * x[0])\n\nmodel = phx.nn.MLP(in_size=2, out_size=\"scalar\", width_size=16, depth=2, key=jr.key(0))\nu = domain.Model(\"x\", \"t\")(model)\n\nstructure_xt = phx.domain.ProductStructure(((\"x\", \"t\"),))\nstructure_x = phx.domain.ProductStructure(((\"x\",),))\n\n# PDE residual: u_t - alpha * u_xx = 0\npde = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    domain,\n    operator=lambda f: phx.operators.dt(f, var=\"t\") - alpha * phx.operators.laplacian(f, var=\"x\"),\n    num_points=128,\n    structure=structure_xt,\n    reduction=\"mean\",\n)\n\n# Dirichlet boundary at x endpoints (soft)\nboundary = domain.component({\"x\": phx.domain.Boundary()})\nbc = phx.constraints.ContinuousDirichletBoundaryConstraint(\n    \"u\",\n    boundary,\n    target=0.0,\n    num_points=64,\n    structure=structure_xt,\n    weight=10.0,\n    reduction=\"mean\",\n)\n\n# Initial condition u(x,0) = u0(x)\nic = phx.constraints.ContinuousInitialFunctionConstraint(\n    \"u\",\n    domain,\n    func=u0,\n    evolution_var=\"t\",\n    time_derivative_order=0,\n    num_points=32,\n    structure=structure_x,\n    weight=10.0,\n    reduction=\"mean\",\n)\n\nsolver = phx.solver.FunctionalSolver(functions={\"u\": u}, constraints=[pde, bc, ic])\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\n</code></pre>"},{"location":"cookbook/heat/#higher-order-initial-data","title":"Higher-order initial data","text":"<p>To constrain \\(\\partial_t^k u(\\cdot,0)\\) for \\(k&gt;0\\), use <code>time_derivative_order=k</code>. For high-order time derivatives, <code>time_derivative_backend=\"jet\"</code> can be more direct than nested Jacobians.</p>"},{"location":"cookbook/heat/#adding-sensors-time-tracks-or-anchors-scattered-data","title":"Adding sensors (time tracks) or anchors (scattered data)","text":"<p>For discrete measurements, add a data-fit constraint alongside the PDE terms. Phydrax supports:</p> <ul> <li>Anchors: scattered \\((x_i,t_i)\\mapsto y_i\\).</li> <li>Sensor tracks: fixed sensors \\(x_m\\) with measurements over time \\(y_m(t_j)\\).</li> </ul> <p>Example</p> <p>Sensor tracks via <code>DiscreteInteriorDataConstraint</code>:</p> <pre><code>import jax.numpy as jnp\nimport phydrax as phx\n\nsensors = jnp.array([[0.25], [0.75]])     # M sensors in 1D\ntimes = jnp.linspace(0.0, T, 51)          # T time points\nsensor_values = jnp.zeros((2, 51))        # shape (M, T) for scalar u\n\ndata = phx.constraints.DiscreteInteriorDataConstraint(\n    \"u\",\n    domain,\n    sensors=sensors,\n    times=times,\n    sensor_values=sensor_values,\n    num_points=256,\n    structure=structure_xt,\n    weight=1.0,\n)\n</code></pre> <p>See API \u2192 Constraints \u2192 Discrete.</p>"},{"location":"cookbook/inverse_and_data/","title":"Inverse problems + hybrid physics\u2013data","text":"<p>This recipe illustrates a common \u201cSciML inverse\u201d pattern: learn a state \\(u\\) and an unknown coefficient/parameter using a PDE residual plus data terms.</p>"},{"location":"cookbook/inverse_and_data/#problem-example","title":"Problem (example)","text":"<p>On a spatial domain \\(\\Omega\\), consider</p> \\[ -\\nabla\\cdot\\bigl(k(x)\\nabla u(x)\\bigr)=f(x)\\quad\\text{in }\\Omega,\\qquad u=g\\quad\\text{on }\\partial\\Omega, \\] <p>where \\(k\\) is unknown (either a scalar parameter or a field), and you also have sparse observations of \\(u\\).</p>"},{"location":"cookbook/inverse_and_data/#pattern-treat-unknowns-as-additional-fields","title":"Pattern: treat unknowns as additional fields","text":"<p>In Phydrax, you typically represent unknowns as additional <code>DomainFunction</code>s and couple them inside the residual operator. Everything is still \u201cminimize functionals over domains\u201d.</p>"},{"location":"cookbook/inverse_and_data/#example-skeleton-learn-u_theta-and-k_phi","title":"Example skeleton (learn \\(u_\\theta\\) and \\(k_\\phi\\))","text":"<p>Example</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport jax.random as jr\nimport optax\nimport phydrax as phx\n\ngeom = phx.domain.Square(center=(0.0, 0.0), side=2.0)  # \u03a9=[-1,1]^2\n\n# Known forcing and boundary value (toy choices)\n@geom.Function(\"x\")\ndef f(x):\n    return 1.0\n\n@geom.Function(\"x\")\ndef g(x):\n    return 0.0\n\n# State u(x) and unknown coefficient k(x) (positive via final activation)\nu_model = phx.nn.MLP(in_size=2, out_size=\"scalar\", width_size=16, depth=2, key=jr.key(0))\nk_model = phx.nn.MLP(\n    in_size=2,\n    out_size=\"scalar\",\n    width_size=16,\n    depth=2,\n    final_activation=jax.nn.softplus,\n    key=jr.key(1),\n)\n\nu = geom.Model(\"x\")(u_model)\nk = geom.Model(\"x\")(k_model)\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\n\ndef pde_operator(u_f, k_f):\n    grad_u = phx.operators.grad(u_f, var=\"x\")      # \u2207u (vector)\n    flux = k_f * grad_u                            # k\u2207u\n    return -phx.operators.div(flux, var=\"x\") - f    # -\u2207\u00b7(k\u2207u) - f\n\npde = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    (\"u\", \"k\"),\n    geom,\n    operator=pde_operator,\n    num_points=128,\n    structure=structure,\n    reduction=\"mean\",\n)\n\nboundary = geom.component({\"x\": phx.domain.Boundary()})\nbc = phx.constraints.ContinuousDirichletBoundaryConstraint(\n    \"u\",\n    boundary,\n    target=g,\n    num_points=64,\n    structure=structure,\n    weight=10.0,\n)\n\n# Optional anchor data for u at scattered points\nanchors = jnp.array([[0.0, 0.0], [0.5, -0.25]])\nvalues = jnp.array([0.0, 0.1])\ndata = phx.constraints.DiscreteInteriorDataConstraint(\n    \"u\",\n    geom,\n    points={\"x\": anchors},\n    values=values,\n    weight=1.0,\n)\n\nsolver = phx.solver.FunctionalSolver(functions={\"u\": u, \"k\": k}, constraints=[pde, bc, data])\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\n</code></pre>"},{"location":"cookbook/inverse_and_data/#notes","title":"Notes","text":"<ul> <li>For scalar unknown parameters (global coefficients), consider <code>domain.Parameter(...)</code> for a trainable constant.</li> <li>If you want to enforce \\(u=g\\) exactly, replace the boundary penalty with an enforced term (see the Poisson recipe).</li> <li>For sensor tracks over time, use <code>DiscreteInteriorDataConstraint(..., sensors=..., times=..., sensor_values=...)</code>.</li> </ul>"},{"location":"cookbook/operator_learning/","title":"Operator learning (DatasetDomain \u00d7 coordinates)","text":"<p>This recipe shows the \u201coperator-learning\u201d decomposition</p> \\[ \\Omega \\;=\\; \\Omega_{\\text{data}}\\times\\Omega_x\\times\\cdots, \\] <p>where \\(\\Omega_{\\text{data}}\\) indexes a dataset of inputs (forcing, coefficients, initial conditions, etc.) and \\(\\Omega_x\\) is the coordinate domain where you evaluate outputs.</p> <p>In Phydrax, \\(\\Omega_{\\text{data}}\\) is represented by <code>DatasetDomain</code>, and operator models are wrapped via <code>Domain.Model(...)</code> so they can be used like any other <code>DomainFunction</code>.</p>"},{"location":"cookbook/operator_learning/#dataset-factor","title":"Dataset factor","text":"<p><code>DatasetDomain</code> stores an in-memory PyTree of arrays with a shared leading dataset axis, and samples by indexing. See API \u2192 Domain \u2192 Composition.</p>"},{"location":"cookbook/operator_learning/#deeponet-skeleton-on-omega_textdatatimesomega_x","title":"DeepONet skeleton on \\(\\Omega_{\\text{data}}\\times\\Omega_x\\)","text":"<p>Assume each dataset sample contains a vector of coefficients \\(c\\in\\mathbb{R}^K\\) that parameterizes an input. For this runnable example, we choose a simple analytic \u201coperator\u201d that maps \\(c\\) to a 1D field \\(u(x)=\\sum_{k=1}^K c_k \\sin(k\\pi x)\\).</p> <p>Example</p> <pre><code>import jax.numpy as jnp\nimport jax.random as jr\nimport optax\nimport phydrax as phx\n\nkey = jr.key(0)\n\n# N dataset samples, each carrying K coefficients.\nN = 32\nK = 8\ncoeffs = jr.normal(key, shape=(N, K))\n\ndata_dom = phx.domain.DatasetDomain(coeffs, label=\"data\", measure=\"probability\")\ngeom = phx.domain.Interval1d(0.0, 1.0)\ndomain = data_dom @ geom\n\nlatent = 32\nbranch = phx.nn.MLP(in_size=K, out_size=latent, width_size=64, depth=2, key=jr.key(1))\ntrunk = phx.nn.MLP(in_size=1, out_size=latent, width_size=64, depth=2, key=jr.key(2))\ndeeponet = phx.nn.DeepONet(branch=branch, trunk=trunk, coord_dim=1, latent_size=latent)\n\n# u_hat(data, x): predicted field on the x-axis for each dataset sample\nu_hat = domain.Model(\"data\", \"x\", structured=True)(deeponet)\n\n# Supervised target u_true(data, x): analytic mapping from coefficients to a function of x\n@domain.Function(\"data\", \"x\")\ndef u_true(c, x):\n    x_axis = x[0]\n    ks = jnp.arange(1, K + 1, dtype=float)\n    basis = jnp.sin(jnp.pi * ks[:, None] * x_axis[None, :])  # (K, nx)\n    return basis.T @ c  # (nx,)\n\n# Supervised residual on \u03a9_data \u00d7 \u03a9_x.\ndef residual(u_f):\n    return u_f - u_true\n\n# Build a grid-aligned supervised loss by sampling data densely and x as a coord-separable axis.\nnx = 32\nconstraint = phx.constraints.FunctionalConstraint.from_operator(\n    component=domain.component(),\n    operator=residual,\n    constraint_vars=\"u\",\n    num_points=8,  # number of dataset samples per step\n    structure=phx.domain.ProductStructure(((\"data\", \"x\"),)),\n    coord_separable={\"x\": phx.domain.UniformAxisSpec(nx)},\n    dense_structure=phx.domain.ProductStructure(((\"data\",),)),\n    reduction=\"mean\",\n)\n\nsolver = phx.solver.FunctionalSolver(functions={\"u\": u_hat}, constraints=[constraint])\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\n</code></pre> <p>Note</p> <p>This page focuses on the domain/model wiring. For structured-input conventions and operator architectures (DeepONet/FNO), see API \u2192 NN \u2192 Architectures. For sampling semantics, see Guides \u2192 Domains and sampling.</p>"},{"location":"cookbook/poisson/","title":"Poisson on a square (field learning)","text":"<p>This recipe solves a simple elliptic PDE by learning a field \\(u_\\theta(x)\\).</p>"},{"location":"cookbook/poisson/#problem","title":"Problem","text":"<p>Let \\(\\Omega=[-1,1]^2\\). We solve</p> \\[ \\Delta u = 4 \\quad \\text{in }\\Omega,\\qquad u = g \\quad \\text{on }\\partial\\Omega, \\] <p>with \\(g(x,y)=x^2+y^2\\). The exact solution is \\(u^\\star(x,y)=x^2+y^2\\).</p>"},{"location":"cookbook/poisson/#domain-and-components","title":"Domain and components","text":"<ul> <li>Domain: <code>Square(center=(0,0), side=2)</code> (label <code>\"x\"</code> with \\(d=2\\)).</li> <li>Interior component: <code>geom.component()</code> (default).</li> <li>Boundary component: <code>geom.component({\"x\": Boundary()})</code>.</li> </ul>"},{"location":"cookbook/poisson/#soft-pinn-pde-residual-boundary-penalty","title":"Soft PINN (PDE residual + boundary penalty)","text":"<p>Example</p> <pre><code>import jax.random as jr\nimport optax\nimport phydrax as phx\n\ngeom = phx.domain.Square(center=(0.0, 0.0), side=2.0)\n\n@geom.Function(\"x\")\ndef g(x):\n    return x[0] ** 2 + x[1] ** 2\n\nmodel = phx.nn.MLP(in_size=2, out_size=\"scalar\", width_size=16, depth=2, key=jr.key(0))\nu = geom.Model(\"x\")(model)\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\n\npde = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    geom,\n    operator=lambda f: phx.operators.laplacian(f, var=\"x\") - 4.0,\n    num_points=64,\n    structure=structure,\n    reduction=\"mean\",\n)\n\nboundary = geom.component({\"x\": phx.domain.Boundary()})\nbc = phx.constraints.ContinuousDirichletBoundaryConstraint(\n    \"u\",\n    boundary,\n    target=g,\n    num_points=32,\n    structure=structure,\n    weight=10.0,\n    reduction=\"mean\",\n)\n\nsolver = phx.solver.FunctionalSolver(functions={\"u\": u}, constraints=[pde, bc])\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\n</code></pre>"},{"location":"cookbook/poisson/#enforced-dirichlet-boundary-ansatz-interior-residual","title":"Enforced Dirichlet boundary (ansatz + interior residual)","text":"<p>Instead of penalizing boundary mismatch, enforce \\(u=g\\) by construction using <code>enforce_dirichlet</code>, staged by an <code>EnforcedConstraintPipeline</code> (via <code>constraint_terms=...</code>).</p> <p>Example</p> <pre><code>import jax.random as jr\nimport optax\nimport phydrax as phx\n\ngeom = phx.domain.Square(center=(0.0, 0.0), side=2.0)\n\n@geom.Function(\"x\")\ndef g(x):\n    return x[0] ** 2 + x[1] ** 2\n\nmodel = phx.nn.MLP(in_size=2, out_size=\"scalar\", width_size=16, depth=2, key=jr.key(0))\nu = geom.Model(\"x\")(model)\n\nstructure = phx.domain.ProductStructure(((\"x\",),))\npde = phx.constraints.ContinuousPointwiseInteriorConstraint(\n    \"u\",\n    geom,\n    operator=lambda f: phx.operators.laplacian(f, var=\"x\") - 4.0,\n    num_points=64,\n    structure=structure,\n)\n\nboundary = geom.component({\"x\": phx.domain.Boundary()})\nterm = phx.solver.SingleFieldEnforcedConstraint(\n    \"u\",\n    boundary,\n    lambda f: phx.constraints.enforce_dirichlet(f, boundary, var=\"x\", target=g),\n)\n\nsolver = phx.solver.FunctionalSolver(\n    functions={\"u\": u},\n    constraints=[pde],\n    constraint_terms=[term],\n    boundary_weight_num_reference=128,\n    boundary_weight_key=jr.key(1),\n)\nsolver = solver.solve(num_iter=20, optim=optax.adam(1e-3), seed=0)\n</code></pre>"},{"location":"cookbook/poisson/#grid-evaluation-coord-separable-batches","title":"Grid evaluation (coord-separable batches)","text":"<p>When you want axis-aware evaluation (e.g. spectral/basis derivatives, operator learning), sample coordinate axes and evaluate on the implied Cartesian grid. For a 2D geometry label <code>\"x\"</code>, coord-separable sampling provides a tuple \\((x_{\\text{axis}},y_{\\text{axis}})\\).</p> <p>Example</p> <pre><code>import jax.random as jr\nimport phydrax as phx\n\n# Basis/FD backends require the field to support structured inputs (a tuple of 1D axes).\n# Use a structured model like SeparableMLP/FNO/DeepONet for grid-native evaluation.\ngeom = phx.domain.Square(center=(0.0, 0.0), side=2.0)\nmodel = phx.nn.SeparableMLP(\n    in_size=2,\n    out_size=\"scalar\",\n    latent_size=16,\n    width_size=16,\n    depth=2,\n    key=jr.key(0),\n)\nu = geom.Model(\"x\")(model)\n\nbatch = geom.component().sample_coord_separable({\"x\": (32, 32)}, key=jr.key(1))\n\n# Evaluate a basis-aware Laplacian on the grid.\ndu = phx.operators.laplacian(u, var=\"x\", backend=\"basis\", basis=\"poly\")\nout = du(batch)\n</code></pre> <p>See Guides \u2192 Domains and sampling and Guides \u2192 Differential operators.</p>"},{"location":"misc/nondimensionalization/","title":"Nondimensionalization","text":"<p>Nondimensionalization is common in many engineering and physics problems: it improves numerical conditioning, makes parameter scales explicit, and helps compare regimes across systems.</p> <p>Mathematically, you choose characteristic scales (e.g. length \\(L\\), time \\(T\\), and state scale \\(U\\)) and define dimensionless variables \\(\\hat{x},\\hat{t},\\hat{u}\\) via</p> \\[ x = L\\hat{x},\\qquad t = T\\hat{t},\\qquad u = U\\hat{u}. \\] <p>Derivatives transform by the chain rule, e.g.</p> \\[ \\begin{aligned} \\frac{\\partial}{\\partial t} &amp;= \\frac{1}{T}\\frac{\\partial}{\\partial \\hat{t}}, \\\\ \\frac{\\partial}{\\partial x} &amp;= \\frac{1}{L}\\frac{\\partial}{\\partial \\hat{x}}, \\\\ \\frac{\\partial^2}{\\partial x^2} &amp;= \\frac{1}{L^2}\\frac{\\partial^2}{\\partial \\hat{x}^2}. \\end{aligned} \\] <p>Substitute these into the governing equations and divide through by a reference scale; the remaining coefficients become dimensionless groups (e.g. Reynolds and P\u00e9clet numbers) that control the behavior. Convert back by undoing the scaling (\\(x=L\\hat{x}\\), \\(t=T\\hat{t}\\), \\(u=U\\hat{u}\\)).</p> <p>We recommend using <code>unxt</code> for units, conversions, and nondimensionalization workflows.</p>"}]}